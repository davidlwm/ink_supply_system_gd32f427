# 通信接口规范文档

## 版本信息
- **版本**: V4.0
- **日期**: 2025-09-27
- **项目**: ink_supply_system_gd32f427
- **标准**: 8周v4标准

## 1. 文档概述

本文档详细规定了供墨系统与外部设备通信的接口规范，包括硬件接口、软件接口、数据格式、通信协议和集成要求。为上位机软件开发、系统集成和第三方设备接入提供标准化的技术规范。

## 2. 接口架构总览

### 2.1 接口分层架构

```
应用接口层 (Application Interface Layer)
├── RESTful API接口
├── WebSocket实时接口
├── SDK软件开发包
└── 配置管理接口

协议接口层 (Protocol Interface Layer)
├── EtherCAT从站接口
├── Modbus TCP服务器接口
├── 自定义TCP协议接口
└── UDP广播发现接口

网络接口层 (Network Interface Layer)
├── 以太网物理接口
├── 网络配置接口
├── 安全传输接口
└── 网络诊断接口

硬件接口层 (Hardware Interface Layer)
├── GPIO数字接口
├── 模拟信号接口
├── 串行通信接口
└── 电源管理接口
```

### 2.2 接口映射关系

```
外部设备类型          支持的接口类型              主要用途
──────────────────────────────────────────────────────
工业控制系统         EtherCAT + Modbus TCP      实时控制和监控
SCADA系统           Modbus TCP + RESTful API   数据采集和监控
MES系统             RESTful API + WebSocket    生产管理集成
HMI人机界面         WebSocket + RESTful API    操作界面和显示
移动设备App         RESTful API + WebSocket    远程监控和控制
第三方传感器        GPIO + 串口 + 模拟信号      数据采集扩展
云平台              RESTful API + MQTT         云端数据同步
维护工具            SDK + 调试接口              系统诊断维护
```

## 3. EtherCAT接口规范

### 3.1 EtherCAT硬件接口规范

#### 3.1.1 物理接口规格
```
接口类型: RJ45以太网接口
连接器: 标准RJ45-8P8C
传输介质: Cat5e或更高等级双绞线
传输速率: 100Mbps全双工
最大传输距离: 100米 (点对点)
供电方式: 独立供电 (不支持PoE)

引脚定义:
Pin 1 (橙白): TX+ (发送正)
Pin 2 (橙):   TX- (发送负)
Pin 3 (绿白): RX+ (接收正)
Pin 4 (蓝):   未使用
Pin 5 (蓝白): 未使用
Pin 6 (绿):   RX- (接收负)
Pin 7 (棕白): 未使用
Pin 8 (棕):   未使用
```

#### 3.1.2 电气特性
```
工作电压: 3.3V LVDS信号
信号电平:
  - 逻辑高电平: 2.4V ~ 3.6V
  - 逻辑低电平: -0.3V ~ 0.8V
差分电压: ±350mV典型值
共模电压: 1.2V ± 0.1V
输入阻抗: 100Ω ± 15%
上升/下降时间: ≤ 5ns
传输延迟: ≤ 30ns
```

### 3.2 EtherCAT软件接口规范

#### 3.2.1 设备标识信息
```c
// ESI (EtherCAT Slave Information) 设备信息
typedef struct {
    uint16_t vendor_id;         // 厂商ID: 0x5453 ('TS')
    uint32_t product_code;      // 产品代码: 0x20240001
    uint32_t revision_number;   // 版本号: 0x00040000 (V4.0)
    uint32_t serial_number;     // 序列号: 唯一标识
    uint16_t alias_address;     // 别名地址: 0x0000 (自动分配)
    char device_name[32];       // 设备名称: "InkSupplySystem_GD32F427"
    char vendor_name[32];       // 厂商名称: "TechnoSolutions"
    char product_description[64]; // 产品描述
} ethercat_device_info_t;

// 设备类型分类
#define ETHERCAT_DEVICE_TYPE_PROCESS_CONTROL    0x43120000
#define ETHERCAT_DEVICE_PROFILE_DS402           402  // 驱动设备规范
```

#### 3.2.2 对象字典定义

##### 通信区对象 (0x1000-0x1FFF)
```c
// 设备类型 (0x1000)
#define OD_DEVICE_TYPE              0x1000
#define DEVICE_TYPE_VALUE           0x43120000  // 过程控制设备

// 错误寄存器 (0x1001)
#define OD_ERROR_REGISTER           0x1001
typedef union {
    uint8_t value;
    struct {
        uint8_t generic_error       : 1;  // 通用错误
        uint8_t current_error       : 1;  // 电流错误
        uint8_t voltage_error       : 1;  // 电压错误
        uint8_t temperature_error   : 1;  // 温度错误
        uint8_t communication_error : 1;  // 通信错误
        uint8_t device_profile_error: 1;  // 设备配置错误
        uint8_t reserved            : 1;  // 保留
        uint8_t manufacturer_error  : 1;  // 厂商特定错误
    } bits;
} error_register_t;

// 同步管理器通信类型 (0x1C00-0x1C03)
#define OD_SM0_COMMUNICATION_TYPE   0x1C00  // Mailbox Out
#define OD_SM1_COMMUNICATION_TYPE   0x1C01  // Mailbox In
#define OD_SM2_COMMUNICATION_TYPE   0x1C02  // Process Data Out
#define OD_SM3_COMMUNICATION_TYPE   0x1C03  // Process Data In

// PDO分配 (0x1C10-0x1C13)
#define OD_SM0_PDO_ASSIGNMENT       0x1C10
#define OD_SM1_PDO_ASSIGNMENT       0x1C11
#define OD_SM2_PDO_ASSIGNMENT       0x1C12  // 输出PDO分配
#define OD_SM3_PDO_ASSIGNMENT       0x1C13  // 输入PDO分配
```

##### 制造商特定区 (0x2000-0x5FFF)
```c
// 系统配置参数 (0x2000-0x20FF)
#define OD_SYSTEM_CONFIG_BASE       0x2000

typedef struct {
    uint32_t system_mode;           // 0x2000: 系统工作模式
    uint32_t control_word;          // 0x2001: 控制字
    uint32_t status_word;           // 0x2002: 状态字
    float temperature_targets[3];   // 0x2003-0x2005: 温度目标值
    float pressure_targets[2];      // 0x2006-0x2007: 压力目标值
    float level_targets[2];         // 0x2008-0x2009: 液位目标值
    uint32_t safety_config;         // 0x200A: 安全配置
    uint32_t diagnostic_mode;       // 0x200B: 诊断模式
} system_config_objects_t;

// 传感器校准参数 (0x2100-0x21FF)
#define OD_SENSOR_CALIB_BASE        0x2100

typedef struct {
    float temperature_offset[3];    // 温度传感器偏移
    float temperature_scale[3];     // 温度传感器缩放
    float pressure_offset[2];       // 压力传感器偏移
    float pressure_scale[2];        // 压力传感器缩放
    float level_offset[2];          // 液位传感器偏移
    float level_scale[2];           // 液位传感器缩放
} sensor_calibration_objects_t;

// 控制器参数 (0x2200-0x22FF)
#define OD_CONTROLLER_PARAM_BASE    0x2200

typedef struct {
    float pid_kp[5];               // PID比例参数
    float pid_ki[5];               // PID积分参数
    float pid_kd[5];               // PID微分参数
    uint32_t control_period_ms;    // 控制周期
    float output_limits[5];        // 输出限制
} controller_param_objects_t;
```

#### 3.2.3 PDO映射规范

##### 输出PDO (主站→从站)
```c
// TxPDO 1 (0x1600): 控制命令
typedef struct {
    uint32_t control_word;          // 控制字
    float temperature_setpoint[3];  // 温度设定值
    float pressure_setpoint[2];     // 压力设定值
    float level_setpoint[2];        // 液位设定值
    uint16_t pump_speed[2];         // 泵速设定
    uint16_t heater_power[3];       // 加热器功率
    uint8_t valve_control;          // 阀门控制
    uint8_t reserved;               // 保留字节
} __attribute__((packed)) ethercat_output_pdo1_t;  // 总大小: 64字节

// TxPDO 2 (0x1601): 参数设置
typedef struct {
    uint32_t parameter_index;       // 参数索引
    uint32_t parameter_value;       // 参数值
    uint32_t parameter_command;     // 参数命令
    uint8_t reserved[20];           // 保留区域
} __attribute__((packed)) ethercat_output_pdo2_t;  // 总大小: 32字节
```

##### 输入PDO (从站→主站)
```c
// RxPDO 1 (0x1A00): 传感器数据
typedef struct {
    uint32_t status_word;           // 状态字
    float temperature_actual[3];    // 实际温度值
    float pressure_actual[2];       // 实际压力值
    float level_actual[2];          // 实际液位值
    uint16_t pump_speed_actual[2];  // 实际泵速
    uint16_t heater_power_actual[3]; // 实际加热器功率
    uint8_t valve_status;           // 阀门状态
    uint8_t sensor_status;          // 传感器状态
    uint32_t timestamp;             // 时间戳
} __attribute__((packed)) ethercat_input_pdo1_t;   // 总大小: 64字节

// RxPDO 2 (0x1A01): 系统状态
typedef struct {
    uint32_t fault_code;            // 故障代码
    uint32_t warning_code;          // 警告代码
    float system_efficiency;        // 系统效率
    uint32_t operation_hours;       // 运行小时数
    uint16_t cycle_counter;         // 周期计数器
    uint8_t system_mode;            // 系统模式
    uint8_t reserved;               // 保留字节
} __attribute__((packed)) ethercat_input_pdo2_t;   // 总大小: 20字节
```

## 4. Modbus TCP接口规范

### 4.1 Modbus TCP网络配置

#### 4.1.1 网络参数
```
默认IP地址: 192.168.1.100
子网掩码: 255.255.255.0
默认网关: 192.168.1.1
DNS服务器: 192.168.1.1
TCP端口: 502 (标准Modbus端口)
单元标识符: 1
最大连接数: 10个并发连接
超时时间: 5秒
```

#### 4.1.2 Modbus功能码支持
```
支持的功能码:
┌─────────┬─────────────────────┬──────────────────────┐
│ 功能码  │ 功能描述            │ 数据区域             │
├─────────┼─────────────────────┼──────────────────────┤
│ 0x01    │ 读线圈状态          │ 0x0000-0x00FF (256)  │
│ 0x02    │ 读离散输入状态      │ 0x0000-0x00FF (256)  │
│ 0x03    │ 读保持寄存器        │ 0x0000-0x7FFF (32K)  │
│ 0x04    │ 读输入寄存器        │ 0x0000-0x7FFF (32K)  │
│ 0x05    │ 写单个线圈          │ 0x0000-0x00FF (256)  │
│ 0x06    │ 写单个保持寄存器    │ 0x0000-0x7FFF (32K)  │
│ 0x0F    │ 写多个线圈          │ 0x0000-0x00FF (256)  │
│ 0x10    │ 写多个保持寄存器    │ 0x0000-0x7FFF (32K)  │
│ 0x17    │ 读写多个寄存器      │ 支持混合操作         │
│ 0x2B/0E │ 读设备标识          │ 设备信息查询         │
└─────────┴─────────────────────┴──────────────────────┘

不支持的功能码将返回异常响应 0x01 (非法功能)
```

### 4.2 Modbus数据地址映射

#### 4.2.1 线圈区域 (0x0000-0x00FF)
```c
// 数字输出控制线圈
typedef struct {
    // 0x0000-0x000F: 加热器控制
    bool heater_enable[3];          // 0x0000-0x0002: 加热器使能
    bool reserved_heater[13];       // 0x0003-0x000F: 保留

    // 0x0010-0x001F: 泵控制
    bool pump_enable[2];            // 0x0010-0x0011: 泵使能
    bool pump_direction[2];         // 0x0012-0x0013: 泵方向
    bool reserved_pump[12];         // 0x0014-0x001F: 保留

    // 0x0020-0x002F: 阀门控制
    bool valve_open[2];             // 0x0020-0x0021: 阀门开启
    bool valve_close[2];            // 0x0022-0x0023: 阀门关闭
    bool reserved_valve[12];        // 0x0024-0x002F: 保留

    // 0x0030-0x003F: 系统控制
    bool system_enable;             // 0x0030: 系统使能
    bool emergency_stop;            // 0x0031: 紧急停止
    bool fault_reset;               // 0x0032: 故障复位
    bool calibration_mode;          // 0x0033: 校准模式
    bool maintenance_mode;          // 0x0034: 维护模式
    bool reserved_system[11];       // 0x0035-0x003F: 保留

    // 0x0040-0x00FF: 扩展控制区域 (用户自定义)
    bool user_defined[192];         // 用户自定义控制位
} modbus_coil_map_t;
```

#### 4.2.2 离散输入区域 (0x0000-0x00FF)
```c
// 数字输入状态
typedef struct {
    // 0x0000-0x000F: 传感器状态
    bool temperature_sensor_ok[3];  // 0x0000-0x0002: 温度传感器正常
    bool pressure_sensor_ok[2];     // 0x0003-0x0004: 压力传感器正常
    bool level_sensor_ok[2];        // 0x0005-0x0006: 液位传感器正常
    bool reserved_sensor[9];        // 0x0007-0x000F: 保留

    // 0x0010-0x001F: 执行器状态
    bool heater_running[3];         // 0x0010-0x0012: 加热器运行
    bool pump_running[2];           // 0x0013-0x0014: 泵运行
    bool valve_open_fb[2];          // 0x0015-0x0016: 阀门开启反馈
    bool valve_close_fb[2];         // 0x0017-0x0018: 阀门关闭反馈
    bool reserved_actuator[7];      // 0x0019-0x001F: 保留

    // 0x0020-0x002F: 系统状态
    bool system_ready;              // 0x0020: 系统就绪
    bool system_running;            // 0x0021: 系统运行
    bool system_fault;              // 0x0022: 系统故障
    bool system_warning;            // 0x0023: 系统警告
    bool emergency_active;          // 0x0024: 紧急状态激活
    bool maintenance_required;      // 0x0025: 需要维护
    bool calibration_required;      // 0x0026: 需要校准
    bool reserved_status[9];        // 0x0027-0x002F: 保留

    // 0x0030-0x00FF: 扩展状态区域
    bool extended_status[208];      // 扩展状态位
} modbus_discrete_input_map_t;
```

#### 4.2.3 输入寄存器区域 (0x0000-0x7FFF)
```c
// 传感器数据和状态信息 (只读)
typedef struct {
    // 0x0000-0x001F: 传感器原始值
    uint16_t temperature_raw[3];    // 0x0000-0x0002: 温度传感器原始值
    uint16_t pressure_raw[2];       // 0x0003-0x0004: 压力传感器原始值
    uint16_t level_raw[2];          // 0x0005-0x0006: 液位传感器原始值
    uint16_t reserved_raw[25];      // 0x0007-0x001F: 保留

    // 0x0020-0x003F: 传感器工程值 (IEEE 754浮点格式，每个占2个寄存器)
    uint16_t temperature_float[6];  // 0x0020-0x0025: 温度值 (3×2寄存器)
    uint16_t pressure_float[4];     // 0x0026-0x0029: 压力值 (2×2寄存器)
    uint16_t level_float[4];        // 0x002A-0x002D: 液位值 (2×2寄存器)
    uint16_t reserved_float[18];    // 0x002E-0x003F: 保留

    // 0x0040-0x005F: 执行器反馈
    uint16_t heater_power_fb[3];    // 0x0040-0x0042: 加热器功率反馈
    uint16_t pump_speed_fb[2];      // 0x0043-0x0044: 泵速反馈
    uint16_t valve_position_fb[2];  // 0x0045-0x0046: 阀门位置反馈
    uint16_t reserved_actuator[25]; // 0x0047-0x005F: 保留

    // 0x0060-0x007F: 系统状态
    uint16_t system_status;         // 0x0060: 系统状态字
    uint16_t fault_code;            // 0x0061: 故障代码
    uint16_t warning_code;          // 0x0062: 警告代码
    uint16_t operation_mode;        // 0x0063: 运行模式
    uint16_t cycle_counter;         // 0x0064: 周期计数器
    uint16_t temperature_avg;       // 0x0065: 平均温度
    uint16_t pressure_avg;          // 0x0066: 平均压力
    uint16_t efficiency_percent;    // 0x0067: 系统效率(%)
    uint16_t uptime_hours_low;      // 0x0068: 运行时间低16位
    uint16_t uptime_hours_high;     // 0x0069: 运行时间高16位
    uint16_t reserved_status[22];   // 0x006A-0x007F: 保留

    // 0x0080-0x00FF: 诊断数据
    uint16_t cpu_usage_percent;     // 0x0080: CPU使用率(%)
    uint16_t memory_usage_percent;  // 0x0081: 内存使用率(%)
    uint16_t network_tx_kbps;       // 0x0082: 网络发送速率(kbps)
    uint16_t network_rx_kbps;       // 0x0083: 网络接收速率(kbps)
    uint16_t task_response_time[10]; // 0x0084-0x008D: 任务响应时间(ms)
    uint16_t reserved_diag[114];    // 0x008E-0x00FF: 保留
} modbus_input_register_map_t;
```

#### 4.2.4 保持寄存器区域 (0x0000-0x7FFF)
```c
// 配置参数和控制命令 (读写)
typedef struct {
    // 0x0000-0x001F: 设备标识
    uint16_t device_type;           // 0x0000: 设备类型
    uint16_t firmware_version;      // 0x0001: 固件版本
    uint16_t hardware_version;      // 0x0002: 硬件版本
    uint16_t serial_number_low;     // 0x0003: 序列号低16位
    uint16_t serial_number_high;    // 0x0004: 序列号高16位
    uint16_t manufacture_date;      // 0x0005: 制造日期 (YYMMDD)
    uint16_t calibration_date;      // 0x0006: 校准日期 (YYMMDD)
    uint16_t reserved_id[25];       // 0x0007-0x001F: 保留

    // 0x0020-0x003F: 控制设定值 (IEEE 754浮点格式)
    uint16_t temperature_setpoint[6]; // 0x0020-0x0025: 温度设定值
    uint16_t pressure_setpoint[4];    // 0x0026-0x0029: 压力设定值
    uint16_t level_setpoint[4];       // 0x002A-0x002D: 液位设定值
    uint16_t reserved_setpoint[18];   // 0x002E-0x003F: 保留

    // 0x0040-0x005F: 执行器控制
    uint16_t heater_power_cmd[3];   // 0x0040-0x0042: 加热器功率命令
    uint16_t pump_speed_cmd[2];     // 0x0043-0x0044: 泵速命令
    uint16_t valve_position_cmd[2]; // 0x0045-0x0046: 阀门位置命令
    uint16_t reserved_cmd[25];      // 0x0047-0x005F: 保留

    // 0x0060-0x007F: 系统控制
    uint16_t system_command;        // 0x0060: 系统命令字
    uint16_t operation_mode_cmd;    // 0x0061: 运行模式命令
    uint16_t safety_config;         // 0x0062: 安全配置
    uint16_t alarm_limits[10];      // 0x0063-0x006C: 报警限值
    uint16_t reserved_control[19];  // 0x006D-0x007F: 保留

    // 0x0080-0x00FF: PID参数配置
    uint16_t pid_kp[10];           // 0x0080-0x0089: PID比例参数(IEEE 754)
    uint16_t pid_ki[10];           // 0x008A-0x0093: PID积分参数(IEEE 754)
    uint16_t pid_kd[10];           // 0x0094-0x009D: PID微分参数(IEEE 754)
    uint16_t pid_output_limit[10]; // 0x009E-0x00A7: PID输出限制(IEEE 754)
    uint16_t reserved_pid[88];     // 0x00A8-0x00FF: 保留

    // 0x0100-0x01FF: 传感器校准参数
    uint16_t sensor_offset[20];     // 0x0100-0x0113: 传感器偏移(IEEE 754)
    uint16_t sensor_scale[20];      // 0x0114-0x0127: 传感器缩放(IEEE 754)
    uint16_t sensor_filter[20];     // 0x0128-0x013B: 传感器滤波(IEEE 754)
    uint16_t reserved_calib[196];   // 0x013C-0x01FF: 保留
} modbus_holding_register_map_t;
```

### 4.3 Modbus数据格式规范

#### 4.3.1 IEEE 754浮点数编码
```c
// 32位浮点数在Modbus中的存储格式 (大端序)
typedef union {
    float value;                    // 浮点值
    struct {
        uint16_t high_word;         // 高16位 (包含符号位和指数)
        uint16_t low_word;          // 低16位 (尾数部分)
    } words;
    uint32_t raw;                   // 原始32位值
} ieee754_modbus_t;

// 浮点数编码示例
inline void float_to_modbus_registers(float value, uint16_t* high_reg, uint16_t* low_reg) {
    ieee754_modbus_t converter;
    converter.value = value;
    *high_reg = converter.words.high_word;
    *low_reg = converter.words.low_word;
}

inline float modbus_registers_to_float(uint16_t high_reg, uint16_t low_reg) {
    ieee754_modbus_t converter;
    converter.words.high_word = high_reg;
    converter.words.low_word = low_reg;
    return converter.value;
}
```

#### 4.3.2 状态字和命令字格式
```c
// 系统状态字 (0x0060)
typedef union {
    uint16_t value;
    struct {
        uint16_t ready              : 1;  // Bit 0: 系统就绪
        uint16_t running            : 1;  // Bit 1: 系统运行
        uint16_t fault              : 1;  // Bit 2: 系统故障
        uint16_t warning            : 1;  // Bit 3: 系统警告
        uint16_t emergency          : 1;  // Bit 4: 紧急状态
        uint16_t maintenance_mode   : 1;  // Bit 5: 维护模式
        uint16_t calibration_mode   : 1;  // Bit 6: 校准模式
        uint16_t manual_mode        : 1;  // Bit 7: 手动模式
        uint16_t auto_mode          : 1;  // Bit 8: 自动模式
        uint16_t local_mode         : 1;  // Bit 9: 本地模式
        uint16_t remote_mode        : 1;  // Bit 10: 远程模式
        uint16_t data_valid         : 1;  // Bit 11: 数据有效
        uint16_t reserved           : 4;  // Bit 12-15: 保留
    } bits;
} system_status_word_t;

// 系统命令字 (0x0060)
typedef union {
    uint16_t value;
    struct {
        uint16_t start_system       : 1;  // Bit 0: 启动系统
        uint16_t stop_system        : 1;  // Bit 1: 停止系统
        uint16_t reset_fault        : 1;  // Bit 2: 复位故障
        uint16_t emergency_stop     : 1;  // Bit 3: 紧急停止
        uint16_t enter_maintenance  : 1;  // Bit 4: 进入维护模式
        uint16_t exit_maintenance   : 1;  // Bit 5: 退出维护模式
        uint16_t start_calibration  : 1;  // Bit 6: 开始校准
        uint16_t stop_calibration   : 1;  // Bit 7: 停止校准
        uint16_t save_parameters    : 1;  // Bit 8: 保存参数
        uint16_t load_parameters    : 1;  // Bit 9: 加载参数
        uint16_t factory_reset      : 1;  // Bit 10: 恢复出厂设置
        uint16_t self_test          : 1;  // Bit 11: 自检
        uint16_t reserved           : 4;  // Bit 12-15: 保留
    } bits;
} system_command_word_t;
```

## 5. 自定义TCP接口规范

### 5.1 TCP连接管理

#### 5.1.1 连接参数
```
监听端口: 8080
连接类型: TCP/IPv4
最大连接数: 5个并发连接
连接超时: 30秒
心跳间隔: 5秒
接收缓冲区: 4KB
发送缓冲区: 4KB
TCP_NODELAY: 启用 (禁用Nagle算法)
SO_KEEPALIVE: 启用
```

#### 5.1.2 连接状态机
```c
typedef enum {
    TCP_STATE_DISCONNECTED = 0,    // 断开连接
    TCP_STATE_CONNECTING,          // 正在连接
    TCP_STATE_CONNECTED,           // 已连接
    TCP_STATE_AUTHENTICATING,      // 身份验证中
    TCP_STATE_AUTHENTICATED,       // 已认证
    TCP_STATE_ACTIVE,              // 活跃通信
    TCP_STATE_ERROR,               // 错误状态
    TCP_STATE_CLOSING              // 正在关闭
} tcp_connection_state_t;

typedef struct {
    int socket_fd;                 // 套接字文件描述符
    tcp_connection_state_t state;  // 连接状态
    uint32_t session_id;           // 会话ID
    time_t connect_time;           // 连接时间
    time_t last_activity;          // 最后活动时间
    uint32_t tx_bytes;             // 发送字节数
    uint32_t rx_bytes;             // 接收字节数
    uint16_t sequence_number;      // 序列号
    char client_ip[16];            // 客户端IP地址
    uint16_t client_port;          // 客户端端口
} tcp_connection_info_t;
```

### 5.2 协议帧格式

#### 5.2.1 通用帧格式
```c
#define TCP_FRAME_SYNC              0x55AA  // 帧同步字
#define TCP_FRAME_VERSION           0x01    // 协议版本
#define TCP_MAX_PAYLOAD_SIZE        1024    // 最大载荷大小

typedef struct {
    uint16_t sync;                  // 同步字 (0x55AA)
    uint8_t version;                // 协议版本
    uint8_t type;                   // 消息类型
    uint16_t length;                // 数据长度 (不包含帧头和CRC)
    uint16_t sequence;              // 序列号
    uint32_t timestamp;             // 时间戳 (Unix时间戳)
    uint8_t flags;                  // 标志位
    uint8_t reserved;               // 保留字节
    uint8_t payload[];              // 数据载荷
    // uint16_t crc;                // CRC16校验 (在载荷后)
} __attribute__((packed)) tcp_frame_header_t;

// 帧头大小: 12字节
#define TCP_FRAME_HEADER_SIZE       sizeof(tcp_frame_header_t)
#define TCP_FRAME_CRC_SIZE          2
#define TCP_FRAME_MIN_SIZE          (TCP_FRAME_HEADER_SIZE + TCP_FRAME_CRC_SIZE)
```

#### 5.2.2 消息类型定义
```c
// 控制类消息 (0x00-0x0F)
#define MSG_TYPE_HELLO              0x00    // 协议握手
#define MSG_TYPE_AUTH_REQUEST       0x01    // 认证请求
#define MSG_TYPE_AUTH_RESPONSE      0x02    // 认证响应
#define MSG_TYPE_HEARTBEAT          0x03    // 心跳消息
#define MSG_TYPE_GOODBYE            0x04    // 断开连接

// 查询类消息 (0x10-0x1F)
#define MSG_TYPE_DEVICE_INFO        0x10    // 设备信息查询
#define MSG_TYPE_SYSTEM_STATUS      0x11    // 系统状态查询
#define MSG_TYPE_SENSOR_DATA        0x12    // 传感器数据查询
#define MSG_TYPE_ACTUATOR_STATUS    0x13    // 执行器状态查询
#define MSG_TYPE_DIAGNOSTIC_DATA    0x14    // 诊断数据查询

// 控制类消息 (0x20-0x2F)
#define MSG_TYPE_SYSTEM_CONTROL     0x20    // 系统控制命令
#define MSG_TYPE_PARAMETER_SET      0x21    // 参数设置
#define MSG_TYPE_CALIBRATION_CMD    0x22    // 校准命令
#define MSG_TYPE_MAINTENANCE_CMD    0x23    // 维护命令

// 订阅类消息 (0x30-0x3F)
#define MSG_TYPE_SUBSCRIBE_REQUEST  0x30    // 订阅请求
#define MSG_TYPE_UNSUBSCRIBE_REQUEST 0x31   // 取消订阅请求
#define MSG_TYPE_DATA_PUSH          0x32    // 数据推送

// 响应类消息 (0x80-0xFF)
#define MSG_TYPE_RESPONSE_OK        0x80    // 成功响应
#define MSG_TYPE_RESPONSE_ERROR     0x81    // 错误响应
#define MSG_TYPE_RESPONSE_DATA      0x82    // 数据响应

// 标志位定义
#define TCP_FLAG_ACKNOWLEDGE        0x01    // 需要确认
#define TCP_FLAG_COMPRESSED         0x02    // 数据压缩
#define TCP_FLAG_ENCRYPTED          0x04    // 数据加密
#define TCP_FLAG_PRIORITY_HIGH      0x08    // 高优先级
#define TCP_FLAG_MULTIPART          0x10    // 多部分消息
#define TCP_FLAG_LAST_PART          0x20    // 最后一部分
```

### 5.3 具体消息格式

#### 5.3.1 握手和认证消息
```c
// 协议握手消息 (MSG_TYPE_HELLO)
typedef struct {
    uint8_t protocol_version_major; // 主版本号
    uint8_t protocol_version_minor; // 次版本号
    uint32_t capabilities;          // 功能位掩码
    char client_name[32];           // 客户端名称
    char client_version[16];        // 客户端版本
} __attribute__((packed)) hello_message_t;

// 认证请求消息 (MSG_TYPE_AUTH_REQUEST)
typedef struct {
    uint8_t auth_method;            // 认证方法
    uint8_t username_length;        // 用户名长度
    uint8_t password_length;        // 密码长度
    char credentials[];             // 用户名+密码 (变长)
} __attribute__((packed)) auth_request_message_t;

// 认证响应消息 (MSG_TYPE_AUTH_RESPONSE)
typedef struct {
    uint8_t result;                 // 认证结果 (0=成功, 1=失败)
    uint32_t session_id;            // 会话ID
    uint32_t session_timeout;       // 会话超时时间(秒)
    uint32_t permissions;           // 权限位掩码
    char token[64];                 // 访问令牌
} __attribute__((packed)) auth_response_message_t;

// 心跳消息 (MSG_TYPE_HEARTBEAT)
typedef struct {
    uint32_t uptime_seconds;        // 系统运行时间
    uint8_t system_health;          // 系统健康度 (0-100)
    uint8_t reserved[3];            // 保留字节
} __attribute__((packed)) heartbeat_message_t;
```

#### 5.3.2 数据查询消息
```c
// 传感器数据查询响应 (MSG_TYPE_SENSOR_DATA)
typedef struct {
    uint32_t timestamp;             // 数据时间戳
    uint8_t sensor_count;           // 传感器数量
    uint8_t reserved[3];            // 保留字节

    struct {
        uint8_t sensor_id;          // 传感器ID
        uint8_t sensor_type;        // 传感器类型
        uint8_t status;             // 传感器状态
        uint8_t reserved;           // 保留字节
        float value;                // 传感器值
        float min_value;            // 最小值
        float max_value;            // 最大值
        uint32_t last_update;       // 最后更新时间
    } __attribute__((packed)) sensors[];
} __attribute__((packed)) sensor_data_response_t;

// 系统状态查询响应 (MSG_TYPE_SYSTEM_STATUS)
typedef struct {
    uint8_t system_state;           // 系统状态
    uint8_t operation_mode;         // 运行模式
    uint16_t fault_code;            // 故障代码
    uint16_t warning_code;          // 警告代码
    uint16_t active_alarms;         // 激活报警数量
    float system_efficiency;        // 系统效率
    uint32_t operation_hours;       // 运行小时数
    uint32_t cycle_count;           // 循环计数

    struct {
        uint8_t subsystem_id;       // 子系统ID
        uint8_t subsystem_state;    // 子系统状态
        uint16_t subsystem_health;  // 子系统健康度
    } __attribute__((packed)) subsystems[8];
} __attribute__((packed)) system_status_response_t;
```

#### 5.3.3 控制命令消息
```c
// 系统控制命令 (MSG_TYPE_SYSTEM_CONTROL)
typedef struct {
    uint16_t command_id;            // 命令ID
    uint16_t target_id;             // 目标对象ID
    uint32_t parameters;            // 命令参数
    float value1;                   // 参数值1
    float value2;                   // 参数值2
    uint32_t timeout_ms;            // 超时时间(毫秒)
} __attribute__((packed)) system_control_command_t;

// 参数设置消息 (MSG_TYPE_PARAMETER_SET)
typedef struct {
    uint16_t parameter_group;       // 参数组
    uint16_t parameter_count;       // 参数数量

    struct {
        uint16_t param_id;          // 参数ID
        uint8_t param_type;         // 参数类型
        uint8_t reserved;           // 保留字节
        union {
            uint32_t uint_value;    // 无符号整数值
            int32_t int_value;      // 有符号整数值
            float float_value;      // 浮点值
            char string_value[16];  // 字符串值
        } value;
    } __attribute__((packed)) parameters[];
} __attribute__((packed)) parameter_set_message_t;
```

#### 5.3.4 订阅和推送消息
```c
// 订阅请求消息 (MSG_TYPE_SUBSCRIBE_REQUEST)
typedef struct {
    uint16_t subscription_id;       // 订阅ID
    uint8_t data_type;              // 数据类型
    uint8_t update_rate;            // 更新频率 (Hz)
    uint32_t filter_mask;           // 过滤掩码
    uint16_t max_queue_size;        // 最大队列大小
    uint8_t compression_enabled;    // 启用压缩
    uint8_t reserved;               // 保留字节
} __attribute__((packed)) subscribe_request_message_t;

// 数据推送消息 (MSG_TYPE_DATA_PUSH)
typedef struct {
    uint16_t subscription_id;       // 订阅ID
    uint32_t sequence_number;       // 数据序列号
    uint32_t timestamp;             // 数据时间戳
    uint16_t data_length;           // 数据长度
    uint8_t quality;                // 数据质量
    uint8_t reserved;               // 保留字节
    uint8_t data[];                 // 实际数据
} __attribute__((packed)) data_push_message_t;
```

### 5.4 错误处理和响应码

#### 5.4.1 错误响应格式
```c
// 错误响应消息 (MSG_TYPE_RESPONSE_ERROR)
typedef struct {
    uint16_t error_code;            // 错误代码
    uint16_t original_msg_type;     // 原始消息类型
    uint16_t original_sequence;     // 原始序列号
    uint8_t severity;               // 严重性级别
    uint8_t reserved;               // 保留字节
    char error_description[64];     // 错误描述
    uint32_t additional_info;       // 附加信息
} __attribute__((packed)) error_response_message_t;

// 错误代码定义
#define ERROR_CODE_SUCCESS              0x0000  // 成功
#define ERROR_CODE_UNKNOWN_MESSAGE      0x0001  // 未知消息类型
#define ERROR_CODE_INVALID_PARAMETER    0x0002  // 无效参数
#define ERROR_CODE_ACCESS_DENIED        0x0003  // 访问被拒绝
#define ERROR_CODE_RESOURCE_BUSY        0x0004  // 资源忙
#define ERROR_CODE_TIMEOUT              0x0005  // 超时
#define ERROR_CODE_SYSTEM_ERROR         0x0006  // 系统错误
#define ERROR_CODE_NOT_IMPLEMENTED      0x0007  // 功能未实现
#define ERROR_CODE_BUFFER_OVERFLOW      0x0008  // 缓冲区溢出
#define ERROR_CODE_CHECKSUM_ERROR       0x0009  // 校验和错误
#define ERROR_CODE_PROTOCOL_VERSION     0x000A  // 协议版本不兼容
#define ERROR_CODE_AUTHENTICATION_FAIL  0x000B  // 认证失败
#define ERROR_CODE_SESSION_EXPIRED      0x000C  // 会话过期
#define ERROR_CODE_INSUFFICIENT_PRIV    0x000D  // 权限不足
#define ERROR_CODE_DEVICE_NOT_READY     0x000E  // 设备未就绪
#define ERROR_CODE_OPERATION_FAILED     0x000F  // 操作失败
```

#### 5.4.2 严重性级别定义
```c
typedef enum {
    SEVERITY_INFO = 0,              // 信息
    SEVERITY_WARNING = 1,           // 警告
    SEVERITY_ERROR = 2,             // 错误
    SEVERITY_CRITICAL = 3,          // 严重错误
    SEVERITY_FATAL = 4              // 致命错误
} error_severity_t;
```

## 6. RESTful API接口规范

### 6.1 HTTP服务器配置

#### 6.1.1 服务器参数
```
监听端口: 8081 (HTTP)
最大连接数: 20个并发连接
请求超时: 30秒
最大请求大小: 1MB
支持的HTTP方法: GET, POST, PUT, DELETE
内容类型: application/json, application/xml
字符编码: UTF-8
压缩支持: gzip
```

#### 6.1.2 API版本控制
```
API版本: v1
Base URL: http://192.168.1.100:8081/api/v1/
版本兼容性: 向后兼容
版本协商: 通过Accept header或URL path
```

### 6.2 API端点规范

#### 6.2.1 设备信息接口
```
GET /api/v1/device/info
描述: 获取设备基本信息
参数: 无
响应格式:
{
    "device_id": "INK_SYS_001",
    "device_name": "Ink Supply System",
    "model": "GD32F427-ISS",
    "firmware_version": "4.0.0",
    "hardware_version": "1.2",
    "serial_number": "ISS2024001",
    "manufacture_date": "2024-12-27",
    "uptime_seconds": 86400,
    "status": "running"
}

GET /api/v1/device/capabilities
描述: 获取设备功能列表
响应格式:
{
    "protocols": ["ethercat", "modbus_tcp", "custom_tcp"],
    "sensors": {
        "temperature": 3,
        "pressure": 2,
        "level": 2
    },
    "actuators": {
        "heaters": 3,
        "pumps": 2,
        "valves": 2
    },
    "features": [
        "pid_control",
        "data_logging",
        "remote_monitoring",
        "fault_diagnosis"
    ]
}
```

#### 6.2.2 传感器数据接口
```
GET /api/v1/sensors
描述: 获取所有传感器数据
参数:
  - format: json/xml (可选，默认json)
  - timestamp: 包含时间戳 (可选，默认true)
响应格式:
{
    "timestamp": "2025-09-27T10:30:00Z",
    "sensors": {
        "temperature": [
            {
                "id": 0,
                "name": "temp_sensor_1",
                "value": 65.2,
                "unit": "°C",
                "status": "ok",
                "last_update": "2025-09-27T10:30:00Z"
            }
        ],
        "pressure": [
            {
                "id": 0,
                "name": "pressure_sensor_1",
                "value": 52.1,
                "unit": "kPa",
                "status": "ok",
                "last_update": "2025-09-27T10:30:00Z"
            }
        ],
        "level": [
            {
                "id": 0,
                "name": "level_sensor_1",
                "value": 78.5,
                "unit": "%",
                "status": "ok",
                "last_update": "2025-09-27T10:30:00Z"
            }
        ]
    }
}

GET /api/v1/sensors/{sensor_type}/{sensor_id}
描述: 获取指定传感器数据
参数:
  - sensor_type: temperature/pressure/level
  - sensor_id: 传感器ID (0-based)
```

#### 6.2.3 系统控制接口
```
GET /api/v1/system/status
描述: 获取系统状态
响应格式:
{
    "system_state": "running",
    "operation_mode": "automatic",
    "health_score": 95,
    "efficiency": 89.5,
    "faults": [],
    "warnings": [],
    "uptime_hours": 240,
    "last_maintenance": "2025-09-20T08:00:00Z"
}

POST /api/v1/system/control
描述: 发送系统控制命令
请求格式:
{
    "command": "start|stop|reset|emergency_stop",
    "parameters": {
        "timeout_ms": 5000
    }
}
响应格式:
{
    "result": "success|error",
    "message": "Command executed successfully",
    "execution_time_ms": 150
}

POST /api/v1/system/mode
描述: 设置系统运行模式
请求格式:
{
    "mode": "automatic|manual|maintenance",
    "force": false
}
```

#### 6.2.4 参数配置接口
```
GET /api/v1/config/parameters
描述: 获取所有配置参数
响应格式:
{
    "temperature_control": {
        "setpoints": [65.0, 70.0, 75.0],
        "pid_parameters": [
            {"kp": 2.0, "ki": 0.1, "kd": 0.05}
        ]
    },
    "pressure_control": {
        "setpoints": [50.0, 45.0],
        "pid_parameters": [
            {"kp": 1.5, "ki": 0.05, "kd": 0.02}
        ]
    }
}

PUT /api/v1/config/parameters/{group}/{parameter}
描述: 更新配置参数
请求格式:
{
    "value": 65.5,
    "immediate": true,
    "save_to_flash": true
}

POST /api/v1/config/backup
描述: 备份配置
响应格式:
{
    "backup_id": "backup_20250927_103000",
    "size_bytes": 2048,
    "checksum": "abc123def456"
}

POST /api/v1/config/restore
描述: 恢复配置
请求格式:
{
    "backup_id": "backup_20250927_103000",
    "verify_checksum": true
}
```

#### 6.2.5 诊断和维护接口
```
GET /api/v1/diagnostic/health
描述: 获取系统健康状态
响应格式:
{
    "overall_health": 95,
    "subsystems": {
        "sensors": {"health": 98, "status": "good"},
        "actuators": {"health": 92, "status": "good"},
        "control": {"health": 96, "status": "good"},
        "communication": {"health": 94, "status": "good"}
    },
    "recommendations": [
        "Schedule maintenance for pump #2",
        "Calibrate pressure sensor #1"
    ]
}

GET /api/v1/diagnostic/performance
描述: 获取性能指标
响应格式:
{
    "cpu_usage_percent": 45.2,
    "memory_usage_percent": 32.1,
    "network_utilization_percent": 15.8,
    "task_response_times": {
        "control_task": 0.8,
        "sensor_task": 1.2,
        "communication_task": 2.1
    },
    "error_rates": {
        "sensor_errors_per_hour": 0.1,
        "communication_timeouts_per_hour": 0.05
    }
}

POST /api/v1/maintenance/selftest
描述: 执行自检
请求格式:
{
    "test_level": "basic|comprehensive",
    "include_calibration": false
}
响应格式:
{
    "test_id": "selftest_20250927_103000",
    "status": "running|completed|failed",
    "progress_percent": 100,
    "results": {
        "overall": "pass",
        "details": [
            {"test": "sensor_connectivity", "result": "pass"},
            {"test": "actuator_function", "result": "pass"},
            {"test": "communication", "result": "pass"}
        ]
    }
}
```

### 6.3 认证和安全

#### 6.3.1 API认证
```
认证方式: Bearer Token
Token获取:
POST /api/v1/auth/login
请求格式:
{
    "username": "admin",
    "password": "password123"
}
响应格式:
{
    "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "token_type": "Bearer",
    "expires_in": 3600,
    "refresh_token": "refresh_token_here"
}

使用方式:
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

#### 6.3.2 权限级别
```
权限级别定义:
- guest: 只读访问传感器数据和状态
- operator: 基本操作权限，可以启停系统
- engineer: 工程师权限，可以修改参数和配置
- admin: 管理员权限，完全访问权限

权限验证:
每个API端点都有相应的权限要求
未授权访问返回401 Unauthorized
权限不足返回403 Forbidden
```

## 7. WebSocket实时接口规范

### 7.1 WebSocket连接规范

#### 7.1.1 连接参数
```
WebSocket URL: ws://192.168.1.100:8082/ws/v1/realtime
协议: WebSocket (RFC 6455)
子协议: ink-supply-protocol-v1
最大连接数: 10个并发连接
心跳间隔: 30秒
重连策略: 指数退避算法
压缩: 支持 per-message-deflate
```

#### 7.1.2 消息格式
```javascript
// WebSocket消息通用格式
{
    "id": "unique_message_id",      // 消息唯一标识
    "type": "message_type",         // 消息类型
    "timestamp": "2025-09-27T10:30:00Z", // 时间戳
    "payload": {                    // 消息载荷
        // 具体数据
    }
}

// 消息类型定义
const MESSAGE_TYPES = {
    // 控制消息
    HELLO: "hello",
    PING: "ping",
    PONG: "pong",
    ERROR: "error",

    // 订阅管理
    SUBSCRIBE: "subscribe",
    UNSUBSCRIBE: "unsubscribe",
    SUBSCRIPTION_ACK: "subscription_ack",

    // 数据推送
    SENSOR_DATA: "sensor_data",
    SYSTEM_STATUS: "system_status",
    ALARM_EVENT: "alarm_event",
    LOG_EVENT: "log_event"
};
```

### 7.2 实时数据订阅

#### 7.2.1 订阅请求
```javascript
// 订阅传感器数据
{
    "id": "req_001",
    "type": "subscribe",
    "timestamp": "2025-09-27T10:30:00Z",
    "payload": {
        "channel": "sensor_data",
        "filters": {
            "sensor_types": ["temperature", "pressure"],
            "sensor_ids": [0, 1],
            "update_rate": 10           // 10Hz更新频率
        },
        "options": {
            "include_metadata": true,
            "compression": false
        }
    }
}

// 订阅确认响应
{
    "id": "resp_001",
    "type": "subscription_ack",
    "timestamp": "2025-09-27T10:30:00Z",
    "payload": {
        "status": "success",
        "subscription_id": "sub_12345",
        "channel": "sensor_data",
        "actual_update_rate": 10
    }
}
```

#### 7.2.2 数据推送格式
```javascript
// 传感器数据推送
{
    "id": "push_001",
    "type": "sensor_data",
    "timestamp": "2025-09-27T10:30:00Z",
    "payload": {
        "subscription_id": "sub_12345",
        "sequence": 1001,
        "data": [
            {
                "sensor_id": 0,
                "sensor_type": "temperature",
                "value": 65.2,
                "unit": "°C",
                "quality": "good",
                "timestamp": "2025-09-27T10:30:00.123Z"
            },
            {
                "sensor_id": 1,
                "sensor_type": "pressure",
                "value": 52.1,
                "unit": "kPa",
                "quality": "good",
                "timestamp": "2025-09-27T10:30:00.125Z"
            }
        ]
    }
}

// 系统状态推送
{
    "id": "push_002",
    "type": "system_status",
    "timestamp": "2025-09-27T10:30:00Z",
    "payload": {
        "subscription_id": "sub_12346",
        "system_state": "running",
        "operation_mode": "automatic",
        "health_score": 95,
        "active_alarms": 0,
        "warnings": [],
        "performance": {
            "cpu_usage": 45.2,
            "memory_usage": 32.1,
            "network_utilization": 15.8
        }
    }
}

// 报警事件推送
{
    "id": "alarm_001",
    "type": "alarm_event",
    "timestamp": "2025-09-27T10:30:00Z",
    "payload": {
        "alarm_id": "TEMP_HIGH_001",
        "severity": "warning",
        "description": "Temperature sensor #1 reading high",
        "value": 85.5,
        "threshold": 80.0,
        "location": "temperature_sensor_1",
        "recommended_action": "Check cooling system"
    }
}
```

### 7.3 实时控制接口

#### 7.3.1 远程控制命令
```javascript
// 系统控制命令
{
    "id": "cmd_001",
    "type": "system_control",
    "timestamp": "2025-09-27T10:30:00Z",
    "payload": {
        "command": "set_temperature",
        "target": "temperature_controller_0",
        "parameters": {
            "setpoint": 70.0,
            "immediate": true
        }
    }
}

// 命令执行响应
{
    "id": "resp_cmd_001",
    "type": "command_response",
    "timestamp": "2025-09-27T10:30:01Z",
    "payload": {
        "command_id": "cmd_001",
        "status": "success",
        "execution_time_ms": 150,
        "result": {
            "previous_setpoint": 65.0,
            "new_setpoint": 70.0
        }
    }
}
```

## 8. SDK软件开发包规范

### 8.1 SDK架构和组件

#### 8.1.1 SDK组件结构
```
ink_supply_sdk/
├── include/
│   ├── ink_supply_api.h        // 主要API头文件
│   ├── ink_supply_types.h      // 数据类型定义
│   ├── ink_supply_errors.h     // 错误代码定义
│   └── protocols/
│       ├── ethercat_client.h   // EtherCAT客户端
│       ├── modbus_client.h     // Modbus客户端
│       ├── tcp_client.h        // TCP客户端
│       └── websocket_client.h  // WebSocket客户端
├── src/
│   ├── core/                   // 核心功能实现
│   ├── protocols/              // 协议实现
│   ├── utils/                  // 工具函数
│   └── examples/               // 示例代码
├── lib/                        // 编译后的库文件
├── docs/                       // 文档
├── tests/                      // 单元测试
└── tools/                      // 开发工具
```

#### 8.1.2 主要API接口
```c
// ink_supply_api.h - 主要API接口

#ifndef INK_SUPPLY_API_H
#define INK_SUPPLY_API_H

#include "ink_supply_types.h"
#include "ink_supply_errors.h"

#ifdef __cplusplus
extern "C" {
#endif

// SDK初始化和清理
/**
 * @brief 初始化SDK
 * @param config 配置参数
 * @return 错误代码
 */
ink_supply_error_t ink_supply_init(const ink_supply_config_t* config);

/**
 * @brief 清理SDK资源
 * @return 错误代码
 */
ink_supply_error_t ink_supply_cleanup(void);

// 连接管理
/**
 * @brief 连接到设备
 * @param connection_info 连接信息
 * @param handle 返回的连接句柄
 * @return 错误代码
 */
ink_supply_error_t ink_supply_connect(
    const ink_supply_connection_info_t* connection_info,
    ink_supply_handle_t* handle
);

/**
 * @brief 断开连接
 * @param handle 连接句柄
 * @return 错误代码
 */
ink_supply_error_t ink_supply_disconnect(ink_supply_handle_t handle);

// 设备信息查询
/**
 * @brief 获取设备信息
 * @param handle 连接句柄
 * @param device_info 设备信息结构
 * @return 错误代码
 */
ink_supply_error_t ink_supply_get_device_info(
    ink_supply_handle_t handle,
    ink_supply_device_info_t* device_info
);

// 传感器数据读取
/**
 * @brief 读取传感器数据
 * @param handle 连接句柄
 * @param sensor_data 传感器数据结构
 * @return 错误代码
 */
ink_supply_error_t ink_supply_read_sensors(
    ink_supply_handle_t handle,
    ink_supply_sensor_data_t* sensor_data
);

/**
 * @brief 读取指定传感器数据
 * @param handle 连接句柄
 * @param sensor_type 传感器类型
 * @param sensor_id 传感器ID
 * @param value 传感器值
 * @return 错误代码
 */
ink_supply_error_t ink_supply_read_sensor(
    ink_supply_handle_t handle,
    ink_supply_sensor_type_t sensor_type,
    uint8_t sensor_id,
    float* value
);

// 系统控制
/**
 * @brief 发送系统控制命令
 * @param handle 连接句柄
 * @param command 控制命令
 * @return 错误代码
 */
ink_supply_error_t ink_supply_system_control(
    ink_supply_handle_t handle,
    const ink_supply_system_command_t* command
);

/**
 * @brief 设置参数
 * @param handle 连接句柄
 * @param parameter 参数信息
 * @return 错误代码
 */
ink_supply_error_t ink_supply_set_parameter(
    ink_supply_handle_t handle,
    const ink_supply_parameter_t* parameter
);

// 实时数据订阅
/**
 * @brief 订阅实时数据
 * @param handle 连接句柄
 * @param subscription 订阅配置
 * @param callback 回调函数
 * @return 错误代码
 */
ink_supply_error_t ink_supply_subscribe_data(
    ink_supply_handle_t handle,
    const ink_supply_subscription_t* subscription,
    ink_supply_data_callback_t callback
);

/**
 * @brief 取消订阅
 * @param handle 连接句柄
 * @param subscription_id 订阅ID
 * @return 错误代码
 */
ink_supply_error_t ink_supply_unsubscribe_data(
    ink_supply_handle_t handle,
    uint32_t subscription_id
);

// 错误处理
/**
 * @brief 获取错误描述
 * @param error_code 错误代码
 * @return 错误描述字符串
 */
const char* ink_supply_get_error_string(ink_supply_error_t error_code);

#ifdef __cplusplus
}
#endif

#endif // INK_SUPPLY_API_H
```

### 8.2 数据类型定义

#### 8.2.1 基础数据类型
```c
// ink_supply_types.h - 数据类型定义

#ifndef INK_SUPPLY_TYPES_H
#define INK_SUPPLY_TYPES_H

#include <stdint.h>
#include <stdbool.h>
#include <time.h>

// 句柄类型
typedef void* ink_supply_handle_t;

// 传感器类型
typedef enum {
    INK_SUPPLY_SENSOR_TYPE_TEMPERATURE = 0,
    INK_SUPPLY_SENSOR_TYPE_PRESSURE = 1,
    INK_SUPPLY_SENSOR_TYPE_LEVEL = 2,
    INK_SUPPLY_SENSOR_TYPE_COUNT
} ink_supply_sensor_type_t;

// 通信协议类型
typedef enum {
    INK_SUPPLY_PROTOCOL_ETHERCAT = 0,
    INK_SUPPLY_PROTOCOL_MODBUS_TCP = 1,
    INK_SUPPLY_PROTOCOL_CUSTOM_TCP = 2,
    INK_SUPPLY_PROTOCOL_HTTP_REST = 3,
    INK_SUPPLY_PROTOCOL_WEBSOCKET = 4
} ink_supply_protocol_t;

// 连接信息
typedef struct {
    ink_supply_protocol_t protocol;     // 协议类型
    char host[64];                      // 主机地址
    uint16_t port;                      // 端口号
    char username[32];                  // 用户名
    char password[32];                  // 密码
    uint32_t timeout_ms;                // 超时时间
    bool auto_reconnect;                // 自动重连
    void* protocol_specific;            // 协议特定参数
} ink_supply_connection_info_t;

// 设备信息
typedef struct {
    char device_id[32];                 // 设备ID
    char device_name[64];               // 设备名称
    char model[32];                     // 型号
    char firmware_version[16];          // 固件版本
    char hardware_version[16];          // 硬件版本
    char serial_number[32];             // 序列号
    time_t manufacture_date;            // 制造日期
    uint32_t uptime_seconds;            // 运行时间
    uint8_t status;                     // 设备状态
} ink_supply_device_info_t;

// 传感器数据
typedef struct {
    time_t timestamp;                   // 时间戳
    float temperature[3];               // 温度值
    float pressure[2];                  // 压力值
    float level[2];                     // 液位值
    uint8_t sensor_status[7];           // 传感器状态
    bool data_valid;                    // 数据有效性
} ink_supply_sensor_data_t;

// 系统状态
typedef struct {
    uint8_t system_state;               // 系统状态
    uint8_t operation_mode;             // 运行模式
    uint16_t fault_code;                // 故障代码
    uint16_t warning_code;              // 警告代码
    float system_efficiency;            // 系统效率
    uint32_t operation_hours;           // 运行小时数
    bool emergency_active;              // 紧急状态
    bool maintenance_required;          // 需要维护
} ink_supply_system_status_t;

// 控制命令
typedef struct {
    uint16_t command_id;                // 命令ID
    uint16_t target_id;                 // 目标ID
    float parameters[4];                // 参数数组
    uint32_t timeout_ms;                // 超时时间
    bool immediate;                     // 立即执行
} ink_supply_system_command_t;

// 参数设置
typedef struct {
    uint16_t parameter_id;              // 参数ID
    uint8_t parameter_type;             // 参数类型
    union {
        uint32_t uint_value;
        int32_t int_value;
        float float_value;
        char string_value[32];
    } value;                            // 参数值
    bool save_to_flash;                 // 保存到闪存
} ink_supply_parameter_t;

// 订阅配置
typedef struct {
    uint32_t subscription_id;           // 订阅ID
    uint8_t data_type;                  // 数据类型
    uint8_t update_rate;                // 更新频率
    uint32_t filter_mask;               // 过滤掩码
    bool include_metadata;              // 包含元数据
} ink_supply_subscription_t;

// 数据回调函数类型
typedef void (*ink_supply_data_callback_t)(
    ink_supply_handle_t handle,
    uint32_t subscription_id,
    const void* data,
    size_t data_size,
    void* user_data
);

// 事件回调函数类型
typedef void (*ink_supply_event_callback_t)(
    ink_supply_handle_t handle,
    uint32_t event_type,
    const void* event_data,
    void* user_data
);

// SDK配置
typedef struct {
    uint32_t log_level;                 // 日志级别
    char log_file[256];                 // 日志文件路径
    uint32_t max_connections;           // 最大连接数
    uint32_t default_timeout_ms;        // 默认超时时间
    ink_supply_event_callback_t event_callback; // 事件回调
    void* user_data;                    // 用户数据
} ink_supply_config_t;

#endif // INK_SUPPLY_TYPES_H
```

### 8.3 示例代码

#### 8.3.1 基本使用示例
```c
// example_basic.c - 基本使用示例

#include "ink_supply_api.h"
#include <stdio.h>
#include <stdlib.h>

void data_callback(ink_supply_handle_t handle,
                   uint32_t subscription_id,
                   const void* data,
                   size_t data_size,
                   void* user_data)
{
    const ink_supply_sensor_data_t* sensor_data = (const ink_supply_sensor_data_t*)data;

    printf("Received sensor data:\n");
    printf("  Temperature: %.1f°C, %.1f°C, %.1f°C\n",
           sensor_data->temperature[0],
           sensor_data->temperature[1],
           sensor_data->temperature[2]);
    printf("  Pressure: %.1fkPa, %.1fkPa\n",
           sensor_data->pressure[0],
           sensor_data->pressure[1]);
    printf("  Level: %.1f%%, %.1f%%\n",
           sensor_data->level[0],
           sensor_data->level[1]);
}

int main()
{
    ink_supply_error_t result;
    ink_supply_handle_t handle;

    // 1. 初始化SDK
    ink_supply_config_t config = {0};
    config.log_level = 2;  // Info level

    result = ink_supply_init(&config);
    if (result != INK_SUPPLY_SUCCESS) {
        printf("Failed to initialize SDK: %s\n",
               ink_supply_get_error_string(result));
        return 1;
    }

    // 2. 连接到设备
    ink_supply_connection_info_t conn_info = {0};
    conn_info.protocol = INK_SUPPLY_PROTOCOL_MODBUS_TCP;
    strcpy(conn_info.host, "192.168.1.100");
    conn_info.port = 502;
    conn_info.timeout_ms = 5000;

    result = ink_supply_connect(&conn_info, &handle);
    if (result != INK_SUPPLY_SUCCESS) {
        printf("Failed to connect: %s\n",
               ink_supply_get_error_string(result));
        ink_supply_cleanup();
        return 1;
    }

    // 3. 获取设备信息
    ink_supply_device_info_t device_info;
    result = ink_supply_get_device_info(handle, &device_info);
    if (result == INK_SUPPLY_SUCCESS) {
        printf("Connected to device: %s\n", device_info.device_name);
        printf("Firmware version: %s\n", device_info.firmware_version);
    }

    // 4. 读取传感器数据
    ink_supply_sensor_data_t sensor_data;
    result = ink_supply_read_sensors(handle, &sensor_data);
    if (result == INK_SUPPLY_SUCCESS) {
        printf("Current sensor readings:\n");
        printf("  Temperature 1: %.1f°C\n", sensor_data.temperature[0]);
        printf("  Pressure 1: %.1fkPa\n", sensor_data.pressure[0]);
        printf("  Level 1: %.1f%%\n", sensor_data.level[0]);
    }

    // 5. 设置温度目标值
    ink_supply_parameter_t temp_param;
    temp_param.parameter_id = 0x2003;  // 温度控制器1目标值
    temp_param.parameter_type = 3;      // Float type
    temp_param.value.float_value = 70.0f;
    temp_param.save_to_flash = true;

    result = ink_supply_set_parameter(handle, &temp_param);
    if (result == INK_SUPPLY_SUCCESS) {
        printf("Temperature setpoint updated to 70.0°C\n");
    }

    // 6. 订阅实时数据
    ink_supply_subscription_t subscription;
    subscription.subscription_id = 1;
    subscription.data_type = 1;         // Sensor data
    subscription.update_rate = 10;      // 10Hz
    subscription.filter_mask = 0x07;    // All sensor types
    subscription.include_metadata = true;

    result = ink_supply_subscribe_data(handle, &subscription, data_callback);
    if (result == INK_SUPPLY_SUCCESS) {
        printf("Subscribed to real-time data\n");

        // 等待10秒接收数据
        sleep(10);

        // 取消订阅
        ink_supply_unsubscribe_data(handle, subscription.subscription_id);
    }

    // 7. 断开连接并清理
    ink_supply_disconnect(handle);
    ink_supply_cleanup();

    return 0;
}
```

#### 8.3.2 多协议使用示例
```c
// example_multi_protocol.c - 多协议使用示例

#include "ink_supply_api.h"
#include <stdio.h>
#include <pthread.h>

typedef struct {
    ink_supply_handle_t handle;
    ink_supply_protocol_t protocol;
    const char* protocol_name;
} protocol_context_t;

void* protocol_worker(void* arg)
{
    protocol_context_t* ctx = (protocol_context_t*)arg;
    ink_supply_sensor_data_t sensor_data;
    ink_supply_error_t result;

    printf("[%s] Worker thread started\n", ctx->protocol_name);

    for (int i = 0; i < 60; i++) {  // 运行1分钟
        result = ink_supply_read_sensors(ctx->handle, &sensor_data);
        if (result == INK_SUPPLY_SUCCESS) {
            printf("[%s] Temp: %.1f°C, Pressure: %.1fkPa\n",
                   ctx->protocol_name,
                   sensor_data.temperature[0],
                   sensor_data.pressure[0]);
        } else {
            printf("[%s] Read error: %s\n",
                   ctx->protocol_name,
                   ink_supply_get_error_string(result));
        }

        sleep(1);  // 1秒间隔
    }

    printf("[%s] Worker thread finished\n", ctx->protocol_name);
    return NULL;
}

int main()
{
    ink_supply_error_t result;
    pthread_t threads[3];
    protocol_context_t contexts[3];

    // 初始化SDK
    ink_supply_config_t config = {0};
    config.log_level = 1;  // Warning level

    result = ink_supply_init(&config);
    if (result != INK_SUPPLY_SUCCESS) {
        printf("Failed to initialize SDK\n");
        return 1;
    }

    // 配置三种协议连接
    ink_supply_connection_info_t connections[3] = {
        // EtherCAT连接
        {
            .protocol = INK_SUPPLY_PROTOCOL_ETHERCAT,
            .host = "192.168.1.100",
            .port = 0,
            .timeout_ms = 1000
        },
        // Modbus TCP连接
        {
            .protocol = INK_SUPPLY_PROTOCOL_MODBUS_TCP,
            .host = "192.168.1.100",
            .port = 502,
            .timeout_ms = 5000
        },
        // 自定义TCP连接
        {
            .protocol = INK_SUPPLY_PROTOCOL_CUSTOM_TCP,
            .host = "192.168.1.100",
            .port = 8080,
            .timeout_ms = 3000
        }
    };

    const char* protocol_names[] = {
        "EtherCAT", "Modbus TCP", "Custom TCP"
    };

    // 建立所有连接
    for (int i = 0; i < 3; i++) {
        strcpy(connections[i].username, "admin");
        strcpy(connections[i].password, "admin123");

        result = ink_supply_connect(&connections[i], &contexts[i].handle);
        if (result == INK_SUPPLY_SUCCESS) {
            contexts[i].protocol = connections[i].protocol;
            contexts[i].protocol_name = protocol_names[i];
            printf("Connected via %s\n", protocol_names[i]);
        } else {
            printf("Failed to connect via %s: %s\n",
                   protocol_names[i],
                   ink_supply_get_error_string(result));
            contexts[i].handle = NULL;
        }
    }

    // 启动工作线程
    for (int i = 0; i < 3; i++) {
        if (contexts[i].handle != NULL) {
            pthread_create(&threads[i], NULL, protocol_worker, &contexts[i]);
        }
    }

    // 等待所有线程完成
    for (int i = 0; i < 3; i++) {
        if (contexts[i].handle != NULL) {
            pthread_join(threads[i], NULL);
            ink_supply_disconnect(contexts[i].handle);
        }
    }

    // 清理资源
    ink_supply_cleanup();
    printf("All connections closed\n");

    return 0;
}
```

## 9. 接口兼容性和版本管理

### 9.1 版本兼容性策略

#### 9.1.1 版本号规则
```
版本格式: MAJOR.MINOR.PATCH
- MAJOR: 主版本号，不兼容的API变更
- MINOR: 次版本号，向后兼容的功能增加
- PATCH: 修订号，向后兼容的问题修复

当前版本: 4.0.0

兼容性承诺:
- 同一主版本内保持API兼容性
- 新增功能通过功能标志或新端点提供
- 废弃功能提前一个次版本通知
- 协议格式保持向后兼容
```

#### 9.1.2 功能协商机制
```c
// 功能位掩码定义
#define INK_SUPPLY_FEATURE_BASIC_CONTROL        0x00000001
#define INK_SUPPLY_FEATURE_ADVANCED_PID         0x00000002
#define INK_SUPPLY_FEATURE_DATA_LOGGING         0x00000004
#define INK_SUPPLY_FEATURE_REMOTE_DIAGNOSTICS   0x00000008
#define INK_SUPPLY_FEATURE_SECURITY_AUTH        0x00000010
#define INK_SUPPLY_FEATURE_REAL_TIME_SUBSCRIBE  0x00000020
#define INK_SUPPLY_FEATURE_FIRMWARE_UPDATE      0x00000040
#define INK_SUPPLY_FEATURE_MULTI_PROTOCOL       0x00000080

// 功能查询接口
typedef struct {
    uint32_t supported_features;       // 支持的功能
    uint32_t enabled_features;         // 启用的功能
    uint8_t protocol_version_major;    // 协议主版本
    uint8_t protocol_version_minor;    // 协议次版本
    char vendor_extension[64];         // 厂商扩展信息
} ink_supply_capabilities_t;

ink_supply_error_t ink_supply_get_capabilities(
    ink_supply_handle_t handle,
    ink_supply_capabilities_t* capabilities
);
```

### 9.2 协议扩展机制

#### 9.2.1 自定义扩展格式
```c
// 扩展消息格式 (用于未来功能)
typedef struct {
    uint16_t extension_id;          // 扩展ID
    uint16_t extension_version;     // 扩展版本
    uint16_t data_length;           // 数据长度
    uint8_t reserved[2];            // 保留字节
    uint8_t extension_data[];       // 扩展数据
} __attribute__((packed)) protocol_extension_t;

// 扩展ID定义
#define EXT_ID_VENDOR_SPECIFIC      0x8000  // 厂商特定扩展
#define EXT_ID_FUTURE_FEATURE_1     0x0001  // 未来功能1
#define EXT_ID_FUTURE_FEATURE_2     0x0002  // 未来功能2
```

#### 9.2.2 配置迁移支持
```c
// 配置迁移接口
typedef struct {
    uint16_t source_version;        // 源版本
    uint16_t target_version;        // 目标版本
    uint32_t config_size;           // 配置大小
    uint8_t* config_data;           // 配置数据
} ink_supply_config_migration_t;

ink_supply_error_t ink_supply_migrate_config(
    const ink_supply_config_migration_t* migration
);
```

## 10. 测试和验证规范

### 10.1 接口测试用例

#### 10.1.1 功能测试清单
```
EtherCAT接口测试:
✓ PDO映射正确性验证
✓ 对象字典访问测试
✓ 状态机转换测试
✓ 分布式时钟同步测试
✓ 错误处理和恢复测试

Modbus TCP接口测试:
✓ 所有功能码操作测试
✓ 地址映射正确性验证
✓ 异常响应测试
✓ 并发连接测试
✓ 数据完整性验证

自定义TCP接口测试:
✓ 协议握手和认证测试
✓ 消息格式验证
✓ 实时数据推送测试
✓ 错误处理测试
✓ 连接管理测试

RESTful API测试:
✓ 所有端点功能测试
✓ HTTP状态码正确性
✓ JSON格式验证
✓ 认证和权限测试
✓ 错误响应格式测试

WebSocket接口测试:
✓ 连接建立和断开测试
✓ 消息格式验证
✓ 实时订阅测试
✓ 心跳机制测试
✓ 重连机制测试

SDK测试:
✓ API接口完整性测试
✓ 内存泄漏检测
✓ 多线程安全测试
✓ 错误处理测试
✓ 性能基准测试
```

### 10.2 性能测试基准

#### 10.2.1 响应时间要求
```
接口类型            | 平均响应时间 | 95%响应时间 | 最大响应时间
EtherCAT循环        | 1ms         | 1.1ms       | 1.2ms
Modbus TCP查询      | 50ms        | 80ms        | 100ms
自定义TCP命令       | 30ms        | 50ms        | 80ms
RESTful API请求     | 100ms       | 200ms       | 500ms
WebSocket推送       | 10ms        | 20ms        | 50ms
SDK API调用         | 5ms         | 10ms        | 20ms
```

#### 10.2.2 吞吐量要求
```
接口类型            | 最小吞吐量   | 目标吞吐量   | 并发连接数
EtherCAT           | 1000 PDO/s  | 1000 PDO/s  | 1连接
Modbus TCP         | 10 req/s    | 20 req/s    | 10连接
自定义TCP          | 20 msg/s    | 50 msg/s    | 5连接
RESTful API        | 50 req/s    | 100 req/s   | 20连接
WebSocket          | 100 msg/s   | 200 msg/s   | 10连接
```

## 11. 部署和集成指南

### 11.1 系统集成清单

#### 11.1.1 硬件集成要求
```
网络基础设施:
- 千兆以太网交换机 (支持EtherCAT)
- CAT6网线 (EtherCAT专线)
- 网络冗余配置 (可选)
- 网络隔离和VLAN配置

电源和接地:
- 稳定的24V直流电源
- 良好的接地系统
- 电源滤波和防护
- UPS不间断电源 (可选)

环境要求:
- 工作温度: 0°C ~ 50°C
- 存储温度: -20°C ~ 70°C
- 相对湿度: 5% ~ 95% (无凝露)
- 振动等级: IEC 60068-2-6
```

#### 11.1.2 软件集成步骤
```
1. 网络配置
   - 设置设备IP地址
   - 配置网络参数
   - 测试网络连通性
   - 配置防火墙规则

2. 协议配置
   - EtherCAT网络配置
   - Modbus TCP服务器设置
   - 自定义TCP端口配置
   - WebSocket服务启用

3. 安全配置
   - 用户账户创建
   - 权限分配设置
   - 证书安装配置
   - 访问控制策略

4. 功能验证
   - 基本连接测试
   - 数据读写验证
   - 控制功能测试
   - 异常处理验证

5. 性能优化
   - 网络参数调优
   - 系统负载监控
   - 响应时间优化
   - 资源使用优化
```

### 11.2 故障诊断指南

#### 11.2.1 常见问题诊断
```
连接问题:
问题: 无法建立EtherCAT连接
诊断: 检查网线连接、网络配置、主站设置
解决: 重新配置网络参数，检查硬件连接

问题: Modbus TCP超时
诊断: 检查IP地址、端口、防火墙设置
解决: 验证网络连通性，调整超时参数

问题: 自定义TCP认证失败
诊断: 检查用户名密码、证书配置
解决: 重新设置认证信息，验证权限

数据问题:
问题: 传感器数据异常
诊断: 检查传感器连接、校准参数
解决: 重新校准传感器，检查硬件故障

问题: 控制命令无响应
诊断: 检查系统状态、权限设置
解决: 验证系统模式，检查控制权限

性能问题:
问题: 响应时间过长
诊断: 监控CPU负载、网络使用率
解决: 优化系统配置，减少并发负载

问题: 数据推送延迟
诊断: 检查网络带宽、缓冲区设置
解决: 调整推送频率，优化网络配置
```

## 12. 总结

本接口规范文档全面定义了供墨系统的通信接口标准，涵盖了硬件接口、协议规范、API设计和集成要求。通过标准化的接口设计，确保系统的互操作性、可扩展性和可维护性。

### 12.1 核心特性

- **多协议支持**: 同时支持EtherCAT、Modbus TCP、自定义TCP、RESTful API和WebSocket
- **标准化设计**: 遵循工业标准和最佳实践
- **安全可靠**: 完善的认证、加密和错误处理机制
- **高性能**: 满足工业实时控制要求
- **易于集成**: 提供完整的SDK和示例代码

### 12.2 适用场景

本接口规范适用于：
- 工业自动化系统集成
- SCADA和MES系统连接
- 远程监控和控制应用
- 第三方软件开发
- 设备维护和诊断工具

通过遵循本规范，可以确保与供墨系统的高效、稳定、安全的通信连接。