# ä¾›å¢¨ç³»ç»Ÿæ§åˆ¶æ¿å¡ç»¼åˆæŠ€æœ¯è®¾è®¡æ–‡æ¡£

## æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£ç»¼åˆäº†ã€Šä¾›å¢¨ç³»ç»Ÿæ§åˆ¶æ¿å¡è½¯ä»¶æ¶æ„è®¾è®¡æ–‡æ¡£ã€‹å’Œã€Šä¾›å¢¨ç³»ç»Ÿè½¯ä»¶æ¶æ„è¡¥å……è®¾è®¡æ–‡æ¡£ã€‹çš„å®Œæ•´å†…å®¹ï¼Œç»“åˆç¡¬ä»¶æ¶æ„åˆ†æå’Œ24é¡µåŸå§‹è®¾è®¡æ–¹æ¡ˆï¼Œä¸ºä»€æ–¹ç§‘æŠ€InkCoreç”µèŠ¯ç»ç¼˜æ¶‚å±‚æ‰“å°æœºä¾›å¢¨ç³»ç»Ÿæ§åˆ¶æ¿å¡æä¾›å®Œæ•´çš„æŠ€æœ¯è®¾è®¡è§„èŒƒã€‚

## ğŸ“‹ æ–‡æ¡£å‚è€ƒä¾æ®

### åŸå§‹è®¾è®¡èµ„æ–™
- **ä»€æ–¹ç§‘æŠ€ä¾›å¢¨ç³»ç»Ÿæ§åˆ¶æ¿å¡è®¾è®¡æ–¹æ¡ˆV1.1** (ç¬¬1-24é¡µ PNGæ–‡ä»¶)
- **ç¬¬20é¡µç¡¬ä»¶åŠŸèƒ½æ¶æ„å›¾** - UV Ink Service V1.0 æ ¸å¿ƒæ¶æ„ â­
- **ç¬¬17é¡µPLCåŠŸèƒ½æ¨¡å—å®šä¹‰** - å®Œæ•´IOåœ°å€æ˜ å°„è¡¨ ğŸ”§
- **ç¬¬18é¡µåŠŸèƒ½æ¥å£è§„æ ¼æ±‡æ€»** - ç¡¬ä»¶æ¥å£å‚æ•°è¡¨ ğŸ“‹

### é…å¥—æŠ€æœ¯æ–‡æ¡£
- **è®¾è®¡æ–¹æ¡ˆç›®å½•ç´¢å¼•ä¸å¯¼èˆªæ–‡æ¡£** - å®Œæ•´æŠ€æœ¯ç´¢å¼•ç³»ç»Ÿ
- **ä¾›å¢¨ç³»ç»Ÿç¡¬ä»¶æ¶æ„ä¿¡æ¯è¡¨æ ¼** - ç¡¬ä»¶è§„æ ¼å‚æ•°è¡¨
- **ç¬¬20é¡µç¡¬ä»¶æ¶æ„è¯¦ç»†è§£è¯»æ–‡æ¡£** - ç¡¬ä»¶æŠ€æœ¯æ·±åº¦åˆ†æ

---

# ç¬¬ä¸€ç«  ç³»ç»Ÿæ€»ä½“æ¶æ„è®¾è®¡

## 1.1 ç³»ç»Ÿæ¦‚è¿°

**äº§å“å®šä½**: ä»€æ–¹ç§‘æŠ€InkCoreç”µèŠ¯ç»ç¼˜æ¶‚å±‚æ‰“å°æœºä¾›å¢¨ç³»ç»Ÿæ§åˆ¶æ¿å¡
**åº”ç”¨åœºæ™¯**: å¤šå·¥ä½ç‹¬ç«‹ä¾›å¢¨æ¶æ„ï¼Œæ»¡è¶³ç”µèŠ¯ç»ç¼˜æ¶‚å±‚æ‰“å°çš„ç²¾å¯†æ§åˆ¶éœ€æ±‚
**è®¾è®¡ç†å¿µ**: æ¨¡å—åŒ–ã€å·¥ä¸šçº§ã€é«˜å¯é æ€§ã€æ˜“ç»´æŠ¤

### 1.1.1 æ ¸å¿ƒæŠ€æœ¯å‚æ•° (åŸºäºåŸå§‹è®¾è®¡ç¬¬18é¡µ)

| å‚æ•°ç±»å‹ | æŠ€æœ¯è§„æ ¼ | æ€§èƒ½æŒ‡æ ‡ | å‚è€ƒæ¥æº |
|----------|----------|----------|----------|
| **ä¸»æ§èŠ¯ç‰‡** | GD32F427VGT6 | 200MHz, 1024K Flash, 100PIN | ç¬¬18é¡µ+ç¬¬20é¡µæ¶æ„å›¾ |
| **é€šä¿¡åè®®** | EtherCAT + ä»¥å¤ªç½‘ | 100MbpsåŒåè®®æ”¯æŒ | ç¬¬20é¡µ+ç¬¬21-23é¡µç»„ç½‘ |
| **æ¨¡æ‹Ÿé‡‡é›†** | 15bit ADC | å¤šé€šé“é«˜ç²¾åº¦é‡‡é›† | ç¬¬14-15é¡µä¿¡å·å¤„ç† |
| **æ•°å­—IO** | å…‰ç”µéš”ç¦» | 24è·¯æ•°å­—IOï¼Œ0.5Aè¾“å‡º | ç¬¬16-17é¡µIOå®šä¹‰ |
| **æ˜¾ç¤ºæ¥å£** | CH12832B-12 | 128Ã—32ç‚¹é˜µLCD | ç¬¬18é¡µæ¥å£è§„æ ¼ |

### 1.1.2 ç³»ç»ŸåŠŸèƒ½åˆ†åŒº (å‚è€ƒç¬¬20é¡µæ¶æ„å›¾)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   UV Ink Service V1.0 ç³»ç»Ÿæ¶æ„                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   ç”µæºç®¡ç†åŒº     â”‚    ä¸»æ§å¤„ç†åŒº    â”‚    é€šä¿¡æ¥å£åŒº    â”‚   æ¨¡æ‹Ÿä¿¡å·åŒº  â”‚
â”‚                â”‚                â”‚                â”‚             â”‚
â”‚  AC220Vè¾“å…¥     â”‚  GD32F427VGT6   â”‚  EtherCAT      â”‚  15bit ADC  â”‚
â”‚  DC24Vè½¬æ¢      â”‚  ARM Cortex-M4  â”‚  YT8512C PHY   â”‚  ä¿¡å·è°ƒç†    â”‚
â”‚  å¤šè·¯DC-DC      â”‚  200MHzä¸»é¢‘     â”‚  ç½‘ç»œæ¥å£      â”‚  4-20mAå¤„ç† â”‚
â”‚                â”‚                â”‚                â”‚  PT100å¤„ç†  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   æ•°å­—IOåŒº      â”‚    LEDæŒ‡ç¤ºåŒº    â”‚    HMIç•Œé¢åŒº    â”‚   å®‰å…¨ç›‘æ§åŒº  â”‚
â”‚                â”‚                â”‚                â”‚             â”‚
â”‚  å…‰ç”µéš”ç¦»       â”‚  5è·¯çŠ¶æ€æŒ‡ç¤ºLED â”‚  LCDæ˜¾ç¤ºå±     â”‚  çœ‹é—¨ç‹—ä¿æŠ¤   â”‚
â”‚  ç»§ç”µå™¨é©±åŠ¨     â”‚  çº¢ç»¿é»„è“ç™½     â”‚  æŒ‰é”®æ¥å£      â”‚  æ•…éšœæ£€æµ‹     â”‚
â”‚  24Vè¾“å‡ºæ§åˆ¶   â”‚  GPIOæ§åˆ¶      â”‚  ç”¨æˆ·äº¤äº’      â”‚  ç³»ç»Ÿç›‘æ§     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## 1.2 åˆ†å±‚è½¯ä»¶æ¶æ„è®¾è®¡

åŸºäºGD32F427å¹³å°çš„å››å±‚è½¯ä»¶æ¶æ„ï¼Œæ•´åˆäº†åŸºç¡€åŠŸèƒ½å’Œè¡¥å……åŠŸèƒ½æ¨¡å—ï¼š

### 1.2.1 æ¶æ„å±‚æ¬¡ç»“æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        åº”ç”¨å±‚ (Application Layer)                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   åŸºç¡€æ§åˆ¶æ¨¡å—   â”‚    HMIç•Œé¢æ¨¡å—   â”‚   ç³»ç»Ÿç›‘æ§æ¨¡å—   â”‚   é…ç½®ç®¡ç†   â”‚
â”‚                â”‚                â”‚                â”‚             â”‚
â”‚  â€¢ ä¾›å¢¨æ§åˆ¶ç®—æ³•  â”‚  â€¢ LEDç®¡ç†ç³»ç»Ÿ  â”‚  â€¢ å¥åº·ç›‘æ§     â”‚  â€¢ å‚æ•°é…ç½®  â”‚
â”‚  â€¢ æ¸©åº¦æ§åˆ¶PID  â”‚  â€¢ LCDæ˜¾ç¤ºç®¡ç†  â”‚  â€¢ æ•…éšœè¯Šæ–­     â”‚  â€¢ Flashå­˜å‚¨ â”‚
â”‚  â€¢ å‹åŠ›ç›‘æ§     â”‚  â€¢ æŒ‰é”®å¤„ç†     â”‚  â€¢ æ€§èƒ½ç»Ÿè®¡     â”‚  â€¢ æ ¡éªŒç®¡ç†  â”‚
â”‚  â€¢ æ¶²ä½ç®¡ç†     â”‚  â€¢ ç”¨æˆ·äº¤äº’     â”‚  â€¢ æ—¥å¿—è®°å½•     â”‚  â€¢ é»˜è®¤é…ç½®  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      ä¸­é—´ä»¶å±‚ (Middleware Layer)                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   ä»»åŠ¡è°ƒåº¦      â”‚    é€šä¿¡åè®®æ ˆ    â”‚    æ•°æ®å¤„ç†     â”‚   å®‰å…¨ä¿æŠ¤   â”‚
â”‚                â”‚                â”‚                â”‚             â”‚
â”‚  â€¢ RTOSè°ƒåº¦    â”‚  â€¢ EtherCATåè®® â”‚  â€¢ æ»¤æ³¢ç®—æ³•     â”‚  â€¢ çœ‹é—¨ç‹—    â”‚
â”‚  â€¢ ä¼˜å…ˆçº§ç®¡ç†  â”‚  â€¢ TCP/IPåè®®   â”‚  â€¢ æ ¡å‡†ç®—æ³•     â”‚  â€¢ æ•…éšœä¿æŠ¤  â”‚
â”‚  â€¢ æ—¶é—´ç‰‡åˆ†é…  â”‚  â€¢ Modbusåè®®   â”‚  â€¢ æ•°æ®èåˆ     â”‚  â€¢ ç´§æ€¥å¤„ç†  â”‚
â”‚  â€¢ ä»»åŠ¡ç›‘æ§    â”‚  â€¢ è‡ªå®šä¹‰åè®®   â”‚  â€¢ çŠ¶æ€æœºç®¡ç†   â”‚  â€¢ å®‰å…¨ç›‘æ§  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ç¡¬ä»¶æŠ½è±¡å±‚ (HAL Layer)                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   ä¼ æ„Ÿå™¨æ¥å£    â”‚    æ‰§è¡Œå™¨æ¥å£    â”‚    é€šä¿¡æ¥å£     â”‚   ç³»ç»Ÿæ¥å£   â”‚
â”‚                â”‚                â”‚                â”‚             â”‚
â”‚  â€¢ ADCé‡‡é›†é©±åŠ¨ â”‚  â€¢ PWMè¾“å‡ºé©±åŠ¨  â”‚  â€¢ UARTé©±åŠ¨    â”‚  â€¢ GPIOé©±åŠ¨  â”‚
â”‚  â€¢ ä¿¡å·è°ƒç†    â”‚  â€¢ DACè¾“å‡ºé©±åŠ¨  â”‚  â€¢ SPIé©±åŠ¨     â”‚  â€¢ å®šæ—¶å™¨    â”‚
â”‚  â€¢ æ•°æ®è½¬æ¢    â”‚  â€¢ ç»§ç”µå™¨æ§åˆ¶  â”‚  â€¢ I2Cé©±åŠ¨     â”‚  â€¢ ä¸­æ–­ç®¡ç†  â”‚
â”‚  â€¢ æ ¡å‡†å¤„ç†    â”‚  â€¢ ä¿æŠ¤æœºåˆ¶    â”‚  â€¢ CANé©±åŠ¨     â”‚  â€¢ æ—¶é’Ÿç®¡ç†  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      åº•å±‚é©±åŠ¨ (BSP Layer)                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   GD32F427åº“    â”‚    å¤–è®¾åˆå§‹åŒ–    â”‚    ä¸­æ–­å¤„ç†     â”‚   ç³»ç»Ÿç®¡ç†   â”‚
â”‚                â”‚                â”‚                â”‚             â”‚
â”‚  â€¢ HALåº“å‡½æ•°   â”‚  â€¢ æ—¶é’Ÿé…ç½®     â”‚  â€¢ ä¸­æ–­å‘é‡è¡¨   â”‚  â€¢ å¯åŠ¨ä»£ç   â”‚
â”‚  â€¢ å¯„å­˜å™¨æ“ä½œ  â”‚  â€¢ GPIOé…ç½®     â”‚  â€¢ ä¸­æ–­æœåŠ¡å‡½æ•° â”‚  â€¢ å†…å­˜ç®¡ç†  â”‚
â”‚  â€¢ åº•å±‚API     â”‚  â€¢ å¤–è®¾é…ç½®     â”‚  â€¢ ä¼˜å…ˆçº§é…ç½®   â”‚  â€¢ å¤ä½ç®¡ç†  â”‚
â”‚  â€¢ èŠ¯ç‰‡æŠ½è±¡    â”‚  â€¢ ç®¡è„šå¤ç”¨     â”‚  â€¢ åµŒå¥—ç®¡ç†     â”‚  â€¢ ç”µæºç®¡ç†  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

# ç¬¬äºŒç«  ç¡¬ä»¶æ¥å£ä¸ä¿¡å·å¤„ç†

## 2.1 ä¼ æ„Ÿå™¨ç³»ç»Ÿè®¾è®¡ (åŸºäºç¬¬8-15é¡µåŸå§‹è®¾è®¡)

### 2.1.1 æ¶²ä½ä¼ æ„Ÿå™¨æ¥å£ - FRD-8061

**ç¡¬ä»¶è§„æ ¼** (æ¥æº: ç¬¬8é¡µä¼ æ„Ÿå™¨è§„æ ¼)
```c
// æ¶²ä½ä¼ æ„Ÿå™¨é…ç½® (åŸºäºç¬¬8é¡µæŠ€æœ¯å‚æ•°)
typedef struct {
    char model[16];           // "FRD-8061"
    float range_min;          // 0mm (æœ€å°æ¶²ä½)
    float range_max;          // 2000mm (æœ€å¤§æ¶²ä½)
    float accuracy;           // Â±1.0% (ç²¾åº¦ç­‰çº§)
    float output_min;         // 4.0mA (è¾“å‡ºä¸‹é™)
    float output_max;         // 20.0mA (è¾“å‡ºä¸Šé™)
    uint16_t response_time;   // <1000ms (å“åº”æ—¶é—´)
    uint8_t supply_voltage;   // 24V (ä¾›ç”µç”µå‹)
} liquid_level_sensor_spec_t;
```

**ä¿¡å·å¤„ç†ç”µè·¯** (åŸºäºç¬¬13é¡µä¿¡å·å¤„ç†è®¾è®¡)
```c
// 4-20mAè½¬æ¢ç”µè·¯å®ç° (å‚è€ƒç¬¬13é¡µç”µè·¯å›¾)
float convert_4_20ma_to_level(uint16_t adc_value) {
    // ADCé…ç½®: 15bitåˆ†è¾¨ç‡ï¼Œå‚è€ƒç”µå‹3.3V
    float voltage = (float)adc_value * 3.3f / 32768.0f;  // 15bit ADC

    // é€šè¿‡250Î©ç²¾å¯†ç”µé˜»è½¬æ¢ä¸ºç”µå‹ (1-5Vå¯¹åº”4-20mA)
    float current = voltage / 250.0f * 1000.0f;  // è½¬æ¢ä¸ºmA

    // çº¿æ€§è½¬æ¢ä¸ºæ¶²ä½å€¼ (4mA=0mm, 20mA=2000mm)
    if (current < 4.0f) return -1;  // ä¼ æ„Ÿå™¨æ•…éšœ
    if (current > 20.0f) return -1; // ä¼ æ„Ÿå™¨æ•…éšœ

    float level = (current - 4.0f) * 2000.0f / 16.0f;  // mm
    return level;
}
```

### 2.1.2 å‹åŠ›ä¼ æ„Ÿå™¨æ¥å£ - HP10MY

**ç¡¬ä»¶è§„æ ¼** (æ¥æº: ç¬¬9é¡µä¼ æ„Ÿå™¨è§„æ ¼)
```c
// å‹åŠ›ä¼ æ„Ÿå™¨é…ç½® (åŸºäºç¬¬9é¡µæŠ€æœ¯å‚æ•°)
typedef struct {
    char model[16];           // "HP10MY"
    float range_min;          // -100kPa (è´Ÿå‹ä¸‹é™)
    float range_max;          // 100000kPa (æ­£å‹ä¸Šé™, 100MPa)
    float accuracy;           // Â±1.5% (ç²¾åº¦ç­‰çº§)
    float output_min;         // 4.0mA (è¾“å‡ºä¸‹é™)
    float output_max;         // 20.0mA (è¾“å‡ºä¸Šé™)
    uint16_t response_time;   // <100ms (å“åº”æ—¶é—´)
    uint8_t supply_voltage;   // 24V (ä¾›ç”µç”µå‹)
} pressure_sensor_spec_t;
```

**ä¿¡å·å¤„ç†ç®—æ³•** (åŸºäºç¬¬14é¡µå‹åŠ›ä¿¡å·å¤„ç†)
```c
// å‹åŠ›ä¼ æ„Ÿå™¨æ•°æ®å¤„ç† (å‚è€ƒç¬¬14é¡µç®—æ³•)
typedef struct {
    float raw_pressure;       // åŸå§‹å‹åŠ›å€¼
    float filtered_pressure;  // æ»¤æ³¢åå‹åŠ›å€¼
    float calibrated_pressure; // æ ¡å‡†åå‹åŠ›å€¼
    uint32_t sample_count;    // é‡‡æ ·è®¡æ•°
    bool sensor_fault;        // ä¼ æ„Ÿå™¨æ•…éšœæ ‡å¿—
} pressure_data_t;

float process_pressure_sensor(uint16_t adc_value, uint8_t channel) {
    static pressure_data_t pressure_data[2] = {0}; // æ”¯æŒ2è·¯å‹åŠ›ä¼ æ„Ÿå™¨

    // ADCåŸå§‹å€¼è½¬æ¢ (15bitç²¾åº¦ï¼Œå‚è€ƒç¬¬14é¡µ)
    float voltage = (float)adc_value * 3.3f / 32768.0f;
    float current = voltage / 250.0f * 1000.0f;  // mA

    // çº¿æ€§è½¬æ¢ä¸ºå‹åŠ›å€¼
    if (current < 3.5f || current > 20.5f) {
        pressure_data[channel].sensor_fault = true;
        return -999.0f;  // é”™è¯¯ä»£ç 
    }

    // å‹åŠ›èŒƒå›´æ˜ å°„ (4mA=-100kPa, 20mA=100MPa)
    float pressure = -100.0f + (current - 4.0f) * (100100.0f / 16.0f);

    // æ•°å­—æ»¤æ³¢å¤„ç† (ä¸€é˜¶ä½é€šæ»¤æ³¢)
    pressure_data[channel].filtered_pressure =
        pressure_data[channel].filtered_pressure * 0.9f + pressure * 0.1f;

    // æ ¡å‡†å¤„ç† (åŸºäºé…ç½®å‚æ•°)
    pressure_data[channel].calibrated_pressure =
        pressure_data[channel].filtered_pressure * get_pressure_scale(channel) +
        get_pressure_offset(channel);

    pressure_data[channel].sample_count++;
    return pressure_data[channel].calibrated_pressure;
}
```

### 2.1.3 æ¸©åº¦ä¼ æ„Ÿå™¨æ¥å£ - FTT518 PT100

**ç¡¬ä»¶è§„æ ¼** (æ¥æº: ç¬¬9é¡µä¼ æ„Ÿå™¨è§„æ ¼)
```c
// PT100æ¸©åº¦ä¼ æ„Ÿå™¨é…ç½® (åŸºäºç¬¬9é¡µæŠ€æœ¯å‚æ•°)
typedef struct {
    char model[16];           // "FTT518"
    char sensor_type[16];     // "PT100 Açº§"
    float range_min;          // 50Â°C (æµ‹é‡ä¸‹é™)
    float range_max;          // 600Â°C (æµ‹é‡ä¸Šé™)
    float accuracy_class;     // 0.15% (Açº§ç²¾åº¦)
    float r0_nominal;         // 100.0Î© (0Â°Cæ ‡ç§°ç”µé˜»)
    float alpha;              // 0.003851 (æ¸©åº¦ç³»æ•°)
    uint8_t wire_connection;  // 3 (ä¸‰çº¿åˆ¶è¿æ¥)
} pt100_sensor_spec_t;
```

**ä¿¡å·è°ƒç†ç”µè·¯** (åŸºäºç¬¬15é¡µæ¸©åº¦ä¿¡å·å¤„ç†)
```c
// PT100ä¸‰çº¿åˆ¶ä¿¡å·å¤„ç† (å‚è€ƒç¬¬15é¡µç”µè·¯è®¾è®¡)
float process_pt100_temperature(uint16_t adc_value_signal, uint16_t adc_value_ref) {
    // æ’æµæ¿€åŠ±: 1mAæ’å®šç”µæµ (ç¬¬15é¡µè®¾è®¡å‚æ•°)
    const float excitation_current = 0.001f;  // 1mA
    const float reference_resistor = 1000.0f; // 1kÎ©å‚è€ƒç”µé˜»

    // ADCç”µå‹è½¬æ¢ (15bitåˆ†è¾¨ç‡)
    float voltage_signal = (float)adc_value_signal * 3.3f / 32768.0f;
    float voltage_ref = (float)adc_value_ref * 3.3f / 32768.0f;

    // ä¸‰çº¿åˆ¶è¡¥å¿ç®—æ³•
    float resistance_signal = voltage_signal / excitation_current;
    float wire_resistance = (reference_resistor - voltage_ref / excitation_current) / 2.0f;
    float pt100_resistance = resistance_signal - 2.0f * wire_resistance;

    // PT100ç”µé˜»-æ¸©åº¦è½¬æ¢ (Callendar-Van Dusenæ–¹ç¨‹ç®€åŒ–)
    float temperature;
    if (pt100_resistance >= 100.0f) {
        // æ­£æ¸©åº¦è®¡ç®—
        temperature = (pt100_resistance - 100.0f) / (100.0f * 0.003851f);
    } else {
        // è´Ÿæ¸©åº¦è®¡ç®— (å¦‚æœéœ€è¦)
        temperature = (pt100_resistance - 100.0f) / (100.0f * 0.003851f);
    }

    return temperature;
}
```

## 2.2 æ‰§è¡Œå™¨æ§åˆ¶ç³»ç»Ÿ (åŸºäºç¬¬10-16é¡µåŸå§‹è®¾è®¡)

### 2.2.1 åŠ çƒ­å™¨æ§åˆ¶ - AC220Vç³»ç»Ÿ

**ç¡¬ä»¶è§„æ ¼** (æ¥æº: ç¬¬10é¡µæ‰§è¡Œå™¨è§„æ ¼)
```c
// åŠ çƒ­å™¨æ§åˆ¶é…ç½® (åŸºäºç¬¬10é¡µæŠ€æœ¯å‚æ•°)
typedef struct {
    char model[16];           // "MRA-23D3"
    uint16_t voltage_rating;  // 220V (é¢å®šç”µå‹)
    uint16_t power_rating;    // 150W/100W (é¢å®šåŠŸç‡)
    uint16_t current_rating;  // 0.7A/0.45A (é¢å®šç”µæµ)
    float switching_voltage;  // 3.3V (æ§åˆ¶ç”µå‹)
    uint16_t response_time;   // <10ms (å“åº”æ—¶é—´)
    char isolation_type[16];  // "å…‰ç”µéš”ç¦»" (éš”ç¦»æ–¹å¼)
} heater_control_spec_t;
```

**æ§åˆ¶ç®—æ³•å®ç°** (åŸºäºç¬¬16é¡µæ§åˆ¶ç”µè·¯)
```c
// åŠ çƒ­å™¨PIDæ§åˆ¶ç®—æ³• (å‚è€ƒç¬¬16é¡µæ§åˆ¶æ–¹æ¡ˆ)
typedef struct {
    float kp, ki, kd;         // PIDå‚æ•°
    float setpoint;           // ç›®æ ‡æ¸©åº¦
    float last_error;         // ä¸Šæ¬¡è¯¯å·®
    float integral;           // ç§¯åˆ†ç´¯ç§¯
    uint32_t last_time;       // ä¸Šæ¬¡è®¡ç®—æ—¶é—´
    bool auto_tuning;         // è‡ªæ•´å®šæ¨¡å¼
} heater_pid_t;

void heater_pid_control(heater_pid_t *pid, float current_temp) {
    uint32_t current_time = get_system_tick();
    float dt = (current_time - pid->last_time) / 1000.0f; // è½¬æ¢ä¸ºç§’

    if (dt <= 0.0f) return;

    // PIDè®¡ç®—
    float error = pid->setpoint - current_temp;
    pid->integral += error * dt;

    // ç§¯åˆ†é™å¹…é˜²æ­¢é¥±å’Œ
    if (pid->integral > 100.0f) pid->integral = 100.0f;
    if (pid->integral < -100.0f) pid->integral = -100.0f;

    float derivative = (error - pid->last_error) / dt;

    float output = pid->kp * error + pid->ki * pid->integral + pid->kd * derivative;

    // è¾“å‡ºé™åˆ¶ (0-100%)
    if (output > 100.0f) output = 100.0f;
    if (output < 0.0f) output = 0.0f;

    // PWMè¾“å‡ºæ§åˆ¶ (é€šè¿‡å›ºæ€ç»§ç”µå™¨)
    set_heater_pwm_duty(output);

    pid->last_error = error;
    pid->last_time = current_time;
}
```

### 2.2.2 æ³µç³»ç»Ÿæ§åˆ¶

**è°ƒé€Ÿæ³µæ§åˆ¶** (æ¥æº: ç¬¬11é¡µMPB025BBBè§„æ ¼)
```c
// è°ƒé€Ÿæ³µæ§åˆ¶é…ç½® (åŸºäºç¬¬11é¡µæŠ€æœ¯å‚æ•°)
typedef struct {
    char model[16];           // "MPB025BBB"
    uint16_t voltage_rating;  // 24V (é¢å®šç”µå‹)
    uint16_t power_rating;    // 25W (é¢å®šåŠŸç‡)
    uint16_t speed_min;       // 200 RPM (æœ€ä½è½¬é€Ÿ)
    uint16_t speed_max;       // 5000 RPM (æœ€é«˜è½¬é€Ÿ)
    float control_voltage_min; // 0.2V (æ§åˆ¶ç”µå‹ä¸‹é™)
    float control_voltage_max; // 5.0V (æ§åˆ¶ç”µå‹ä¸Šé™)
    uint16_t response_time;   // <500ms (å“åº”æ—¶é—´)
} variable_pump_spec_t;

// è°ƒé€Ÿæ³µæ§åˆ¶å‡½æ•° (å‚è€ƒç¬¬16é¡µè°ƒé€Ÿæ§åˆ¶)
void set_pump_speed(uint8_t pump_id, uint16_t target_rpm) {
    // è½¬é€Ÿé™åˆ¶æ£€æŸ¥
    if (target_rpm < 200) target_rpm = 200;
    if (target_rpm > 5000) target_rpm = 5000;

    // è½¬é€Ÿåˆ°æ§åˆ¶ç”µå‹çš„çº¿æ€§è½¬æ¢
    float control_voltage = 0.2f + (target_rpm - 200.0f) * (4.8f / 4800.0f);

    // é€šè¿‡DACè¾“å‡ºæ§åˆ¶ç”µå‹ (0.2-5V)
    uint16_t dac_value = (uint16_t)(control_voltage * 4095.0f / 5.0f); // 12bit DAC

    // è¾“å‡ºåˆ°å¯¹åº”çš„DACé€šé“
    if (pump_id == 0) {
        set_dac_output(DAC_CHANNEL_1, dac_value);  // å¢¨æ¡¶æ³µ
    } else if (pump_id == 1) {
        set_dac_output(DAC_CHANNEL_2, dac_value);  // å›å¢¨æ³µ
    }
}
```

---

# ç¬¬ä¸‰ç«  LEDæŒ‡ç¤ºç¯ç®¡ç†ç³»ç»Ÿ

## 3.1 LEDç¡¬ä»¶é…ç½® (åŸºäºç¬¬20é¡µæ¶æ„å›¾åˆ†æ)

æ ¹æ®ç¬¬20é¡µç¡¬ä»¶æ¶æ„å›¾ä¸­çš„LEDæ ‡è¯†ï¼Œç³»ç»Ÿé…ç½®äº†5è·¯çŠ¶æ€æŒ‡ç¤ºLEDï¼š

### 3.1.1 LEDåŠŸèƒ½æ˜ å°„è¡¨ (å‚è€ƒæ¶æ„å›¾æ ‡è¯†)

```c
// LEDåŠŸèƒ½å®šä¹‰ (åŸºäºç¬¬20é¡µæ¶æ„å›¾LEDæ ‡è¯†)
typedef enum {
    LED_POWER_INDICATOR = 0,     // 2PN1*2D*1 - ç”µæºæŒ‡ç¤ºç¯ (çº¢è‰²)
    LED_NETWORK_STATUS,          // 2PN1*2D*2 - ç½‘ç»œçŠ¶æ€ç¯ (ç»¿è‰²)
    LED_SYSTEM_RUNNING,          // 2PN1*2D*3 - ç³»ç»Ÿè¿è¡Œç¯ (é»„è‰²)
    LED_COMMUNICATION,           // 2PN1*2D*4 - é€šä¿¡çŠ¶æ€ç¯ (è“è‰²)
    LED_FAULT_ALARM,            // 2PN1*2D*5 - æ•…éšœæŠ¥è­¦ç¯ (ç™½è‰²)
    LED_MAX_COUNT
} led_function_t;

// LEDæ§åˆ¶ç»“æ„ä½“
typedef struct {
    uint8_t led_id;              // LEDç¼–å· (0-4)
    led_state_t state;           // å½“å‰çŠ¶æ€
    uint8_t brightness;          // äº®åº¦ (0-100%)
    uint32_t blink_period;       // é—ªçƒå‘¨æœŸ (ms)
    uint32_t last_toggle;        // ä¸Šæ¬¡åˆ‡æ¢æ—¶é—´
    bool is_on;                  // å½“å‰äº®ç­çŠ¶æ€
    gpio_pin_t gpio_pin;         // å¯¹åº”çš„GPIOç®¡è„š
} led_control_t;
```

### 3.1.2 LEDçŠ¶æ€æŒ‡ç¤ºè§„åˆ™

```c
// LEDçŠ¶æ€æŒ‡ç¤ºè§„åˆ™è¡¨ (åŸºäºç³»ç»ŸçŠ¶æ€æ˜ å°„)
static const led_rule_t led_rules[] = {
    // ç”µæºæŒ‡ç¤ºç¯ (çº¢è‰²) - ç¡¬ä»¶ç›´è¿24Vç”µæº
    {LED_POWER_INDICATOR, SYSTEM_POWER_ON,  LED_STATE_ON},
    {LED_POWER_INDICATOR, SYSTEM_POWER_OFF, LED_STATE_OFF},

    // ç½‘ç»œçŠ¶æ€ç¯ (ç»¿è‰²) - åŸºäºYT8512C PHYçŠ¶æ€
    {LED_NETWORK_STATUS, NETWORK_CONNECTED,    LED_STATE_ON},
    {LED_NETWORK_STATUS, NETWORK_CONNECTING,   LED_STATE_BLINK_SLOW},   // 1Hz
    {LED_NETWORK_STATUS, NETWORK_DISCONNECTED, LED_STATE_OFF},
    {LED_NETWORK_STATUS, NETWORK_ERROR,        LED_STATE_BLINK_FAST},   // 2Hz

    // ç³»ç»Ÿè¿è¡Œç¯ (é»„è‰²) - åŸºäºä¸»æ§MCUçŠ¶æ€
    {LED_SYSTEM_RUNNING, SYSTEM_NORMAL,     LED_STATE_BLINK_SLOW},   // æ­£å¸¸å¿ƒè·³
    {LED_SYSTEM_RUNNING, SYSTEM_BUSY,       LED_STATE_BLINK_FAST},   // é«˜è´Ÿè½½
    {LED_SYSTEM_RUNNING, SYSTEM_ERROR,      LED_STATE_OFF},          // ç³»ç»Ÿé”™è¯¯

    // é€šä¿¡çŠ¶æ€ç¯ (è“è‰²) - åŸºäºEtherCAT/TCPé€šä¿¡
    {LED_COMMUNICATION, COMM_ETHERCAT_ACTIVE, LED_STATE_ON},
    {LED_COMMUNICATION, COMM_TCP_ACTIVE,      LED_STATE_BLINK_SLOW},
    {LED_COMMUNICATION, COMM_IDLE,            LED_STATE_OFF},
    {LED_COMMUNICATION, COMM_ERROR,           LED_STATE_BLINK_ULTRA}, // 5Hz

    // æ•…éšœæŠ¥è­¦ç¯ (ç™½è‰²) - åŸºäºç³»ç»Ÿæ•…éšœç­‰çº§
    {LED_FAULT_ALARM, FAULT_NONE,          LED_STATE_OFF},
    {LED_FAULT_ALARM, FAULT_WARNING,       LED_STATE_BLINK_SLOW},
    {LED_FAULT_ALARM, FAULT_ERROR,         LED_STATE_BLINK_FAST},
    {LED_FAULT_ALARM, FAULT_CRITICAL,      LED_STATE_ON},           // ä¸¥é‡æ•…éšœå¸¸äº®
};
```

### 3.1.3 LEDé©±åŠ¨ç”µè·¯å®ç°

```c
// LEDç®¡ç†ä»»åŠ¡ (1mså‘¨æœŸæ‰§è¡Œ)
void led_manager_task(void) {
    static led_control_t led_controls[LED_MAX_COUNT];
    uint32_t current_time = get_system_tick();

    for (int i = 0; i < LED_MAX_COUNT; i++) {
        led_control_t *led = &led_controls[i];

        switch (led->state) {
            case LED_STATE_OFF:
                gpio_write_pin(led->gpio_pin, GPIO_LOW);
                led->is_on = false;
                break;

            case LED_STATE_ON:
                gpio_write_pin(led->gpio_pin, GPIO_HIGH);
                led->is_on = true;
                break;

            case LED_STATE_BLINK_SLOW:  // 1Hzé—ªçƒ
                if (current_time - led->last_toggle >= 500) {
                    led->is_on = !led->is_on;
                    gpio_write_pin(led->gpio_pin, led->is_on ? GPIO_HIGH : GPIO_LOW);
                    led->last_toggle = current_time;
                }
                break;

            case LED_STATE_BLINK_FAST:  // 2Hzé—ªçƒ
                if (current_time - led->last_toggle >= 250) {
                    led->is_on = !led->is_on;
                    gpio_write_pin(led->gpio_pin, led->is_on ? GPIO_HIGH : GPIO_LOW);
                    led->last_toggle = current_time;
                }
                break;

            case LED_STATE_BLINK_ULTRA: // 5Hzå¿«é—ª
                if (current_time - led->last_toggle >= 100) {
                    led->is_on = !led->is_on;
                    gpio_write_pin(led->gpio_pin, led->is_on ? GPIO_HIGH : GPIO_LOW);
                    led->last_toggle = current_time;
                }
                break;
        }
    }
}
```

---

# ç¬¬å››ç«  äººæœºç•Œé¢(HMI)ç³»ç»Ÿ

## 4.1 LCDæ˜¾ç¤ºç³»ç»Ÿ (åŸºäºç¬¬18é¡µCH12832B-12è§„æ ¼)

### 4.1.1 æ˜¾ç¤ºå±ç¡¬ä»¶é…ç½®

```c
// æ˜¾ç¤ºå±é…ç½® (åŸºäºç¬¬18é¡µæ¥å£è§„æ ¼)
typedef struct {
    char model[16];           // "CH12832B-12"
    uint8_t resolution_x;     // 128 (åƒç´ å®½åº¦)
    uint8_t resolution_y;     // 32 (åƒç´ é«˜åº¦)
    uint8_t interface_type;   // SPIæ¥å£
    uint8_t supply_voltage;   // 3.3V (å·¥ä½œç”µå‹)
    uint16_t refresh_rate;    // 60Hz (åˆ·æ–°é¢‘ç‡)
    bool backlight_control;   // true (èƒŒå…‰æ§åˆ¶)
} lcd_display_spec_t;
```

### 4.1.2 æ˜¾ç¤ºé¡µé¢ç®¡ç†

```c
// æ˜¾ç¤ºé¡µé¢å®šä¹‰ (åŸºäºç³»ç»ŸåŠŸèƒ½éœ€æ±‚)
typedef enum {
    DISPLAY_PAGE_MAIN = 0,      // ä¸»é¡µé¢ - ç³»ç»ŸçŠ¶æ€æ€»è§ˆ
    DISPLAY_PAGE_SENSOR,        // ä¼ æ„Ÿå™¨æ•°æ®é¡µé¢
    DISPLAY_PAGE_ACTUATOR,      // æ‰§è¡Œå™¨çŠ¶æ€é¡µé¢
    DISPLAY_PAGE_NETWORK,       // ç½‘ç»œä¿¡æ¯é¡µé¢
    DISPLAY_PAGE_FAULT,         // æ•…éšœä¿¡æ¯é¡µé¢
    DISPLAY_PAGE_CONFIG,        // é…ç½®å‚æ•°é¡µé¢
    DISPLAY_PAGE_IO_STATUS,     // IOçŠ¶æ€é¡µé¢ (åŸºäºç¬¬17é¡µIOå®šä¹‰)
    DISPLAY_PAGE_MAX
} display_page_t;

// ä¸»é¡µé¢æ˜¾ç¤ºå†…å®¹ (ç³»ç»Ÿæ€»è§ˆ)
void display_main_page(display_content_t *content) {
    // æ ‡é¢˜è¡Œ (8åƒç´ é«˜åº¦)
    snprintf(content->title, sizeof(content->title), "UV Ink Service V1.0");

    // ç¬¬ä¸€è¡Œ (8åƒç´ ) - æ¸©åº¦å’Œå‹åŠ›
    snprintf(content->line1, sizeof(content->line1), "T:%.1fÂ°C P:%.1fkPa",
             get_temperature_sensor(0), get_pressure_sensor(0));

    // ç¬¬äºŒè¡Œ (8åƒç´ ) - æ¶²ä½å’Œæµé‡
    snprintf(content->line2, sizeof(content->line2), "Level:%.1f%% Flow:%.1f",
             get_liquid_level_sensor(0), get_flow_rate());

    // ç¬¬ä¸‰è¡Œ (8åƒç´ ) - ç³»ç»ŸçŠ¶æ€
    snprintf(content->line3, sizeof(content->line3), "Sys:%s Net:%s",
             get_system_status_string(), get_network_status_string());
}

// ä¼ æ„Ÿå™¨æ•°æ®é¡µé¢ (è¯¦ç»†æ•°æ®)
void display_sensor_page(display_content_t *content) {
    snprintf(content->title, sizeof(content->title), "Sensor Data");

    // æ¸©åº¦ä¼ æ„Ÿå™¨æ•°æ® (åŸºäºç¬¬15é¡µPT100å¤„ç†)
    snprintf(content->line1, sizeof(content->line1), "T1:%.1f T2:%.1f T3:%.1f",
             get_pt100_temperature(0), get_pt100_temperature(1), get_pt100_temperature(2));

    // å‹åŠ›ä¼ æ„Ÿå™¨æ•°æ® (åŸºäºç¬¬14é¡µå‹åŠ›å¤„ç†)
    snprintf(content->line2, sizeof(content->line2), "P1:%.2f P2:%.2f kPa",
             get_pressure_sensor(0), get_pressure_sensor(1));

    // æ¶²ä½ä¼ æ„Ÿå™¨æ•°æ® (åŸºäºç¬¬13é¡µæ¶²ä½å¤„ç†)
    snprintf(content->line3, sizeof(content->line3), "L1:%.1f%% L2:%.1f%%",
             get_liquid_level_sensor(0), get_liquid_level_sensor(1));
}
```

---

# ç¬¬äº”ç«  é€šä¿¡ç³»ç»Ÿè®¾è®¡

## 5.1 EtherCATå·¥ä¸šæ€»çº¿ (åŸºäºç¬¬20é¡µGDSCN832R2U6)

### 5.1.1 EtherCATç¡¬ä»¶é…ç½®

```c
// EtherCATé…ç½® (åŸºäºç¬¬18é¡µæ¥å£è§„æ ¼ + ç¬¬20é¡µæ¶æ„)
typedef struct {
    char controller_model[16]; // "GDSCN832R2U6"
    uint8_t port_count;        // 2 (åŒç«¯å£)
    uint32_t baudrate;         // 100Mbps
    bool hardware_realtime;    // true (ç¡¬ä»¶å®æ—¶)
    bool distributed_clock;    // true (åˆ†å¸ƒå¼æ—¶é’Ÿ)
    uint16_t sync_period;      // 1ms (åŒæ­¥å‘¨æœŸ)
    uint16_t process_data_size; // 64bytes (è¿‡ç¨‹æ•°æ®å¤§å°)
} ethercat_config_t;
```

### 5.1.2 EtherCATæ•°æ®äº¤æ¢

```c
// EtherCATè¿‡ç¨‹æ•°æ®å®šä¹‰ (åŸºäºç¬¬17é¡µIOåœ°å€æ˜ å°„)
typedef struct {
    // æ•°å­—è¾“å…¥ (8bytes) - å¯¹åº”ç¬¬17é¡µI0.0-I0.7
    union {
        uint8_t digital_input_bytes[8];
        struct {
            bool ink_tank_level_1 : 1;      // I0.0 - å¢¨æ¡¶æ¶²ä½å¼€å…³1
            bool ink_tank_level_2 : 1;      // I0.1 - å¢¨æ¡¶æ¶²ä½å¼€å…³2
            bool waste_tank_level : 1;      // I0.2 - åºŸæ¡¶æ¶²ä½å¼€å…³
            bool cartridge_level_1 : 1;     // I0.3 - å¢¨ç›’æ¶²ä½å¼€å…³1
            bool cartridge_level_2 : 1;     // I0.4 - å¢¨ç›’æ¶²ä½å¼€å…³2
            bool reserved_input_5 : 1;      // I0.5 - é¢„ç•™
            bool reserved_input_6 : 1;      // I0.6 - é¢„ç•™
            bool reserved_input_7 : 1;      // I0.7 - é¢„ç•™
        } digital_inputs;
    };

    // æ¨¡æ‹Ÿè¾“å…¥ (12bytes) - å¯¹åº”ç¬¬17é¡µIW1-IW6
    uint16_t analog_inputs[6];    // IW1-IW6: å‹åŠ›ã€æ¶²ä½æ¨¡æ‹Ÿé‡

    // æ¸©åº¦è¾“å…¥ (4bytes) - å¯¹åº”ç¬¬17é¡µT10-T11
    uint16_t temperature_inputs[2]; // T10-T11: PT100æ¸©åº¦

    // æ•°å­—è¾“å‡º (8bytes) - å¯¹åº”ç¬¬17é¡µQ0.0-Q0.7
    union {
        uint8_t digital_output_bytes[8];
        struct {
            bool ink_pump_start : 1;        // Q0.0 - å¢¨æ¡¶æ³µå¯åŠ¨
            bool return_pump_start : 1;     // Q0.1 - å›å¢¨æ³µå¯åŠ¨
            bool recycle_valve_open : 1;    // Q0.2 - å›æ”¶ç”µç£é˜€
            bool cartridge_heater : 1;      // Q0.3 - å¢¨ç›’åŠ çƒ­
            bool line_heater : 1;           // Q0.4 - æ˜å°¼å¸¸åŠ çƒ­
            bool water_supply_valve : 1;    // Q0.5 - ä¾›æ°´å›æ”¶ç”µç£é˜€
            bool waste_ink_valve : 1;       // Q0.6 - åºŸæ¡¶ä¾›å¢¨ç”µç£é˜€
            bool tank_ink_valve : 1;        // Q0.7 - å¢¨æ¡¶ä¾›å¢¨ç”µç£é˜€
        } digital_outputs;
    };

    // æ¨¡æ‹Ÿè¾“å‡º (8bytes) - å¯¹åº”ç¬¬17é¡µQW1-QW4
    uint16_t analog_outputs[4];   // QW1-QW4: æ³µé€Ÿè°ƒèŠ‚è¾“å‡º

    // ç³»ç»ŸçŠ¶æ€ (4bytes)
    uint16_t system_status;       // ç³»ç»ŸçŠ¶æ€å­—
    uint16_t fault_code;          // æ•…éšœä»£ç 

} ethercat_process_data_t;
```

## 5.2 ç½‘ç»œç»„ç½‘æ–¹æ¡ˆ (åŸºäºç¬¬21-23é¡µç»„ç½‘è®¾è®¡)

### 5.2.1 å•å·¥ä½ç³»ç»Ÿ (ç¬¬21é¡µè®¾è®¡)

```c
// å•å·¥ä½TCP/IPç›´è¿æ–¹æ¡ˆ
typedef struct {
    uint32_t controller_ip;       // æ§åˆ¶å™¨IPåœ°å€
    uint32_t host_ip;            // ä¸Šä½æœºIPåœ°å€
    uint16_t communication_port; // é€šä¿¡ç«¯å£ (é»˜è®¤502)
    uint16_t heartbeat_interval; // å¿ƒè·³é—´éš” (ms)
    uint8_t connection_timeout;  // è¿æ¥è¶…æ—¶ (s)
} single_station_network_t;
```

### 5.2.2 å°å‹ç³»ç»Ÿç»„ç½‘ (ç¬¬22é¡µè®¾è®¡)

```c
// å¤šæ§åˆ¶æ¿TCP/IPç»„ç½‘æ–¹æ¡ˆ
typedef struct {
    uint8_t controller_count;    // æ§åˆ¶å™¨æ•°é‡ (2-8å°)
    uint32_t controller_ips[8];  // å„æ§åˆ¶å™¨IPåˆ—è¡¨
    uint32_t gateway_ip;         // ç½‘å…³IPåœ°å€
    uint8_t subnet_mask;         // å­ç½‘æ©ç  (/24)
    uint16_t sync_period;        // åŒæ­¥å‘¨æœŸ (100ms)
} small_system_network_t;
```

### 5.2.3 å¤§å‹ç³»ç»Ÿç»„ç½‘ (ç¬¬23é¡µè®¾è®¡)

```c
// EtherCAT+Modbusæ··åˆç»„ç½‘æ–¹æ¡ˆ
typedef struct {
    // EtherCATä¸»ç«™é…ç½®
    uint8_t ethercat_slave_count;  // EtherCATä»ç«™æ•°é‡
    uint16_t ethercat_cycle_time;  // EtherCATå¾ªç¯æ—¶é—´ (1ms)

    // Modbus RTUé…ç½®
    uint8_t modbus_slave_id;       // Modbusä»ç«™ID
    uint32_t modbus_baudrate;      // Modbusæ³¢ç‰¹ç‡ (115200)

    // ç³»ç»Ÿæ€»ä½“é…ç½®
    uint8_t total_stations;        // æ€»å·¥ä½æ•°é‡ (16-64)
    uint16_t data_exchange_period; // æ•°æ®äº¤æ¢å‘¨æœŸ (10ms)
} large_system_network_t;
```

---

# ç¬¬å…­ç«  ç³»ç»Ÿç›‘æ§ä¸è¯Šæ–­

## 6.1 ç³»ç»Ÿå¥åº·ç›‘æ§

### 6.1.1 æ€§èƒ½ç›‘æ§æŒ‡æ ‡

```c
// ç³»ç»Ÿæ€§èƒ½ç›‘æ§ (åŸºäºGD32F427æ€§èƒ½ç‰¹æ€§)
typedef struct {
    // CPUæ€§èƒ½ç›‘æ§
    uint8_t cpu_usage_percent;      // CPUä½¿ç”¨ç‡ (%)
    uint32_t free_heap_memory;      // å‰©ä½™å †å†…å­˜ (bytes)
    uint32_t stack_usage_max;       // æœ€å¤§æ ˆä½¿ç”¨é‡ (bytes)
    uint32_t task_switch_count;     // ä»»åŠ¡åˆ‡æ¢è®¡æ•°

    // ç¡¬ä»¶ç›‘æ§
    float mcu_core_temperature;     // MCUæ ¸å¿ƒæ¸©åº¦ (Â°C)
    float supply_voltage_3v3;       // 3.3Vç”µæºç”µå‹
    float supply_voltage_5v;        // 5Vç”µæºç”µå‹
    float supply_voltage_24v;       // 24Vç”µæºç”µå‹

    // é€šä¿¡æ€§èƒ½ç›‘æ§
    uint32_t ethercat_frame_count;  // EtherCATå¸§è®¡æ•°
    uint32_t tcp_packet_count;      // TCPæ•°æ®åŒ…è®¡æ•°
    uint16_t network_latency_ms;    // ç½‘ç»œå»¶è¿Ÿ (ms)
    uint32_t communication_errors;  // é€šä¿¡é”™è¯¯è®¡æ•°

    // å­˜å‚¨ç›‘æ§
    uint32_t flash_write_cycles;    // Flashå†™å…¥æ¬¡æ•°
    uint32_t eeprom_write_count;    // EEPROMå†™å…¥è®¡æ•°
    bool storage_wear_warning;      // å­˜å‚¨å™¨ç£¨æŸè­¦å‘Š
} system_health_monitor_t;
```

### 6.1.2 æ•…éšœæ£€æµ‹ä¸æŠ¥è­¦

```c
// æ•…éšœæ£€æµ‹ä»£ç å®šä¹‰ (åŸºäºç³»ç»ŸåŠŸèƒ½æ¨¡å—)
typedef enum {
    FAULT_NONE = 0x0000,

    // ä¼ æ„Ÿå™¨æ•…éšœ (0x1000ç³»åˆ—)
    FAULT_TEMP_SENSOR_1_OPEN    = 0x1001,  // æ¸©åº¦ä¼ æ„Ÿå™¨1å¼€è·¯
    FAULT_TEMP_SENSOR_1_SHORT   = 0x1002,  // æ¸©åº¦ä¼ æ„Ÿå™¨1çŸ­è·¯
    FAULT_PRESSURE_SENSOR_1_FAULT = 0x1011, // å‹åŠ›ä¼ æ„Ÿå™¨1æ•…éšœ
    FAULT_PRESSURE_SENSOR_2_FAULT = 0x1012, // å‹åŠ›ä¼ æ„Ÿå™¨2æ•…éšœ
    FAULT_LIQUID_LEVEL_1_FAULT  = 0x1021,  // æ¶²ä½ä¼ æ„Ÿå™¨1æ•…éšœ
    FAULT_LIQUID_LEVEL_2_FAULT  = 0x1022,  // æ¶²ä½ä¼ æ„Ÿå™¨2æ•…éšœ

    // æ‰§è¡Œå™¨æ•…éšœ (0x2000ç³»åˆ—)
    FAULT_HEATER_1_OPEN         = 0x2001,  // åŠ çƒ­å™¨1å¼€è·¯
    FAULT_HEATER_2_OPEN         = 0x2002,  // åŠ çƒ­å™¨2å¼€è·¯
    FAULT_PUMP_1_OVERCURRENT    = 0x2011,  // æ³µ1è¿‡æµ
    FAULT_PUMP_2_OVERCURRENT    = 0x2012,  // æ³µ2è¿‡æµ
    FAULT_VALVE_1_FAULT         = 0x2021,  // ç”µç£é˜€1æ•…éšœ
    FAULT_VALVE_2_FAULT         = 0x2022,  // ç”µç£é˜€2æ•…éšœ

    // ç³»ç»Ÿæ•…éšœ (0x3000ç³»åˆ—)
    FAULT_POWER_VOLTAGE_LOW     = 0x3001,  // ç”µæºç”µå‹ä½
    FAULT_POWER_VOLTAGE_HIGH    = 0x3002,  // ç”µæºç”µå‹é«˜
    FAULT_MCU_OVERTEMPERATURE   = 0x3003,  // MCUè¿‡æ¸©
    FAULT_MEMORY_ERROR          = 0x3004,  // å†…å­˜é”™è¯¯
    FAULT_WATCHDOG_RESET        = 0x3005,  // çœ‹é—¨ç‹—å¤ä½

    // é€šä¿¡æ•…éšœ (0x4000ç³»åˆ—)
    FAULT_ETHERCAT_DISCONNECTED = 0x4001,  // EtherCATæ–­å¼€
    FAULT_ETHERNET_LINK_DOWN    = 0x4002,  // ä»¥å¤ªç½‘é“¾è·¯æ–­å¼€
    FAULT_COMMUNICATION_TIMEOUT = 0x4003,  // é€šä¿¡è¶…æ—¶
    FAULT_PROTOCOL_ERROR        = 0x4004,  // åè®®é”™è¯¯

    FAULT_MAX_CODE              = 0xFFFF
} fault_code_t;
```

---

# ç¬¬ä¸ƒç«  é…ç½®ç®¡ç†ç³»ç»Ÿ

## 7.1 ç³»ç»Ÿé…ç½®å‚æ•°

### 7.1.1 é…ç½®å‚æ•°ç»“æ„ (åŸºäºç³»ç»Ÿå…¨åŠŸèƒ½éœ€æ±‚)

```c
// å®Œæ•´ç³»ç»Ÿé…ç½®å‚æ•° (åŸºäºå…¨ç³»ç»ŸåŠŸèƒ½éœ€æ±‚)
typedef struct {
    // é…ç½®æ–‡ä»¶å¤´éƒ¨ä¿¡æ¯
    uint32_t config_version;        // é…ç½®ç‰ˆæœ¬å·
    uint32_t config_size;           // é…ç½®æ•°æ®å¤§å°
    uint32_t config_crc32;          // CRC32æ ¡éªŒå€¼
    char device_serial[32];         // è®¾å¤‡åºåˆ—å·

    // ç½‘ç»œé…ç½® (åŸºäºç¬¬21-23é¡µç»„ç½‘æ–¹æ¡ˆ)
    struct {
        uint32_t ip_address;        // IPåœ°å€
        uint32_t subnet_mask;       // å­ç½‘æ©ç 
        uint32_t gateway_address;   // ç½‘å…³åœ°å€
        uint16_t tcp_port;          // TCPé€šä¿¡ç«¯å£
        uint8_t ethercat_slave_id;  // EtherCATä»ç«™ID
        uint16_t heartbeat_interval; // å¿ƒè·³é—´éš” (ms)
    } network_config;

    // æ§åˆ¶å‚æ•°é…ç½® (åŸºäºPIDæ§åˆ¶éœ€æ±‚)
    struct {
        // æ¸©åº¦æ§åˆ¶PIDå‚æ•° (åŸºäºç¬¬15é¡µæ¸©åº¦å¤„ç†)
        float temp_pid_kp[3];       // æ¸©åº¦PIDæ¯”ä¾‹ç³»æ•° (3è·¯)
        float temp_pid_ki[3];       // æ¸©åº¦PIDç§¯åˆ†ç³»æ•°
        float temp_pid_kd[3];       // æ¸©åº¦PIDå¾®åˆ†ç³»æ•°
        float temp_target[3];       // ç›®æ ‡æ¸©åº¦ (Â°C)
        float temp_alarm_high[3];   // æ¸©åº¦ä¸Šé™æŠ¥è­¦ (Â°C)
        float temp_alarm_low[3];    // æ¸©åº¦ä¸‹é™æŠ¥è­¦ (Â°C)

        // å‹åŠ›æ§åˆ¶PIDå‚æ•° (åŸºäºç¬¬14é¡µå‹åŠ›å¤„ç†)
        float pressure_pid_kp[2];   // å‹åŠ›PIDæ¯”ä¾‹ç³»æ•° (2è·¯)
        float pressure_pid_ki[2];   // å‹åŠ›PIDç§¯åˆ†ç³»æ•°
        float pressure_pid_kd[2];   // å‹åŠ›PIDå¾®åˆ†ç³»æ•°
        float pressure_target[2];   // ç›®æ ‡å‹åŠ› (kPa)
        float pressure_alarm_high[2]; // å‹åŠ›ä¸Šé™æŠ¥è­¦
        float pressure_alarm_low[2];  // å‹åŠ›ä¸‹é™æŠ¥è­¦

        // æ¶²ä½æ§åˆ¶å‚æ•° (åŸºäºç¬¬13é¡µæ¶²ä½å¤„ç†)
        float level_target[2];      // ç›®æ ‡æ¶²ä½ (%)
        float level_alarm_high[2];  // æ¶²ä½ä¸Šé™æŠ¥è­¦ (%)
        float level_alarm_low[2];   // æ¶²ä½ä¸‹é™æŠ¥è­¦ (%)
    } control_config;

    // ä¼ æ„Ÿå™¨æ ¡å‡†å‚æ•° (åŸºäºå„ä¼ æ„Ÿå™¨è§„æ ¼)
    struct {
        // æ¸©åº¦ä¼ æ„Ÿå™¨æ ¡å‡† (PT100)
        float temp_sensor_offset[3];    // æ¸©åº¦ä¼ æ„Ÿå™¨åç§»é‡ (Â°C)
        float temp_sensor_scale[3];     // æ¸©åº¦ä¼ æ„Ÿå™¨ç¼©æ”¾ç³»æ•°
        float temp_wire_resistance[3];  // å¯¼çº¿ç”µé˜»è¡¥å¿ (Î©)

        // å‹åŠ›ä¼ æ„Ÿå™¨æ ¡å‡† (4-20mA)
        float pressure_sensor_offset[2]; // å‹åŠ›ä¼ æ„Ÿå™¨åç§»é‡ (kPa)
        float pressure_sensor_scale[2];  // å‹åŠ›ä¼ æ„Ÿå™¨ç¼©æ”¾ç³»æ•°
        float pressure_zero_point[2];    // å‹åŠ›é›¶ç‚¹æ ¡å‡† (mA)

        // æ¶²ä½ä¼ æ„Ÿå™¨æ ¡å‡† (4-20mA)
        float level_sensor_offset[2];   // æ¶²ä½ä¼ æ„Ÿå™¨åç§»é‡ (%)
        float level_sensor_scale[2];    // æ¶²ä½ä¼ æ„Ÿå™¨ç¼©æ”¾ç³»æ•°
        float level_zero_point[2];      // æ¶²ä½é›¶ç‚¹æ ¡å‡† (mA)
    } calibration_config;

    // ç³»ç»Ÿè¿è¡Œå‚æ•°
    struct {
        uint16_t adc_sample_period;     // ADCé‡‡æ ·å‘¨æœŸ (ms)
        uint16_t control_loop_period;   // æ§åˆ¶å›è·¯å‘¨æœŸ (ms)
        uint16_t communication_period;  // é€šä¿¡å‘¨æœŸ (ms)
        uint8_t led_brightness;         // LEDäº®åº¦ (0-100%)
        bool enable_display;            // ä½¿èƒ½LCDæ˜¾ç¤º
        bool enable_logging;            // ä½¿èƒ½æ—¥å¿—è®°å½•
        bool enable_auto_tuning;        // ä½¿èƒ½PIDè‡ªæ•´å®š
        uint8_t system_language;        // ç³»ç»Ÿè¯­è¨€ (0=ä¸­æ–‡, 1=è‹±æ–‡)
    } system_config;

    // å®‰å…¨ä¿æŠ¤å‚æ•°
    struct {
        uint16_t watchdog_timeout;      // çœ‹é—¨ç‹—è¶…æ—¶æ—¶é—´ (ms)
        float over_temp_threshold;      // è¿‡æ¸©ä¿æŠ¤é˜ˆå€¼ (Â°C)
        float over_pressure_threshold;  // è¿‡å‹ä¿æŠ¤é˜ˆå€¼ (kPa)
        float under_voltage_threshold;  // æ¬ å‹ä¿æŠ¤é˜ˆå€¼ (V)
        bool enable_emergency_stop;     // ä½¿èƒ½ç´§æ€¥åœæ­¢
        uint16_t fault_recovery_delay;  // æ•…éšœæ¢å¤å»¶æ—¶ (s)
    } safety_config;

} system_config_t;
```

### 7.1.2 é…ç½®å­˜å‚¨ç®¡ç†

```c
// é…ç½®å­˜å‚¨ç®¡ç†å‡½æ•° (åŸºäºFlashå­˜å‚¨)
typedef struct {
    uint32_t flash_base_address;    // FlashåŸºåœ°å€
    uint32_t flash_sector_size;     // Flashæ‰‡åŒºå¤§å° (4KB)
    uint32_t config_max_size;       // é…ç½®æœ€å¤§å¤§å°
    uint8_t backup_copy_count;      // å¤‡ä»½å‰¯æœ¬æ•°é‡
    bool write_protection;          // å†™ä¿æŠ¤çŠ¶æ€
} config_storage_t;

// é…ç½®ç®¡ç†å‡½æ•°æ¥å£
bool config_load_from_flash(system_config_t *config);
bool config_save_to_flash(const system_config_t *config);
bool config_restore_factory_default(system_config_t *config);
bool config_validate_integrity(const system_config_t *config);
uint32_t config_calculate_crc32(const system_config_t *config);
bool config_backup_create(const system_config_t *config);
bool config_backup_restore(system_config_t *config, uint8_t backup_index);
```

---

# ç¬¬å…«ç«  å®æ—¶ä»»åŠ¡è°ƒåº¦ç³»ç»Ÿ

## 8.1 ä»»åŠ¡ä¼˜å…ˆçº§è®¾è®¡ (åŸºäºå®æ—¶æ€§éœ€æ±‚)

### 8.1.1 ä»»åŠ¡ä¼˜å…ˆçº§åˆ†é…

```c
// ä»»åŠ¡ä¼˜å…ˆçº§å®šä¹‰ (æ•°å€¼è¶Šå°ä¼˜å…ˆçº§è¶Šé«˜) - åŸºäºEtherCATå®æ—¶æ€§ä¼˜åŒ–
#define TASK_PRIORITY_EMERGENCY      (0)   // ç´§æ€¥å¤„ç†ä»»åŠ¡ - æœ€é«˜ä¼˜å…ˆçº§
#define TASK_PRIORITY_ETHERCAT       (1)   // EtherCATé€šä¿¡ - ä¸¥æ ¼1mså®æ—¶è¦æ±‚ â­
#define TASK_PRIORITY_SAFETY         (2)   // å®‰å…¨ç›‘æ§ä»»åŠ¡ - å®‰å…¨ç›¸å…³
#define TASK_PRIORITY_WATCHDOG       (3)   // çœ‹é—¨ç‹—ä»»åŠ¡ - ç³»ç»Ÿä¿æŠ¤
#define TASK_PRIORITY_CONTROL        (4)   // æ§åˆ¶ç®—æ³•ä»»åŠ¡ - å®æ—¶æ§åˆ¶
#define TASK_PRIORITY_ADC            (5)   // ADCé‡‡é›†ä»»åŠ¡ - æ•°æ®é‡‡é›†
#define TASK_PRIORITY_SENSOR         (6)   // ä¼ æ„Ÿå™¨å¤„ç† - æ•°æ®å¤„ç†
#define TASK_PRIORITY_ACTUATOR       (7)   // æ‰§è¡Œå™¨æ§åˆ¶ - è®¾å¤‡æ§åˆ¶
#define TASK_PRIORITY_TCP_HIGH       (8)   // TCPé«˜ä¼˜å…ˆçº§é€šä¿¡
#define TASK_PRIORITY_LED            (9)   // LEDç®¡ç† - æŒ‡ç¤ºç³»ç»Ÿ
#define TASK_PRIORITY_DISPLAY        (10)  // æ˜¾ç¤ºä»»åŠ¡ - äººæœºç•Œé¢
#define TASK_PRIORITY_TCP_LOW        (11)  // TCPä½ä¼˜å…ˆçº§é€šä¿¡
#define TASK_PRIORITY_LOGGING        (12)  // æ—¥å¿—è®°å½• - åå°ä»»åŠ¡
#define TASK_PRIORITY_CONFIG         (13)  // é…ç½®ç®¡ç† - åå°ä»»åŠ¡
#define TASK_PRIORITY_STATISTICS     (14)  // æ€§èƒ½ç»Ÿè®¡ - æœ€ä½ä¼˜å…ˆçº§

// ä»»åŠ¡æ—¶é—´ç‰‡åˆ†é… - ä¼˜åŒ–EtherCATå®æ—¶æ€§
#define TASK_TIMESLICE_EMERGENCY     (1)    // ç´§æ€¥ä»»åŠ¡ - ç«‹å³å“åº”
#define TASK_TIMESLICE_ETHERCAT      (1)    // EtherCATä»»åŠ¡ - 1msä¸¥æ ¼å‘¨æœŸ â­
#define TASK_TIMESLICE_SAFETY        (10)   // å®‰å…¨ä»»åŠ¡ - 10ms
#define TASK_TIMESLICE_CONTROL       (10)   // æ§åˆ¶ä»»åŠ¡ - 10mså®æ—¶æ§åˆ¶
#define TASK_TIMESLICE_ADC           (5)    // ADCé‡‡é›† - 5msé«˜é¢‘é‡‡æ ·
#define TASK_TIMESLICE_COMMUNICATION (50)   // é€šä¿¡ä»»åŠ¡ - 50msé€šä¿¡å‘¨æœŸ
#define TASK_TIMESLICE_SENSOR        (100)  // ä¼ æ„Ÿå™¨ - 100mså¤„ç†å‘¨æœŸ
#define TASK_TIMESLICE_HMI           (200)  // äººæœºç•Œé¢ - 200msæ›´æ–°
#define TASK_TIMESLICE_BACKGROUND    (1000) // åå°ä»»åŠ¡ - 1så‘¨æœŸ
```

### 8.1.2 ä»»åŠ¡è°ƒåº¦å™¨å®ç°

```c
// ä»»åŠ¡æ§åˆ¶å—å®šä¹‰
typedef struct {
    char task_name[16];             // ä»»åŠ¡åç§°
    task_function_t task_function;  // ä»»åŠ¡å‡½æ•°æŒ‡é’ˆ
    uint8_t priority;              // ä»»åŠ¡ä¼˜å…ˆçº§
    uint32_t period_ms;            // ä»»åŠ¡å‘¨æœŸ (ms)
    uint32_t last_run_time;        // ä¸Šæ¬¡è¿è¡Œæ—¶é—´
    uint32_t max_exec_time;        // æœ€å¤§æ‰§è¡Œæ—¶é—´
    uint32_t total_run_count;      // æ€»è¿è¡Œæ¬¡æ•°
    bool enabled;                  // ä»»åŠ¡ä½¿èƒ½çŠ¶æ€
    bool critical;                 // å…³é”®ä»»åŠ¡æ ‡å¿—
    uint32_t timeout_ms;           // ä»»åŠ¡è¶…æ—¶æ—¶é—´
} task_control_block_t;

// ç³»ç»Ÿä»»åŠ¡åˆ—è¡¨ (åŸºäºEtherCATå®æ—¶æ€§ä¼˜åŒ–éœ€æ±‚)
static task_control_block_t system_tasks[] = {
    //   ä»»åŠ¡åç§°        ä»»åŠ¡å‡½æ•°                      ä¼˜å…ˆçº§                 å‘¨æœŸ  è¿è¡Œæ—¶é—´ç»Ÿè®¡  ä½¿èƒ½  å…³é”®  è¶…æ—¶
    {"Emergency",    emergency_handler_task,      TASK_PRIORITY_EMERGENCY,  1,    0, 0, 0, true,  true,  5},
    {"EtherCAT",     ethercat_communication_task, TASK_PRIORITY_ETHERCAT,   1,    0, 0, 0, true,  true,  3},  // â­ 1msä¸¥æ ¼å®æ—¶
    {"Safety",       safety_monitor_task,         TASK_PRIORITY_SAFETY,     10,   0, 0, 0, true,  true,  20},
    {"Watchdog",     watchdog_feed_task,          TASK_PRIORITY_WATCHDOG,   100,  0, 0, 0, true,  true,  200},
    {"Control",      pid_control_task,            TASK_PRIORITY_CONTROL,    10,   0, 0, 0, true,  true,  50},
    {"ADC",          adc_acquisition_task,        TASK_PRIORITY_ADC,        5,    0, 0, 0, true,  true,  20},
    {"Sensor",       sensor_processing_task,      TASK_PRIORITY_SENSOR,     100,  0, 0, 0, true,  false, 500},
    {"Actuator",     actuator_control_task,       TASK_PRIORITY_ACTUATOR,   50,   0, 0, 0, true,  false, 200},
    {"TCP-High",     tcp_communication_task,      TASK_PRIORITY_TCP_HIGH,   50,   0, 0, 0, true,  false, 1000},
    {"LED",          led_manager_task,            TASK_PRIORITY_LED,        100,  0, 0, 0, true,  false, 500},
    {"Display",      display_update_task,         TASK_PRIORITY_DISPLAY,    200,  0, 0, 0, true,  false, 1000},
    {"TCP-Low",      tcp_low_priority_task,       TASK_PRIORITY_TCP_LOW,    100,  0, 0, 0, true,  false, 2000},
    {"Logging",      log_manager_task,            TASK_PRIORITY_LOGGING,    1000, 0, 0, 0, true,  false, 5000},
    {"Config",       config_manager_task,         TASK_PRIORITY_CONFIG,     5000, 0, 0, 0, true,  false, 10000},
    {"Stats",        statistics_task,             TASK_PRIORITY_STATISTICS, 10000, 0, 0, 0, true,  false, 30000},
};
```

### 8.1.3 EtherCATå®æ—¶æ€§ä¼˜åŒ–è®¾è®¡

**ä¼˜å…ˆçº§æå‡çš„æŠ€æœ¯è€ƒé‡**:

EtherCATä½œä¸ºç¡®å®šæ€§å®æ—¶å·¥ä¸šä»¥å¤ªç½‘åè®®ï¼Œå¯¹æ—¶åºæœ‰æä¸¥æ ¼çš„è¦æ±‚ï¼š

1. **å¾ªç¯æ—¶é—´è¦æ±‚**: æ ‡å‡†EtherCATç³»ç»Ÿè¦æ±‚1mså¾ªç¯æ—¶é—´ï¼Œæœ€å¿«å¯è¾¾125Î¼s
2. **æŠ–åŠ¨æ§åˆ¶**: æ—¶åºæŠ–åŠ¨å¿…é¡»æ§åˆ¶åœ¨å¾®ç§’çº§åˆ«
3. **ç¡¬ä»¶æ”¯æŒ**: GDSCN832R2U6èŠ¯ç‰‡æä¾›ç¡¬ä»¶å®æ—¶ä¿è¯
4. **åˆ†å¸ƒå¼æ—¶é’Ÿ**: éœ€è¦ç²¾ç¡®çš„æ—¶é’ŸåŒæ­¥ï¼Œè¯¯å·®<1Î¼s

**å®æ—¶æ€§ä¿è¯æªæ–½**:

```c
// EtherCATå®æ—¶ä»»åŠ¡ç‰¹æ®Šå¤„ç†
void ethercat_communication_task(void) {
    static uint32_t last_cycle_time = 0;
    static uint32_t max_jitter = 0;

    uint32_t current_time = get_high_precision_tick(); // å¾®ç§’ç²¾åº¦

    // 1. æ—¶åºç›‘æ§ (æ£€æµ‹æŠ–åŠ¨)
    if (last_cycle_time > 0) {
        uint32_t cycle_time = current_time - last_cycle_time;
        uint32_t jitter = abs((int32_t)(cycle_time - 1000)); // 1000Î¼sæ ‡å‡†å‘¨æœŸ

        if (jitter > max_jitter) {
            max_jitter = jitter;
            if (jitter > 50) { // æŠ–åŠ¨è¶…è¿‡50Î¼sè®°å½•è­¦å‘Š
                LOG_WARN(MODULE_ETHERCAT, "Cycle jitter: %d us", jitter);
            }
        }
    }

    // 2. ç¦ç”¨ä¸­æ–­ (ç¡®ä¿åŸå­æ“ä½œ)
    uint32_t interrupt_state = disable_global_interrupts();

    // 3. EtherCATæ•°æ®äº¤æ¢ (ç¡¬ä»¶è¾…åŠ©)
    ethercat_process_data_exchange();

    // 4. æ›´æ–°è¿‡ç¨‹æ•°æ®æ˜ å°„ (åŸºäºç¬¬17é¡µIOå®šä¹‰)
    update_ethercat_input_data();   // ä¼ æ„Ÿå™¨æ•°æ® -> EtherCATè¾“å…¥
    update_ethercat_output_data();  // EtherCATè¾“å‡º -> æ‰§è¡Œå™¨æ§åˆ¶

    // 5. æ¢å¤ä¸­æ–­
    restore_global_interrupts(interrupt_state);

    // 6. åˆ†å¸ƒå¼æ—¶é’ŸåŒæ­¥
    ethercat_sync_distributed_clock();

    last_cycle_time = current_time;
}

// EtherCATä»»åŠ¡è°ƒåº¦ç‰¹æ®Šå¤„ç†
static inline void schedule_ethercat_task(void) {
    // ä½¿ç”¨ç¡¬ä»¶å®šæ—¶å™¨è§¦å‘ï¼Œç¡®ä¿ç²¾ç¡®1mså‘¨æœŸ
    timer_set_period(ETHERCAT_TIMER, 1000); // 1000Î¼s = 1ms
    timer_enable_interrupt(ETHERCAT_TIMER);

    // è®¾ç½®æœ€é«˜ä¸­æ–­ä¼˜å…ˆçº§ (0çº§)
    nvic_set_priority(ETHERCAT_TIMER_IRQn, 0);
}
```

**ä¸æ§åˆ¶ä»»åŠ¡çš„åè°ƒ**:

```c
// ç¡®ä¿æ§åˆ¶ä»»åŠ¡ä¸EtherCATåŒæ­¥
void pid_control_task(void) {
    // ç­‰å¾…EtherCATæ•°æ®æ›´æ–°å®Œæˆ
    while (ethercat_data_updating) {
        // çŸ­æš‚ç­‰å¾…ï¼Œä¸è¶…è¿‡100Î¼s
        delay_microseconds(10);
    }

    // æ‰§è¡Œæ§åˆ¶ç®—æ³• (ä½¿ç”¨æœ€æ–°çš„ä¼ æ„Ÿå™¨æ•°æ®)
    execute_pid_control_algorithms();
}
```

---

# ç¬¬ä¹ç«  æ•…éšœè¯Šæ–­ä¸å®‰å…¨ä¿æŠ¤

## 9.1 å¤šçº§å®‰å…¨ä¿æŠ¤ç³»ç»Ÿ

### 9.1.1 ç¡¬ä»¶çº§ä¿æŠ¤ (åŸºäºç¬¬10-11é¡µæ‰§è¡Œå™¨è§„æ ¼)

```c
// ç¡¬ä»¶ä¿æŠ¤é…ç½® (åŸºäºåŸå§‹è®¾è®¡å®‰å…¨è¦æ±‚)
typedef struct {
    // ç”µæºä¿æŠ¤
    float voltage_24v_min;          // 24Vç”µæºæœ€å°å€¼ (21.6V)
    float voltage_24v_max;          // 24Vç”µæºæœ€å¤§å€¼ (26.4V)
    float voltage_3v3_min;          // 3.3Vç”µæºæœ€å°å€¼ (3.0V)
    float voltage_3v3_max;          // 3.3Vç”µæºæœ€å¤§å€¼ (3.6V)

    // æ¸©åº¦ä¿æŠ¤ (åŸºäºç¬¬9é¡µä¼ æ„Ÿå™¨èŒƒå›´)
    float temp_protection_max;      // æœ€é«˜ä¿æŠ¤æ¸©åº¦ (650Â°C)
    float temp_warning_threshold;   // æ¸©åº¦è­¦å‘Šé˜ˆå€¼ (580Â°C)
    float mcu_temp_max;            // MCUæœ€é«˜æ¸©åº¦ (85Â°C)

    // ç”µæµä¿æŠ¤ (åŸºäºç¬¬10-11é¡µæ‰§è¡Œå™¨ç”µæµ)
    float heater_current_max;       // åŠ çƒ­å™¨æœ€å¤§ç”µæµ (0.8A)
    float pump_current_max;         // æ³µæœ€å¤§ç”µæµ (1.2A)
    float valve_current_max;        // ç”µç£é˜€æœ€å¤§ç”µæµ (0.4A)

    // å‹åŠ›ä¿æŠ¤ (åŸºäºç¬¬9é¡µå‹åŠ›ä¼ æ„Ÿå™¨èŒƒå›´)
    float pressure_max_limit;       // æœ€é«˜å‹åŠ›é™åˆ¶ (110MPa)
    float pressure_min_limit;       // æœ€ä½å‹åŠ›é™åˆ¶ (-110kPa)
    float pressure_alarm_high;      // å‹åŠ›é«˜æŠ¥è­¦ (95MPa)
    float pressure_alarm_low;       // å‹åŠ›ä½æŠ¥è­¦ (-90kPa)
} hardware_protection_t;
```

### 9.1.2 è½¯ä»¶çº§ä¿æŠ¤æœºåˆ¶

```c
// è½¯ä»¶ä¿æŠ¤çŠ¶æ€æœº
typedef enum {
    PROTECTION_STATE_NORMAL = 0,    // æ­£å¸¸è¿è¡ŒçŠ¶æ€
    PROTECTION_STATE_WARNING,       // è­¦å‘ŠçŠ¶æ€ - ç»§ç»­è¿è¡Œä½†ç›‘æ§
    PROTECTION_STATE_ALARM,         // æŠ¥è­¦çŠ¶æ€ - é™åˆ¶éƒ¨åˆ†åŠŸèƒ½
    PROTECTION_STATE_FAULT,         // æ•…éšœçŠ¶æ€ - åœæ­¢å…³é”®åŠŸèƒ½
    PROTECTION_STATE_EMERGENCY,     // ç´§æ€¥çŠ¶æ€ - ç«‹å³åœæœºä¿æŠ¤
    PROTECTION_STATE_MAINTENANCE    // ç»´æŠ¤çŠ¶æ€ - æ‰‹åŠ¨æ§åˆ¶æ¨¡å¼
} protection_state_t;

// å®‰å…¨ä¿æŠ¤ä»»åŠ¡ (é«˜ä¼˜å…ˆçº§,10mså‘¨æœŸ)
void safety_protection_task(void) {
    static protection_state_t current_state = PROTECTION_STATE_NORMAL;
    static uint32_t fault_count = 0;
    static uint32_t last_check_time = 0;

    uint32_t current_time = get_system_tick();
    if (current_time - last_check_time < 10) return; // 10msæ£€æŸ¥å‘¨æœŸ

    // 1. æ£€æŸ¥ç³»ç»Ÿå…³é”®å‚æ•°
    bool critical_fault = false;
    bool warning_fault = false;

    // æ¸©åº¦æ£€æŸ¥ (åŸºäºPT100ä¼ æ„Ÿå™¨)
    for (int i = 0; i < 3; i++) {
        float temp = get_pt100_temperature(i);
        if (temp > 650.0f) {
            critical_fault = true;
            trigger_fault(FAULT_TEMP_SENSOR_1_OVERHEAT + i);
        } else if (temp > 580.0f) {
            warning_fault = true;
            trigger_warning(WARNING_TEMP_HIGH_1 + i);
        }
    }

    // å‹åŠ›æ£€æŸ¥ (åŸºäº4-20mAä¼ æ„Ÿå™¨)
    for (int i = 0; i < 2; i++) {
        float pressure = get_pressure_sensor(i);
        if (pressure > 110000.0f || pressure < -110.0f) {
            critical_fault = true;
            trigger_fault(FAULT_PRESSURE_SENSOR_1_FAULT + i);
        } else if (pressure > 95000.0f || pressure < -90.0f) {
            warning_fault = true;
            trigger_warning(WARNING_PRESSURE_HIGH_1 + i);
        }
    }

    // ç”µæºç›‘æ§
    float voltage_24v = get_supply_voltage_24v();
    if (voltage_24v < 21.6f || voltage_24v > 26.4f) {
        critical_fault = true;
        trigger_fault(FAULT_POWER_VOLTAGE_ABNORMAL);
    }

    // é€šä¿¡ç›‘æ§
    if (is_ethercat_disconnected() || is_tcp_timeout()) {
        warning_fault = true;
        trigger_warning(WARNING_COMMUNICATION_FAULT);
    }

    // 2. çŠ¶æ€æœºå¤„ç†
    switch (current_state) {
        case PROTECTION_STATE_NORMAL:
            if (critical_fault) {
                current_state = PROTECTION_STATE_EMERGENCY;
                execute_emergency_shutdown();
            } else if (warning_fault) {
                current_state = PROTECTION_STATE_WARNING;
                activate_warning_procedures();
            }
            break;

        case PROTECTION_STATE_WARNING:
            if (critical_fault) {
                current_state = PROTECTION_STATE_EMERGENCY;
                execute_emergency_shutdown();
            } else if (!warning_fault) {
                current_state = PROTECTION_STATE_NORMAL;
                deactivate_warning_procedures();
            }
            fault_count++;
            break;

        case PROTECTION_STATE_EMERGENCY:
            // ç´§æ€¥çŠ¶æ€ä¸‹åªæœ‰æ‰‹åŠ¨å¤ä½æ‰èƒ½æ¢å¤
            if (is_manual_reset_requested() && !critical_fault) {
                current_state = PROTECTION_STATE_NORMAL;
                execute_system_recovery();
                fault_count = 0;
            }
            break;
    }

    // 3. æ›´æ–°LEDæŒ‡ç¤º
    update_fault_led_status(current_state);

    last_check_time = current_time;
}
```

### 9.1.3 ç´§æ€¥å¤„ç†æœºåˆ¶

```c
// ç´§æ€¥åœæœºå¤„ç† (æœ€é«˜ä¼˜å…ˆçº§ä»»åŠ¡)
void execute_emergency_shutdown(void) {
    // ç«‹å³å…³é—­æ‰€æœ‰åŠ çƒ­å™¨ (AC220Vç»§ç”µå™¨)
    set_heater_output(HEATER_CARTRIDGE_1, false);
    set_heater_output(HEATER_CARTRIDGE_2, false);
    set_heater_output(HEATER_LINE, false);

    // åœæ­¢æ‰€æœ‰æ³µè¿è¡Œ
    set_pump_output(PUMP_INK_SUPPLY, false);
    set_pump_output(PUMP_INK_RETURN, false);
    set_variable_pump_speed(PUMP_VARIABLE_1, 0);
    set_variable_pump_speed(PUMP_VARIABLE_2, 0);

    // å…³é—­æ‰€æœ‰ç”µç£é˜€
    set_valve_output(VALVE_INK_SUPPLY, false);
    set_valve_output(VALVE_INK_RETURN, false);
    set_valve_output(VALVE_WASTE_SUPPLY, false);
    set_valve_output(VALVE_WATER_SUPPLY, false);

    // æ¿€æ´»æ•…éšœæŒ‡ç¤ºLED (ç™½è‰²LEDå¸¸äº®)
    led_set_state(LED_FAULT_ALARM, LED_STATE_ON);

    // è®°å½•ç´§æ€¥åœæœºäº‹ä»¶
    log_emergency_event("Emergency shutdown executed", get_system_timestamp());

    // å‘é€æ•…éšœé€šæŠ¥
    send_fault_notification_to_host();
}
```

---

# ç¬¬åç«  è½¯ä»¶æ¨¡å—æ–‡ä»¶ç»„ç»‡

## 10.1 æŒ‰å››å±‚æ¶æ„ç»„ç»‡çš„ç›®å½•ç»“æ„

åŸºäºGD32F427å¹³å°çš„å››å±‚è½¯ä»¶æ¶æ„ï¼Œç›®å½•ç»“æ„ä¸¥æ ¼æŒ‰ç…§æ¶æ„å±‚æ¬¡ç»„ç»‡ï¼š

```
ink_supply_control_firmware/
â”œâ”€â”€ src/                                    # æºä»£ç ç›®å½•
â”‚   â”œâ”€â”€ main.c                             # ä¸»ç¨‹åºå…¥å£
â”‚   â”‚
â”‚   â”œâ”€â”€ 01_bsp_layer/                      # åº•å±‚é©±åŠ¨ (BSP Layer) â­
â”‚   â”‚   â”œâ”€â”€ board_support/                 # æ¿çº§æ”¯æŒåŒ…
â”‚   â”‚   â”‚   â”œâ”€â”€ system_init.c/h            # ç³»ç»Ÿåˆå§‹åŒ–
â”‚   â”‚   â”‚   â”œâ”€â”€ clock_config.c/h           # æ—¶é’Ÿé…ç½®
â”‚   â”‚   â”‚   â”œâ”€â”€ interrupt_handler.c/h      # ä¸­æ–­å¤„ç†
â”‚   â”‚   â”‚   â””â”€â”€ memory_manager.c/h         # å†…å­˜ç®¡ç†
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ gd32f427_drivers/              # GD32F427åº•å±‚é©±åŠ¨
â”‚   â”‚   â”‚   â”œâ”€â”€ gd32f427_hal/              # GD32 HALåº“å°è£…
â”‚   â”‚   â”‚   â”œâ”€â”€ gpio_driver.c/h            # GPIOåº•å±‚é©±åŠ¨
â”‚   â”‚   â”‚   â”œâ”€â”€ adc_driver.c/h             # ADCåº•å±‚é©±åŠ¨
â”‚   â”‚   â”‚   â”œâ”€â”€ dac_driver.c/h             # DACåº•å±‚é©±åŠ¨
â”‚   â”‚   â”‚   â”œâ”€â”€ pwm_driver.c/h             # PWMåº•å±‚é©±åŠ¨
â”‚   â”‚   â”‚   â”œâ”€â”€ uart_driver.c/h            # UARTåº•å±‚é©±åŠ¨
â”‚   â”‚   â”‚   â”œâ”€â”€ spi_driver.c/h             # SPIåº•å±‚é©±åŠ¨
â”‚   â”‚   â”‚   â”œâ”€â”€ i2c_driver.c/h             # I2Cåº•å±‚é©±åŠ¨
â”‚   â”‚   â”‚   â”œâ”€â”€ timer_driver.c/h           # å®šæ—¶å™¨åº•å±‚é©±åŠ¨
â”‚   â”‚   â”‚   â””â”€â”€ dma_driver.c/h             # DMAåº•å±‚é©±åŠ¨
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ external_chips/                # å¤–éƒ¨èŠ¯ç‰‡é©±åŠ¨
â”‚   â”‚       â”œâ”€â”€ yt8512c_phy.c/h            # ä»¥å¤ªç½‘PHYèŠ¯ç‰‡ (YT8512C)
â”‚   â”‚       â”œâ”€â”€ gdscn832r2u6_ethercat.c/h  # EtherCATèŠ¯ç‰‡ (GDSCN832R2U6)
â”‚   â”‚       â””â”€â”€ ch12832b_lcd.c/h           # LCDæ˜¾ç¤ºèŠ¯ç‰‡ (CH12832B-12)
â”‚   â”‚
â”‚   â”œâ”€â”€ 02_hal_layer/                      # ç¡¬ä»¶æŠ½è±¡å±‚ (HAL Layer) â­
â”‚   â”‚   â”œâ”€â”€ sensor_hal/                    # ä¼ æ„Ÿå™¨ç¡¬ä»¶æŠ½è±¡
â”‚   â”‚   â”‚   â”œâ”€â”€ adc_interface.c/h          # ADCæ¥å£æŠ½è±¡
â”‚   â”‚   â”‚   â”œâ”€â”€ sensor_interface.c/h       # ä¼ æ„Ÿå™¨é€šç”¨æ¥å£
â”‚   â”‚   â”‚   â”œâ”€â”€ liquid_level_hal.c/h       # æ¶²ä½ä¼ æ„Ÿå™¨HAL
â”‚   â”‚   â”‚   â”œâ”€â”€ pressure_hal.c/h           # å‹åŠ›ä¼ æ„Ÿå™¨HAL
â”‚   â”‚   â”‚   â””â”€â”€ temperature_hal.c/h        # æ¸©åº¦ä¼ æ„Ÿå™¨HAL
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ actuator_hal/                  # æ‰§è¡Œå™¨ç¡¬ä»¶æŠ½è±¡
â”‚   â”‚   â”‚   â”œâ”€â”€ pwm_interface.c/h          # PWMæ¥å£æŠ½è±¡
â”‚   â”‚   â”‚   â”œâ”€â”€ relay_interface.c/h        # ç»§ç”µå™¨æ¥å£æŠ½è±¡
â”‚   â”‚   â”‚   â”œâ”€â”€ heater_hal.c/h             # åŠ çƒ­å™¨HAL
â”‚   â”‚   â”‚   â”œâ”€â”€ pump_hal.c/h               # æ³µHAL
â”‚   â”‚   â”‚   â””â”€â”€ valve_hal.c/h              # ç”µç£é˜€HAL
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ communication_hal/             # é€šä¿¡ç¡¬ä»¶æŠ½è±¡
â”‚   â”‚   â”‚   â”œâ”€â”€ ethernet_interface.c/h     # ä»¥å¤ªç½‘æ¥å£æŠ½è±¡
â”‚   â”‚   â”‚   â”œâ”€â”€ serial_interface.c/h       # ä¸²å£æ¥å£æŠ½è±¡
â”‚   â”‚   â”‚   â”œâ”€â”€ ethercat_hal.c/h           # EtherCAT HAL
â”‚   â”‚   â”‚   â””â”€â”€ tcp_ip_hal.c/h             # TCP/IP HAL
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ hmi_hal/                       # äººæœºç•Œé¢ç¡¬ä»¶æŠ½è±¡
â”‚   â”‚   â”‚   â”œâ”€â”€ led_interface.c/h          # LEDæ¥å£æŠ½è±¡
â”‚   â”‚   â”‚   â”œâ”€â”€ display_interface.c/h      # æ˜¾ç¤ºæ¥å£æŠ½è±¡
â”‚   â”‚   â”‚   â””â”€â”€ key_interface.c/h          # æŒ‰é”®æ¥å£æŠ½è±¡ (å¦‚æœæœ‰)
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ system_hal/                    # ç³»ç»Ÿç¡¬ä»¶æŠ½è±¡
â”‚   â”‚       â”œâ”€â”€ power_monitor_hal.c/h      # ç”µæºç›‘æ§HAL
â”‚   â”‚       â”œâ”€â”€ watchdog_hal.c/h           # çœ‹é—¨ç‹—HAL
â”‚   â”‚       â””â”€â”€ flash_storage_hal.c/h      # Flashå­˜å‚¨HAL
â”‚   â”‚
â”‚   â”œâ”€â”€ 03_middleware_layer/               # ä¸­é—´ä»¶å±‚ (Middleware Layer) â­
â”‚   â”‚   â”œâ”€â”€ rtos/                          # å®æ—¶æ“ä½œç³»ç»Ÿä¸­é—´ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ task_scheduler.c/h         # ä»»åŠ¡è°ƒåº¦å™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ task_manager.c/h           # ä»»åŠ¡ç®¡ç†
â”‚   â”‚   â”‚   â”œâ”€â”€ semaphore.c/h              # ä¿¡å·é‡
â”‚   â”‚   â”‚   â”œâ”€â”€ mutex.c/h                  # äº’æ–¥é”
â”‚   â”‚   â”‚   â”œâ”€â”€ message_queue.c/h          # æ¶ˆæ¯é˜Ÿåˆ—
â”‚   â”‚   â”‚   â””â”€â”€ timer_service.c/h          # å®šæ—¶æœåŠ¡
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ communication_stack/           # é€šä¿¡åè®®æ ˆä¸­é—´ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ ethercat_protocol.c/h      # EtherCATåè®®æ ˆ
â”‚   â”‚   â”‚   â”œâ”€â”€ tcp_ip_stack.c/h           # TCP/IPåè®®æ ˆ
â”‚   â”‚   â”‚   â”œâ”€â”€ modbus_protocol.c/h        # Modbusåè®®æ ˆ
â”‚   â”‚   â”‚   â”œâ”€â”€ custom_protocol.c/h        # è‡ªå®šä¹‰åè®®
â”‚   â”‚   â”‚   â””â”€â”€ protocol_manager.c/h       # åè®®ç®¡ç†å™¨
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ data_processing/               # æ•°æ®å¤„ç†ä¸­é—´ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ digital_filter.c/h         # æ•°å­—æ»¤æ³¢ç®—æ³•
â”‚   â”‚   â”‚   â”œâ”€â”€ signal_processing.c/h      # ä¿¡å·å¤„ç†ç®—æ³•
â”‚   â”‚   â”‚   â”œâ”€â”€ data_fusion.c/h            # æ•°æ®èåˆç®—æ³•
â”‚   â”‚   â”‚   â”œâ”€â”€ calibration_engine.c/h     # æ ¡å‡†å¼•æ“
â”‚   â”‚   â”‚   â””â”€â”€ data_converter.c/h         # æ•°æ®è½¬æ¢å™¨
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ control_algorithms/            # æ§åˆ¶ç®—æ³•ä¸­é—´ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ pid_controller.c/h         # PIDæ§åˆ¶å™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ adaptive_pid.c/h           # è‡ªé€‚åº”PID
â”‚   â”‚   â”‚   â”œâ”€â”€ fuzzy_control.c/h          # æ¨¡ç³Šæ§åˆ¶
â”‚   â”‚   â”‚   â”œâ”€â”€ state_machine.c/h          # çŠ¶æ€æœºå¼•æ“
â”‚   â”‚   â”‚   â””â”€â”€ control_manager.c/h        # æ§åˆ¶ç®¡ç†å™¨
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ safety_middleware/             # å®‰å…¨ä¿æŠ¤ä¸­é—´ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ safety_monitor.c/h         # å®‰å…¨ç›‘æ§
â”‚   â”‚   â”‚   â”œâ”€â”€ fault_detection.c/h        # æ•…éšœæ£€æµ‹
â”‚   â”‚   â”‚   â”œâ”€â”€ protection_logic.c/h       # ä¿æŠ¤é€»è¾‘
â”‚   â”‚   â”‚   â”œâ”€â”€ emergency_handler.c/h      # ç´§æ€¥å¤„ç†
â”‚   â”‚   â”‚   â””â”€â”€ watchdog_manager.c/h       # çœ‹é—¨ç‹—ç®¡ç†
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ utils/                         # å·¥å…·ä¸­é—´ä»¶
â”‚   â”‚       â”œâ”€â”€ math_utils.c/h             # æ•°å­¦å·¥å…·
â”‚   â”‚       â”œâ”€â”€ string_utils.c/h           # å­—ç¬¦ä¸²å·¥å…·
â”‚   â”‚       â”œâ”€â”€ crc_checksum.c/h           # CRCæ ¡éªŒ
â”‚   â”‚       â”œâ”€â”€ ring_buffer.c/h            # ç¯å½¢ç¼“å†²åŒº
â”‚   â”‚       â””â”€â”€ memory_pool.c/h            # å†…å­˜æ± ç®¡ç†
â”‚   â”‚
â”‚   â””â”€â”€ 04_application_layer/              # åº”ç”¨å±‚ (Application Layer) â­
â”‚       â”œâ”€â”€ control_applications/          # æ§åˆ¶åº”ç”¨
â”‚       â”‚   â”œâ”€â”€ ink_supply_control.c/h     # ä¾›å¢¨æ§åˆ¶åº”ç”¨
â”‚       â”‚   â”œâ”€â”€ temperature_control.c/h    # æ¸©åº¦æ§åˆ¶åº”ç”¨
â”‚       â”‚   â”œâ”€â”€ pressure_control.c/h       # å‹åŠ›æ§åˆ¶åº”ç”¨
â”‚       â”‚   â”œâ”€â”€ liquid_level_control.c/h   # æ¶²ä½æ§åˆ¶åº”ç”¨
â”‚       â”‚   â””â”€â”€ flow_control.c/h           # æµé‡æ§åˆ¶åº”ç”¨
â”‚       â”‚
â”‚       â”œâ”€â”€ sensor_applications/           # ä¼ æ„Ÿå™¨åº”ç”¨
â”‚       â”‚   â”œâ”€â”€ sensor_manager.c/h         # ä¼ æ„Ÿå™¨ç®¡ç†å™¨
â”‚       â”‚   â”œâ”€â”€ liquid_level_app.c/h       # æ¶²ä½ä¼ æ„Ÿå™¨åº”ç”¨ (FRD-8061)
â”‚       â”‚   â”œâ”€â”€ pressure_app.c/h           # å‹åŠ›ä¼ æ„Ÿå™¨åº”ç”¨ (HP10MY)
â”‚       â”‚   â”œâ”€â”€ temperature_app.c/h        # æ¸©åº¦ä¼ æ„Ÿå™¨åº”ç”¨ (FTT518)
â”‚       â”‚   â””â”€â”€ sensor_calibration_app.c/h # ä¼ æ„Ÿå™¨æ ¡å‡†åº”ç”¨
â”‚       â”‚
â”‚       â”œâ”€â”€ actuator_applications/         # æ‰§è¡Œå™¨åº”ç”¨
â”‚       â”‚   â”œâ”€â”€ actuator_manager.c/h       # æ‰§è¡Œå™¨ç®¡ç†å™¨
â”‚       â”‚   â”œâ”€â”€ heater_app.c/h             # åŠ çƒ­å™¨åº”ç”¨
â”‚       â”‚   â”œâ”€â”€ pump_app.c/h               # æ³µåº”ç”¨
â”‚       â”‚   â”œâ”€â”€ valve_app.c/h              # ç”µç£é˜€åº”ç”¨
â”‚       â”‚   â””â”€â”€ actuator_protection_app.c/h # æ‰§è¡Œå™¨ä¿æŠ¤åº”ç”¨
â”‚       â”‚
â”‚       â”œâ”€â”€ communication_applications/    # é€šä¿¡åº”ç”¨
â”‚       â”‚   â”œâ”€â”€ network_manager.c/h        # ç½‘ç»œç®¡ç†å™¨
â”‚       â”‚   â”œâ”€â”€ ethercat_app.c/h           # EtherCATåº”ç”¨
â”‚       â”‚   â”œâ”€â”€ tcp_server_app.c/h         # TCPæœåŠ¡å™¨åº”ç”¨
â”‚       â”‚   â””â”€â”€ protocol_router.c/h        # åè®®è·¯ç”±å™¨
â”‚       â”‚
â”‚       â”œâ”€â”€ hmi_applications/              # äººæœºç•Œé¢åº”ç”¨
â”‚       â”‚   â”œâ”€â”€ hmi_manager.c/h            # HMIç®¡ç†å™¨
â”‚       â”‚   â”œâ”€â”€ led_indicator_app.c/h      # LEDæŒ‡ç¤ºåº”ç”¨
â”‚       â”‚   â”œâ”€â”€ display_app.c/h            # æ˜¾ç¤ºåº”ç”¨ (CH12832B-12)
â”‚       â”‚
â”‚       â”œâ”€â”€ system_applications/           # ç³»ç»Ÿåº”ç”¨
â”‚       â”‚   â”œâ”€â”€ system_manager.c/h         # ç³»ç»Ÿç®¡ç†å™¨
â”‚       â”‚   â”œâ”€â”€ config_app.c/h             # é…ç½®ç®¡ç†åº”ç”¨
â”‚       â”‚   â”œâ”€â”€ logging_app.c/h            # æ—¥å¿—è®°å½•åº”ç”¨
â”‚       â”‚   â”œâ”€â”€ diagnostics_app.c/h        # ç³»ç»Ÿè¯Šæ–­åº”ç”¨
â”‚       â”‚
â”‚       â””â”€â”€ main_application/              # ä¸»åº”ç”¨
â”‚           â”œâ”€â”€ application_main.c/h       # åº”ç”¨ä¸»ç¨‹åº
â”‚           â”œâ”€â”€ system_startup.c/h         # ç³»ç»Ÿå¯åŠ¨
â”‚           â”œâ”€â”€ task_initialization.c/h    # ä»»åŠ¡åˆå§‹åŒ–
â”‚           â””â”€â”€ application_config.c/h     # åº”ç”¨é…ç½®
â”‚
â”œâ”€â”€ inc/                                   # å¤´æ–‡ä»¶ç›®å½• (æŒ‰å±‚æ¬¡ç»„ç»‡)
â”‚   â”œâ”€â”€ 01_bsp_layer/                      # BSPå±‚å¤´æ–‡ä»¶
â”‚   â”‚   â”œâ”€â”€ board_config.h                 # æ¿çº§é…ç½®
â”‚   â”‚   â”œâ”€â”€ hardware_defines.h             # ç¡¬ä»¶å®šä¹‰
â”‚   â”‚   â””â”€â”€ chip_drivers.h                 # èŠ¯ç‰‡é©±åŠ¨å¤´æ–‡ä»¶
â”‚   â”‚
â”‚   â”œâ”€â”€ 02_hal_layer/                      # HALå±‚å¤´æ–‡ä»¶
â”‚   â”‚   â”œâ”€â”€ hal_interfaces.h               # HALæ¥å£å®šä¹‰
â”‚   â”‚   â”œâ”€â”€ sensor_types.h                 # ä¼ æ„Ÿå™¨ç±»å‹å®šä¹‰
â”‚   â”‚   â””â”€â”€ actuator_types.h               # æ‰§è¡Œå™¨ç±»å‹å®šä¹‰
â”‚   â”‚
â”‚   â”œâ”€â”€ 03_middleware_layer/               # ä¸­é—´ä»¶å±‚å¤´æ–‡ä»¶
â”‚   â”‚   â”œâ”€â”€ rtos_config.h                  # RTOSé…ç½®
â”‚   â”‚   â”œâ”€â”€ protocol_defines.h             # åè®®å®šä¹‰
â”‚   â”‚   â””â”€â”€ algorithm_config.h             # ç®—æ³•é…ç½®
â”‚   â”‚
â”‚   â”œâ”€â”€ 04_application_layer/              # åº”ç”¨å±‚å¤´æ–‡ä»¶
â”‚   â”‚   â”œâ”€â”€ application_config.h           # åº”ç”¨é…ç½®
â”‚   â”‚   â”œâ”€â”€ system_defines.h               # ç³»ç»Ÿå®šä¹‰
â”‚   â”‚   â””â”€â”€ user_interface_config.h        # ç”¨æˆ·ç•Œé¢é…ç½®
â”‚   â”‚
â”‚   â”œâ”€â”€ main.h                             # ä¸»å¤´æ–‡ä»¶
â”‚   â”œâ”€â”€ system_config.h                    # ç³»ç»Ÿé…ç½®
â”‚   â”œâ”€â”€ error_codes.h                      # é”™è¯¯ä»£ç 
â”‚   â””â”€â”€ version.h                          # ç‰ˆæœ¬ä¿¡æ¯
â”‚
â”œâ”€â”€ lib/                                   # ç¬¬ä¸‰æ–¹åº“
â”‚   â”œâ”€â”€ GD32F4xx_HAL_Driver/               # GD32 HALåº“
â”‚   â”œâ”€â”€ CMSIS/                             # ARM CMSISåº“
â”‚   â””â”€â”€ lwip/                              # è½»é‡çº§TCP/IPåè®®æ ˆ 
â”‚   â””â”€â”€ FreeRTOS/                          # FREERTOS 
â”‚
â”œâ”€â”€ docs/                                  # è®¾è®¡æ–‡æ¡£ (å‚è€ƒæ–‡æ¡£)
â”œâ”€â”€ test/                                  # æµ‹è¯•ä»£ç 
â”œâ”€â”€ tools/                                 # å¼€å‘å·¥å…·
â”œâ”€â”€ build/                                 # æ„å»ºè¾“å‡ºç›®å½•
â”œâ”€â”€ Makefile                               # æ„å»ºé…ç½®
â”œâ”€â”€ CMakeLists.txt                         # CMakeé…ç½® 
â”œâ”€â”€ .gitignore                             # Gitå¿½ç•¥æ–‡ä»¶
â”œâ”€â”€ README.md                              # é¡¹ç›®è¯´æ˜
â””â”€â”€ CHANGELOG.md                           # å˜æ›´æ—¥å¿—
```

## 10.2 æ¶æ„å±‚æ¬¡å…³ç³»è¯´æ˜

### 10.2.1 å››å±‚æ¶æ„è°ƒç”¨å…³ç³»

```c
// å±‚æ¬¡è°ƒç”¨å…³ç³»ç¤ºæ„ (åªèƒ½å‘ä¸‹è°ƒç”¨ï¼Œä¸èƒ½è·¨å±‚è°ƒç”¨)

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    04_application_layer                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â†‘
â”‚  â”‚æ§åˆ¶åº”ç”¨æ¨¡å—  â”‚  â”‚ä¼ æ„Ÿå™¨åº”ç”¨    â”‚  â”‚é€šä¿¡åº”ç”¨æ¨¡å—  â”‚  â”‚HMIåº”ç”¨  â”‚  â”‚  â”‚
â”‚  â”‚             â”‚  â”‚æ¨¡å—         â”‚  â”‚             â”‚  â”‚æ¨¡å—     â”‚  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
                      â”‚ è°ƒç”¨                                         â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚                    03_middleware_layer                          â”‚  â”‚ ä¸š
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚ åŠ¡
â”‚  â”‚RTOSä¸­é—´ä»¶   â”‚  â”‚é€šä¿¡åè®®æ ˆ    â”‚  â”‚æ§åˆ¶ç®—æ³•å¼•æ“  â”‚  â”‚å®‰å…¨ä¿æŠ¤ â”‚  â”‚  â”‚ é€»
â”‚  â”‚             â”‚  â”‚ä¸­é—´ä»¶       â”‚  â”‚ä¸­é—´ä»¶       â”‚  â”‚ä¸­é—´ä»¶   â”‚  â”‚  â”‚ è¾‘
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
                      â”‚ è°ƒç”¨                                         â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚                    02_hal_layer                                 â”‚  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚ ç¡¬
â”‚  â”‚ä¼ æ„Ÿå™¨HAL    â”‚  â”‚æ‰§è¡Œå™¨HAL     â”‚  â”‚é€šä¿¡HAL      â”‚  â”‚ç³»ç»ŸHAL  â”‚  â”‚  â”‚ ä»¶
â”‚  â”‚             â”‚  â”‚             â”‚  â”‚             â”‚  â”‚        â”‚  â”‚  â”‚ æŠ½
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚ è±¡
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
                      â”‚ è°ƒç”¨                                         â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚                    01_bsp_layer                                 â”‚  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚ ç¡¬
â”‚  â”‚æ¿çº§æ”¯æŒåŒ…    â”‚  â”‚GD32F427é©±åŠ¨ â”‚  â”‚å¤–éƒ¨èŠ¯ç‰‡é©±åŠ¨  â”‚  â”‚ä¸­æ–­å¤„ç† â”‚  â”‚  â”‚ ä»¶
â”‚  â”‚             â”‚  â”‚             â”‚  â”‚             â”‚  â”‚        â”‚  â”‚  â”‚ é©±
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚ åŠ¨
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â†“
```

### 10.2.2 å±‚æ¬¡èŒè´£åˆ’åˆ†

**ç¬¬1å±‚ - BSPå±‚ (01_bsp_layer)**:
- **èŒè´£**: ç¡¬ä»¶å¯„å­˜å™¨çº§æ“ä½œã€ä¸­æ–­å¤„ç†ã€æ—¶é’Ÿé…ç½®
- **ç‰¹ç‚¹**: ä¸å…·ä½“ç¡¬ä»¶å¹³å°å¼ºç›¸å…³ï¼Œç§»æ¤æ—¶éœ€è¦ä¿®æ”¹
- **è°ƒç”¨**: åªèƒ½è°ƒç”¨HALåº“å’ŒCMSISæ ‡å‡†æ¥å£
- **è¢«è°ƒç”¨**: ä¸ºHALå±‚æä¾›åº•å±‚ç¡¬ä»¶æŠ½è±¡

**ç¬¬2å±‚ - HALå±‚ (02_hal_layer)**:
- **èŒè´£**: ç¡¬ä»¶åŠŸèƒ½æŠ½è±¡ï¼Œéšè—ç¡¬ä»¶å®ç°ç»†èŠ‚
- **ç‰¹ç‚¹**: æä¾›æ ‡å‡†åŒ–çš„ç¡¬ä»¶æ¥å£ï¼Œæ”¯æŒå¤šç§ç¡¬ä»¶å¹³å°
- **è°ƒç”¨**: åªèƒ½è°ƒç”¨BSPå±‚æ¥å£
- **è¢«è°ƒç”¨**: ä¸ºä¸­é—´ä»¶å±‚æä¾›è®¾å¤‡æ— å…³çš„ç¡¬ä»¶æ¥å£

**ç¬¬3å±‚ - ä¸­é—´ä»¶å±‚ (03_middleware_layer)**:
- **èŒè´£**: åè®®æ ˆã€ç®—æ³•å¼•æ“ã€RTOSæœåŠ¡ã€æ•°æ®å¤„ç†
- **ç‰¹ç‚¹**: ä¸šåŠ¡é€»è¾‘æ— å…³ï¼Œå¯å¤ç”¨çš„åŠŸèƒ½ç»„ä»¶
- **è°ƒç”¨**: åªèƒ½è°ƒç”¨HALå±‚æ¥å£
- **è¢«è°ƒç”¨**: ä¸ºåº”ç”¨å±‚æä¾›é«˜çº§æœåŠ¡å’Œç®—æ³•

**ç¬¬4å±‚ - åº”ç”¨å±‚ (04_application_layer)**:
- **èŒè´£**: ä¸šåŠ¡é€»è¾‘å®ç°ã€ç”¨æˆ·éœ€æ±‚å®ç°
- **ç‰¹ç‚¹**: ä¸å…·ä½“åº”ç”¨åœºæ™¯ç›¸å…³
- **è°ƒç”¨**: åªèƒ½è°ƒç”¨ä¸­é—´ä»¶å±‚æ¥å£
- **è¢«è°ƒç”¨**: ç³»ç»Ÿæœ€é¡¶å±‚ï¼Œä¸è¢«å…¶ä»–å±‚è°ƒç”¨

### 10.2.3 å±‚é—´æ¥å£è§„èŒƒ

```c
// å±‚é—´æ¥å£è°ƒç”¨è§„èŒƒç¤ºä¾‹

// âŒ é”™è¯¯: åº”ç”¨å±‚ç›´æ¥è°ƒç”¨BSPå±‚ (è·¨å±‚è°ƒç”¨)
void temperature_control_app(void) {
    // é”™è¯¯!!! åº”ç”¨å±‚ç›´æ¥æ“ä½œADCå¯„å­˜å™¨
    ADC0_RDATA = adc_read_channel(ADC_CHANNEL_1);
}

// âœ… æ­£ç¡®: åº”ç”¨å±‚é€šè¿‡ä¸­é—´ä»¶å±‚è°ƒç”¨
void temperature_control_app(void) {
    // æ­£ç¡®: åº”ç”¨å±‚ -> ä¸­é—´ä»¶å±‚
    float temperature = sensor_data_processor_get_temperature(TEMP_SENSOR_1);

    // æ­£ç¡®: åº”ç”¨å±‚ -> ä¸­é—´ä»¶å±‚ -> HALå±‚ -> BSPå±‚
    pid_control_execute(PID_TEMPERATURE, temperature);
}

// âœ… æ­£ç¡®: ä¸­é—´ä»¶å±‚è°ƒç”¨HALå±‚
float sensor_data_processor_get_temperature(uint8_t sensor_id) {
    // æ­£ç¡®: ä¸­é—´ä»¶å±‚ -> HALå±‚
    uint16_t raw_adc = temperature_hal_read_adc(sensor_id);

    // ä¸­é—´ä»¶å±‚å¤„ç†æ•°æ®
    float temperature = pt100_convert_resistance_to_temperature(raw_adc);
    return temperature;
}

// âœ… æ­£ç¡®: HALå±‚è°ƒç”¨BSPå±‚
uint16_t temperature_hal_read_adc(uint8_t sensor_id) {
    // æ­£ç¡®: HALå±‚ -> BSPå±‚
    return adc_driver_read_channel(get_adc_channel_by_sensor_id(sensor_id));
}
```

### 10.2.4 ç¼–è¯‘ä¾èµ–å…³ç³»

```makefile
# Makefileä¸­çš„ç¼–è¯‘é¡ºåºä½“ç°å±‚æ¬¡å…³ç³»

# 1. é¦–å…ˆç¼–è¯‘BSPå±‚ (æœ€åº•å±‚ï¼Œæ— ä¾èµ–)
BSP_SOURCES = src/01_bsp_layer/**/*.c

# 2. ç„¶åç¼–è¯‘HALå±‚ (ä¾èµ–BSPå±‚)
HAL_SOURCES = src/02_hal_layer/**/*.c

# 3. æ¥ç€ç¼–è¯‘ä¸­é—´ä»¶å±‚ (ä¾èµ–HALå±‚)
MIDDLEWARE_SOURCES = src/03_middleware_layer/**/*.c

# 4. æœ€åç¼–è¯‘åº”ç”¨å±‚ (ä¾èµ–ä¸­é—´ä»¶å±‚)
APPLICATION_SOURCES = src/04_application_layer/**/*.c

# ç¼–è¯‘é¡ºåº
$(BUILD_DIR)/01_bsp.o: $(BSP_SOURCES)
$(BUILD_DIR)/02_hal.o: $(HAL_SOURCES) $(BUILD_DIR)/01_bsp.o
$(BUILD_DIR)/03_middleware.o: $(MIDDLEWARE_SOURCES) $(BUILD_DIR)/02_hal.o
$(BUILD_DIR)/04_application.o: $(APPLICATION_SOURCES) $(BUILD_DIR)/03_middleware.o
```

è¿™æ ·çš„ç›®å½•ç»“æ„å’Œç»„ç»‡æ–¹å¼æ¸…æ™°åœ°ä½“ç°äº†å››å±‚æ¶æ„çš„å±‚æ¬¡å…³ç³»ï¼Œç¡®ä¿äº†ï¼š

ğŸ”¹ **å±‚æ¬¡æ¸…æ™°**: é€šè¿‡ç›®å½•å‘½å (01/02/03/04) æ˜ç¡®å±‚æ¬¡é¡ºåº
ğŸ”¹ **èŒè´£åˆ†æ˜**: æ¯å±‚ä¸“æ³¨äºç‰¹å®šèŒè´£ï¼Œé™ä½è€¦åˆåº¦
ğŸ”¹ **æ˜“äºç»´æŠ¤**: å±‚æ¬¡åŒ–ç®¡ç†ä¾¿äºä»£ç ç»´æŠ¤å’Œå‡çº§
ğŸ”¹ **å¯ç§»æ¤æ€§**: BSPå±‚å’ŒHALå±‚åˆ†ç¦»ï¼Œä¾¿äºç¡¬ä»¶å¹³å°ç§»æ¤
ğŸ”¹ **å¯å¤ç”¨æ€§**: ä¸­é—´ä»¶å±‚å¯åœ¨ä¸åŒé¡¹ç›®é—´å¤ç”¨

---

# ç¬¬åä¸€ç«  å…³é”®ç®—æ³•ä¼˜åŒ–

## 11.1 è‡ªé€‚åº”PIDæ§åˆ¶ç®—æ³•

### 11.1.1 åŸºäºæ¨¡ç³Šé€»è¾‘çš„PIDè‡ªæ•´å®š

```c
// è‡ªé€‚åº”PIDæ§åˆ¶å™¨ (åŸºäºæ¨¡ç³Šé€»è¾‘æ•´å®š)
typedef struct {
    // åŸºç¡€PIDå‚æ•°
    float kp, ki, kd;                    // å½“å‰PIDå‚æ•°
    float kp_base, ki_base, kd_base;     // åŸºç¡€PIDå‚æ•°

    // è‡ªé€‚åº”å‚æ•°
    float error_threshold_small;         // å°è¯¯å·®é˜ˆå€¼
    float error_threshold_large;         // å¤§è¯¯å·®é˜ˆå€¼
    float error_rate_threshold;          // è¯¯å·®å˜åŒ–ç‡é˜ˆå€¼
    float adaptation_rate;               // è‡ªé€‚åº”é€Ÿç‡

    // å†å²æ•°æ®
    float error_history[10];             // è¯¯å·®å†å²è®°å½•
    uint8_t history_index;               // å†å²ç´¢å¼•
    uint32_t stable_count;               // ç¨³å®šè®¡æ•°
    uint32_t last_update_time;           // ä¸Šæ¬¡æ›´æ–°æ—¶é—´

    // çŠ¶æ€æ ‡å¿—
    bool adaptive_mode_enabled;          // è‡ªé€‚åº”æ¨¡å¼ä½¿èƒ½
    bool system_stable;                  // ç³»ç»Ÿç¨³å®šæ ‡å¿—
    uint8_t control_mode;                // æ§åˆ¶æ¨¡å¼ (0=æ‰‹åŠ¨, 1=è‡ªåŠ¨, 2=è‡ªé€‚åº”)

} adaptive_pid_controller_t;

// è‡ªé€‚åº”PIDæ§åˆ¶å‡½æ•° (åŸºäºæ¸©åº¦/å‹åŠ›æ§åˆ¶éœ€æ±‚)
float adaptive_pid_control(adaptive_pid_controller_t *pid, float setpoint, float process_value) {
    uint32_t current_time = get_system_tick();
    float dt = (current_time - pid->last_update_time) / 1000.0f; // è½¬æ¢ä¸ºç§’

    if (dt <= 0.001f) return 0.0f; // é¿å…é™¤é›¶é”™è¯¯

    // è®¡ç®—å½“å‰è¯¯å·®å’Œè¯¯å·®å˜åŒ–ç‡
    float error = setpoint - process_value;
    float abs_error = fabs(error);

    // æ›´æ–°è¯¯å·®å†å²
    pid->error_history[pid->history_index] = error;
    pid->history_index = (pid->history_index + 1) % 10;

    // è®¡ç®—è¯¯å·®å˜åŒ–ç‡
    float error_rate = 0.0f;
    if (pid->history_index >= 2) {
        int prev_index = (pid->history_index + 8) % 10; // å‰ä¸¤ä¸ªæ ·æœ¬
        error_rate = (error - pid->error_history[prev_index]) / dt;
    }

    // è‡ªé€‚åº”å‚æ•°è°ƒæ•´ (åŸºäºæ¨¡ç³Šé€»è¾‘è§„åˆ™)
    if (pid->adaptive_mode_enabled) {
        // è§„åˆ™1: å¤§è¯¯å·®æ—¶å¢åŠ æ¯”ä¾‹å¢ç›Šï¼Œå‡å°‘ç§¯åˆ†å¢ç›Š
        if (abs_error > pid->error_threshold_large) {
            pid->kp = pid->kp_base * (1.0f + pid->adaptation_rate);
            pid->ki = pid->ki_base * (1.0f - pid->adaptation_rate * 0.5f);
            pid->kd = pid->kd_base * (1.0f + pid->adaptation_rate * 0.3f);
            pid->stable_count = 0;
        }
        // è§„åˆ™2: å°è¯¯å·®æ—¶æ¢å¤æ ‡å‡†å‚æ•°
        else if (abs_error < pid->error_threshold_small) {
            pid->stable_count++;
            if (pid->stable_count > 50) { // ç¨³å®š50ä¸ªå‘¨æœŸåæ¢å¤
                pid->kp = pid->kp_base;
                pid->ki = pid->ki_base;
                pid->kd = pid->kd_base;
                pid->system_stable = true;
            }
        }
        // è§„åˆ™3: è¯¯å·®å˜åŒ–ç‡å¤§æ—¶å¢åŠ å¾®åˆ†å¢ç›Š
        else if (fabs(error_rate) > pid->error_rate_threshold) {
            pid->kd = pid->kd_base * (1.0f + pid->adaptation_rate * 0.5f);
        }
    }

    // æ‰§è¡Œæ ‡å‡†PIDè®¡ç®— (å¸¦ç§¯åˆ†åˆ†ç¦»)
    static float integral_sum = 0.0f;
    static float last_error = 0.0f;

    // ç§¯åˆ†åˆ†ç¦» (å¤§è¯¯å·®æ—¶ä¸ç§¯åˆ†)
    if (abs_error < pid->error_threshold_large) {
        integral_sum += error * dt;

        // ç§¯åˆ†é™å¹…é˜²æ­¢ç§¯åˆ†é¥±å’Œ
        float integral_limit = 100.0f / pid->ki; // æ ¹æ®è¾“å‡ºé™åˆ¶è®¡ç®—ç§¯åˆ†é™åˆ¶
        if (integral_sum > integral_limit) integral_sum = integral_limit;
        if (integral_sum < -integral_limit) integral_sum = -integral_limit;
    }

    // è®¡ç®—å¾®åˆ†é¡¹ (å¸¦ä½é€šæ»¤æ³¢)
    float derivative = (error - last_error) / dt;
    static float filtered_derivative = 0.0f;
    filtered_derivative = 0.8f * filtered_derivative + 0.2f * derivative; // ä½é€šæ»¤æ³¢

    // PIDè¾“å‡ºè®¡ç®—
    float pid_output = pid->kp * error + pid->ki * integral_sum + pid->kd * filtered_derivative;

    // è¾“å‡ºé™åˆ¶
    if (pid_output > 100.0f) pid_output = 100.0f;
    if (pid_output < -100.0f) pid_output = -100.0f;

    // æ›´æ–°å†å²æ•°æ®
    last_error = error;
    pid->last_update_time = current_time;

    return pid_output;
}
```

### 11.1.2 æ•°å­—æ»¤æ³¢ç®—æ³•ä¼˜åŒ–

```c
// å¤šç§æ•°å­—æ»¤æ³¢ç®—æ³•é›†æˆ (åŸºäºä¼ æ„Ÿå™¨å™ªå£°ç‰¹æ€§)
typedef struct {
    // æ»‘åŠ¨å¹³å‡æ»¤æ³¢
    float moving_avg_buffer[16];         // æ»‘åŠ¨å¹³å‡ç¼“å†²åŒº
    uint8_t moving_avg_index;            // å½“å‰ç´¢å¼•
    uint8_t moving_avg_size;             // çª—å£å¤§å°

    // å¡å°”æ›¼æ»¤æ³¢å‚æ•°
    float kalman_q;                      // è¿‡ç¨‹å™ªå£°åæ–¹å·®
    float kalman_r;                      // æµ‹é‡å™ªå£°åæ–¹å·®
    float kalman_x;                      // çŠ¶æ€ä¼°è®¡
    float kalman_p;                      // ä¼°è®¡è¯¯å·®åæ–¹å·®
    float kalman_k;                      // å¡å°”æ›¼å¢ç›Š

    // ä¸­å€¼æ»¤æ³¢
    float median_buffer[5];              // ä¸­å€¼æ»¤æ³¢ç¼“å†²åŒº
    uint8_t median_index;                // ä¸­å€¼æ»¤æ³¢ç´¢å¼•

    // é™å¹…æ»¤æ³¢
    float limit_max;                     // ä¸Šé™å€¼
    float limit_min;                     // ä¸‹é™å€¼
    float last_valid_value;              // ä¸Šæ¬¡æœ‰æ•ˆå€¼

} digital_filter_t;

// ç»¼åˆæ»¤æ³¢å¤„ç†å‡½æ•°
float digital_filter_process(digital_filter_t *filter, float raw_value) {
    float filtered_value = raw_value;

    // 1. é™å¹…æ»¤æ³¢ (å»é™¤æ˜æ˜¾å¼‚å¸¸å€¼)
    if (filtered_value > filter->limit_max || filtered_value < filter->limit_min) {
        filtered_value = filter->last_valid_value; // ä½¿ç”¨ä¸Šæ¬¡æœ‰æ•ˆå€¼
    }

    // 2. ä¸­å€¼æ»¤æ³¢ (å»é™¤è„‰å†²å¹²æ‰°)
    filter->median_buffer[filter->median_index] = filtered_value;
    filter->median_index = (filter->median_index + 1) % 5;

    // è®¡ç®—ä¸­å€¼ (5ç‚¹ä¸­å€¼)
    float temp_array[5];
    memcpy(temp_array, filter->median_buffer, sizeof(temp_array));

    // ç®€å•æ’åºæ±‚ä¸­å€¼
    for (int i = 0; i < 4; i++) {
        for (int j = i + 1; j < 5; j++) {
            if (temp_array[i] > temp_array[j]) {
                float temp = temp_array[i];
                temp_array[i] = temp_array[j];
                temp_array[j] = temp;
            }
        }
    }
    filtered_value = temp_array[2]; // ä¸­å€¼

    // 3. å¡å°”æ›¼æ»¤æ³¢ (æœ€ä¼˜ä¼°è®¡)
    // é¢„æµ‹æ­¥éª¤
    float x_pred = filter->kalman_x;
    float p_pred = filter->kalman_p + filter->kalman_q;

    // æ›´æ–°æ­¥éª¤
    filter->kalman_k = p_pred / (p_pred + filter->kalman_r);
    filter->kalman_x = x_pred + filter->kalman_k * (filtered_value - x_pred);
    filter->kalman_p = (1.0f - filter->kalman_k) * p_pred;

    filtered_value = filter->kalman_x;

    // 4. æ»‘åŠ¨å¹³å‡æ»¤æ³¢ (å¹³æ»‘è¾“å‡º)
    filter->moving_avg_buffer[filter->moving_avg_index] = filtered_value;
    filter->moving_avg_index = (filter->moving_avg_index + 1) % filter->moving_avg_size;

    float sum = 0.0f;
    for (int i = 0; i < filter->moving_avg_size; i++) {
        sum += filter->moving_avg_buffer[i];
    }
    filtered_value = sum / filter->moving_avg_size;

    // æ›´æ–°ä¸Šæ¬¡æœ‰æ•ˆå€¼
    filter->last_valid_value = filtered_value;

    return filtered_value;
}
```

---

# æ€»ç»“

æœ¬ç»¼åˆæŠ€æœ¯è®¾è®¡æ–‡æ¡£æ•´åˆäº†ä¾›å¢¨ç³»ç»Ÿæ§åˆ¶æ¿å¡çš„å®Œæ•´æŠ€æœ¯æ–¹æ¡ˆï¼Œæ¶µç›–äº†ä»ç¡¬ä»¶æ¶æ„åˆ°è½¯ä»¶å®ç°çš„å…¨æ–¹é¢å†…å®¹ï¼š

## ä¸»è¦æŠ€æœ¯ç‰¹ç‚¹

1. **å…ˆè¿›çš„ç¡¬ä»¶å¹³å°**: åŸºäºGD32F427VGT6ä¸»æ§èŠ¯ç‰‡ï¼Œ200MHzä¸»é¢‘ï¼Œæ”¯æŒå¤æ‚æ§åˆ¶ç®—æ³•
2. **å®Œæ•´çš„é€šä¿¡èƒ½åŠ›**: æ”¯æŒEtherCATå·¥ä¸šæ€»çº¿å’Œæ ‡å‡†ä»¥å¤ªç½‘ï¼Œæ»¡è¶³ä¸åŒç»„ç½‘éœ€æ±‚
3. **ç²¾å¯†çš„ä¿¡å·å¤„ç†**: 15bit ADCé‡‡é›†ï¼Œæ”¯æŒ4-20mAå’ŒPT100ä¿¡å·å¤„ç†
4. **å®Œå–„çš„äººæœºç•Œé¢**: LEDæŒ‡ç¤ºç³»ç»Ÿã€LCDæ˜¾ç¤ºå±ã€å®Œæ•´çš„çŠ¶æ€åé¦ˆ
5. **å¯é çš„å®‰å…¨ä¿æŠ¤**: å¤šçº§å®‰å…¨ä¿æŠ¤æœºåˆ¶ï¼Œæ•…éšœæ£€æµ‹ä¸è¯Šæ–­ç³»ç»Ÿ
6. **çµæ´»çš„é…ç½®ç®¡ç†**: å®Œæ•´çš„å‚æ•°é…ç½®å’Œå­˜å‚¨ç®¡ç†ç³»ç»Ÿ

## æŠ€æœ¯åˆ›æ–°ç‚¹

1. **è‡ªé€‚åº”PIDæ§åˆ¶**: åŸºäºæ¨¡ç³Šé€»è¾‘çš„PIDå‚æ•°è‡ªæ•´å®šç®—æ³•
2. **å¤šé‡æ•°å­—æ»¤æ³¢**: ç»¼åˆå¤šç§æ»¤æ³¢ç®—æ³•æé«˜æ•°æ®è´¨é‡
3. **åˆ†å±‚è½¯ä»¶æ¶æ„**: å››å±‚æ¶æ„è®¾è®¡ï¼Œæ¨¡å—åŒ–ç¨‹åº¦é«˜ï¼Œæ˜“äºç»´æŠ¤
4. **å®æ—¶ä»»åŠ¡è°ƒåº¦**: åŸºäºä¼˜å…ˆçº§çš„å®æ—¶ä»»åŠ¡è°ƒåº¦ç³»ç»Ÿ
5. **å®Œæ•´ç›‘æ§ç³»ç»Ÿ**: ç³»ç»Ÿå¥åº·ç›‘æ§ã€æ€§èƒ½ç»Ÿè®¡ã€æ•…éšœè¯Šæ–­ä¸€ä½“åŒ–

## æ–‡æ¡£å‚è€ƒä½“ç³»

æœ¬æ–‡æ¡£åŸºäºä»¥ä¸‹å‚è€ƒèµ„æ–™ç¼–å†™ï¼š
- **ä»€æ–¹ç§‘æŠ€ä¾›å¢¨ç³»ç»Ÿæ§åˆ¶æ¿å¡è®¾è®¡æ–¹æ¡ˆV1.1** (åŸå§‹24é¡µPNGè®¾è®¡å›¾)
- **è®¾è®¡æ–¹æ¡ˆç›®å½•ç´¢å¼•ä¸å¯¼èˆªæ–‡æ¡£** (æŠ€æœ¯ç´¢å¼•ç³»ç»Ÿ)
- **ç¡¬ä»¶æ¶æ„è¡¨æ ¼å’Œè§£è¯»æ–‡æ¡£** (ç¡¬ä»¶æŠ€æœ¯åˆ†æ)
- **åŸæœ‰è½¯ä»¶æ¶æ„æ–‡æ¡£** (åŸºç¡€è½¯ä»¶è®¾è®¡)
- **è¡¥å……è½¯ä»¶æ¶æ„æ–‡æ¡£** (åŠŸèƒ½æ‰©å±•è®¾è®¡)

æœ¬æ–‡æ¡£ä¸ºä»€æ–¹ç§‘æŠ€InkCoreç”µèŠ¯ç»ç¼˜æ¶‚å±‚æ‰“å°æœºä¾›å¢¨ç³»ç»Ÿçš„è½¯ä»¶å¼€å‘æä¾›äº†å®Œæ•´çš„æŠ€æœ¯æŒ‡å¯¼å’Œå®ç°æ–¹æ¡ˆã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬**: V1.0
**åˆ›å»ºæ—¥æœŸ**: 2025-09-26
**åˆ›å»ºè€…**: ä»€æ–¹ç§‘æŠ€è½¯ç¡¬ä»¶ç ”å‘éƒ¨
**é€‚ç”¨äº§å“**: InkCoreç”µèŠ¯ç»ç¼˜æ¶‚å±‚æ‰“å°æœºä¾›å¢¨ç³»ç»Ÿæ§åˆ¶æ¿å¡
**æŠ€æœ¯å¹³å°**: GD32F427VGT6 + EtherCAT + TCP/IP
**æ–‡æ¡£ç±»å‹**: ç»¼åˆæŠ€æœ¯è®¾è®¡æ–‡æ¡£
**å‚è€ƒæ¶æ„**: UV Ink Service V1.0 (ç¬¬20é¡µç¡¬ä»¶åŠŸèƒ½æ¶æ„å›¾)