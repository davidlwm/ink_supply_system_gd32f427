# 供墨系统控制板卡综合技术设计文档

## 文档概述

本文档综合了《供墨系统控制板卡软件架构设计文档》和《供墨系统软件架构补充设计文档》的完整内容，结合硬件架构分析和24页原始设计方案，为什方科技InkCore电芯绝缘涂层打印机供墨系统控制板卡提供完整的技术设计规范。

## 📋 文档参考依据

### 原始设计资料
- **什方科技供墨系统控制板卡设计方案V1.1** (第1-24页 PNG文件)
- **第20页硬件功能架构图** - UV Ink Service V1.0 核心架构 ⭐
- **第17页PLC功能模块定义** - 完整IO地址映射表 🔧
- **第18页功能接口规格汇总** - 硬件接口参数表 📋

### 配套技术文档
- **设计方案目录索引与导航文档** - 完整技术索引系统
- **供墨系统硬件架构信息表格** - 硬件规格参数表
- **第20页硬件架构详细解读文档** - 硬件技术深度分析

---

# 第一章 系统总体架构设计

## 1.1 系统概述

**产品定位**: 什方科技InkCore电芯绝缘涂层打印机供墨系统控制板卡
**应用场景**: 多工位独立供墨架构，满足电芯绝缘涂层打印的精密控制需求
**设计理念**: 模块化、工业级、高可靠性、易维护

### 1.1.1 核心技术参数 (基于原始设计第18页)

| 参数类型 | 技术规格 | 性能指标 | 参考来源 |
|----------|----------|----------|----------|
| **主控芯片** | GD32F427VGT6 | 200MHz, 1024K Flash, 100PIN | 第18页+第20页架构图 |
| **通信协议** | EtherCAT + 以太网 | 100Mbps双协议支持 | 第20页+第21-23页组网 |
| **模拟采集** | 15bit ADC | 多通道高精度采集 | 第14-15页信号处理 |
| **数字IO** | 光电隔离 | 24路数字IO，0.5A输出 | 第16-17页IO定义 |
| **显示接口** | CH12832B-12 | 128×32点阵LCD | 第18页接口规格 |

### 1.1.2 系统功能分区 (参考第20页架构图)

```
┌─────────────────────────────────────────────────────────────────┐
│                   UV Ink Service V1.0 系统架构                    │
├─────────────────┬─────────────────┬─────────────────┬─────────────┤
│   电源管理区     │    主控处理区    │    通信接口区    │   模拟信号区  │
│                │                │                │             │
│  AC220V输入     │  GD32F427VGT6   │  EtherCAT      │  15bit ADC  │
│  DC24V转换      │  ARM Cortex-M4  │  YT8512C PHY   │  信号调理    │
│  多路DC-DC      │  200MHz主频     │  网络接口      │  4-20mA处理 │
│                │                │                │  PT100处理  │
├─────────────────┼─────────────────┼─────────────────┼─────────────┤
│   数字IO区      │    LED指示区    │    HMI界面区    │   安全监控区  │
│                │                │                │             │
│  光电隔离       │  5路状态指示LED │  LCD显示屏     │  看门狗保护   │
│  继电器驱动     │  红绿黄蓝白     │  按键接口      │  故障检测     │
│  24V输出控制   │  GPIO控制      │  用户交互      │  系统监控     │
└─────────────────┴─────────────────┴─────────────────┴─────────────┘
```

## 1.2 分层软件架构设计

基于GD32F427平台的四层软件架构，整合了基础功能和补充功能模块：

### 1.2.1 架构层次结构

```
┌─────────────────────────────────────────────────────────────────┐
│                        应用层 (Application Layer)                │
├─────────────────┬─────────────────┬─────────────────┬─────────────┤
│   基础控制模块   │    HMI界面模块   │   系统监控模块   │   配置管理   │
│                │                │                │             │
│  • 供墨控制算法  │  • LED管理系统  │  • 健康监控     │  • 参数配置  │
│  • 温度控制PID  │  • LCD显示管理  │  • 故障诊断     │  • Flash存储 │
│  • 压力监控     │  • 按键处理     │  • 性能统计     │  • 校验管理  │
│  • 液位管理     │  • 用户交互     │  • 日志记录     │  • 默认配置  │
└─────────────────┴─────────────────┴─────────────────┴─────────────┘
┌─────────────────────────────────────────────────────────────────┐
│                      中间件层 (Middleware Layer)                  │
├─────────────────┬─────────────────┬─────────────────┬─────────────┤
│   任务调度      │    通信协议栈    │    数据处理     │   安全保护   │
│                │                │                │             │
│  • RTOS调度    │  • EtherCAT协议 │  • 滤波算法     │  • 看门狗    │
│  • 优先级管理  │  • TCP/IP协议   │  • 校准算法     │  • 故障保护  │
│  • 时间片分配  │  • Modbus协议   │  • 数据融合     │  • 紧急处理  │
│  • 任务监控    │  • 自定义协议   │  • 状态机管理   │  • 安全监控  │
└─────────────────┴─────────────────┴─────────────────┴─────────────┘
┌─────────────────────────────────────────────────────────────────┐
│                    硬件抽象层 (HAL Layer)                        │
├─────────────────┬─────────────────┬─────────────────┬─────────────┤
│   传感器接口    │    执行器接口    │    通信接口     │   系统接口   │
│                │                │                │             │
│  • ADC采集驱动 │  • PWM输出驱动  │  • UART驱动    │  • GPIO驱动  │
│  • 信号调理    │  • DAC输出驱动  │  • SPI驱动     │  • 定时器    │
│  • 数据转换    │  • 继电器控制  │  • I2C驱动     │  • 中断管理  │
│  • 校准处理    │  • 保护机制    │  • CAN驱动     │  • 时钟管理  │
└─────────────────┴─────────────────┴─────────────────┴─────────────┘
┌─────────────────────────────────────────────────────────────────┐
│                      底层驱动 (BSP Layer)                        │
├─────────────────┬─────────────────┬─────────────────┬─────────────┤
│   GD32F427库    │    外设初始化    │    中断处理     │   系统管理   │
│                │                │                │             │
│  • HAL库函数   │  • 时钟配置     │  • 中断向量表   │  • 启动代码  │
│  • 寄存器操作  │  • GPIO配置     │  • 中断服务函数 │  • 内存管理  │
│  • 底层API     │  • 外设配置     │  • 优先级配置   │  • 复位管理  │
│  • 芯片抽象    │  • 管脚复用     │  • 嵌套管理     │  • 电源管理  │
└─────────────────┴─────────────────┴─────────────────┴─────────────┘
```

---

# 第二章 硬件接口与信号处理

## 2.1 传感器系统设计 (基于第8-15页原始设计)

### 2.1.1 液位传感器接口 - FRD-8061

**硬件规格** (来源: 第8页传感器规格)
```c
// 液位传感器配置 (基于第8页技术参数)
typedef struct {
    char model[16];           // "FRD-8061"
    float range_min;          // 0mm (最小液位)
    float range_max;          // 2000mm (最大液位)
    float accuracy;           // ±1.0% (精度等级)
    float output_min;         // 4.0mA (输出下限)
    float output_max;         // 20.0mA (输出上限)
    uint16_t response_time;   // <1000ms (响应时间)
    uint8_t supply_voltage;   // 24V (供电电压)
} liquid_level_sensor_spec_t;
```

**信号处理电路** (基于第13页信号处理设计)
```c
// 4-20mA转换电路实现 (参考第13页电路图)
float convert_4_20ma_to_level(uint16_t adc_value) {
    // ADC配置: 15bit分辨率，参考电压3.3V
    float voltage = (float)adc_value * 3.3f / 32768.0f;  // 15bit ADC

    // 通过250Ω精密电阻转换为电压 (1-5V对应4-20mA)
    float current = voltage / 250.0f * 1000.0f;  // 转换为mA

    // 线性转换为液位值 (4mA=0mm, 20mA=2000mm)
    if (current < 4.0f) return -1;  // 传感器故障
    if (current > 20.0f) return -1; // 传感器故障

    float level = (current - 4.0f) * 2000.0f / 16.0f;  // mm
    return level;
}
```

### 2.1.2 压力传感器接口 - HP10MY

**硬件规格** (来源: 第9页传感器规格)
```c
// 压力传感器配置 (基于第9页技术参数)
typedef struct {
    char model[16];           // "HP10MY"
    float range_min;          // -100kPa (负压下限)
    float range_max;          // 100000kPa (正压上限, 100MPa)
    float accuracy;           // ±1.5% (精度等级)
    float output_min;         // 4.0mA (输出下限)
    float output_max;         // 20.0mA (输出上限)
    uint16_t response_time;   // <100ms (响应时间)
    uint8_t supply_voltage;   // 24V (供电电压)
} pressure_sensor_spec_t;
```

**信号处理算法** (基于第14页压力信号处理)
```c
// 压力传感器数据处理 (参考第14页算法)
typedef struct {
    float raw_pressure;       // 原始压力值
    float filtered_pressure;  // 滤波后压力值
    float calibrated_pressure; // 校准后压力值
    uint32_t sample_count;    // 采样计数
    bool sensor_fault;        // 传感器故障标志
} pressure_data_t;

float process_pressure_sensor(uint16_t adc_value, uint8_t channel) {
    static pressure_data_t pressure_data[2] = {0}; // 支持2路压力传感器

    // ADC原始值转换 (15bit精度，参考第14页)
    float voltage = (float)adc_value * 3.3f / 32768.0f;
    float current = voltage / 250.0f * 1000.0f;  // mA

    // 线性转换为压力值
    if (current < 3.5f || current > 20.5f) {
        pressure_data[channel].sensor_fault = true;
        return -999.0f;  // 错误代码
    }

    // 压力范围映射 (4mA=-100kPa, 20mA=100MPa)
    float pressure = -100.0f + (current - 4.0f) * (100100.0f / 16.0f);

    // 数字滤波处理 (一阶低通滤波)
    pressure_data[channel].filtered_pressure =
        pressure_data[channel].filtered_pressure * 0.9f + pressure * 0.1f;

    // 校准处理 (基于配置参数)
    pressure_data[channel].calibrated_pressure =
        pressure_data[channel].filtered_pressure * get_pressure_scale(channel) +
        get_pressure_offset(channel);

    pressure_data[channel].sample_count++;
    return pressure_data[channel].calibrated_pressure;
}
```

### 2.1.3 温度传感器接口 - FTT518 PT100

**硬件规格** (来源: 第9页传感器规格)
```c
// PT100温度传感器配置 (基于第9页技术参数)
typedef struct {
    char model[16];           // "FTT518"
    char sensor_type[16];     // "PT100 A级"
    float range_min;          // 50°C (测量下限)
    float range_max;          // 600°C (测量上限)
    float accuracy_class;     // 0.15% (A级精度)
    float r0_nominal;         // 100.0Ω (0°C标称电阻)
    float alpha;              // 0.003851 (温度系数)
    uint8_t wire_connection;  // 3 (三线制连接)
} pt100_sensor_spec_t;
```

**信号调理电路** (基于第15页温度信号处理)
```c
// PT100三线制信号处理 (参考第15页电路设计)
float process_pt100_temperature(uint16_t adc_value_signal, uint16_t adc_value_ref) {
    // 恒流激励: 1mA恒定电流 (第15页设计参数)
    const float excitation_current = 0.001f;  // 1mA
    const float reference_resistor = 1000.0f; // 1kΩ参考电阻

    // ADC电压转换 (15bit分辨率)
    float voltage_signal = (float)adc_value_signal * 3.3f / 32768.0f;
    float voltage_ref = (float)adc_value_ref * 3.3f / 32768.0f;

    // 三线制补偿算法
    float resistance_signal = voltage_signal / excitation_current;
    float wire_resistance = (reference_resistor - voltage_ref / excitation_current) / 2.0f;
    float pt100_resistance = resistance_signal - 2.0f * wire_resistance;

    // PT100电阻-温度转换 (Callendar-Van Dusen方程简化)
    float temperature;
    if (pt100_resistance >= 100.0f) {
        // 正温度计算
        temperature = (pt100_resistance - 100.0f) / (100.0f * 0.003851f);
    } else {
        // 负温度计算 (如果需要)
        temperature = (pt100_resistance - 100.0f) / (100.0f * 0.003851f);
    }

    return temperature;
}
```

## 2.2 执行器控制系统 (基于第10-16页原始设计)

### 2.2.1 加热器控制 - AC220V系统

**硬件规格** (来源: 第10页执行器规格)
```c
// 加热器控制配置 (基于第10页技术参数)
typedef struct {
    char model[16];           // "MRA-23D3"
    uint16_t voltage_rating;  // 220V (额定电压)
    uint16_t power_rating;    // 150W/100W (额定功率)
    uint16_t current_rating;  // 0.7A/0.45A (额定电流)
    float switching_voltage;  // 3.3V (控制电压)
    uint16_t response_time;   // <10ms (响应时间)
    char isolation_type[16];  // "光电隔离" (隔离方式)
} heater_control_spec_t;
```

**控制算法实现** (基于第16页控制电路)
```c
// 加热器PID控制算法 (参考第16页控制方案)
typedef struct {
    float kp, ki, kd;         // PID参数
    float setpoint;           // 目标温度
    float last_error;         // 上次误差
    float integral;           // 积分累积
    uint32_t last_time;       // 上次计算时间
    bool auto_tuning;         // 自整定模式
} heater_pid_t;

void heater_pid_control(heater_pid_t *pid, float current_temp) {
    uint32_t current_time = get_system_tick();
    float dt = (current_time - pid->last_time) / 1000.0f; // 转换为秒

    if (dt <= 0.0f) return;

    // PID计算
    float error = pid->setpoint - current_temp;
    pid->integral += error * dt;

    // 积分限幅防止饱和
    if (pid->integral > 100.0f) pid->integral = 100.0f;
    if (pid->integral < -100.0f) pid->integral = -100.0f;

    float derivative = (error - pid->last_error) / dt;

    float output = pid->kp * error + pid->ki * pid->integral + pid->kd * derivative;

    // 输出限制 (0-100%)
    if (output > 100.0f) output = 100.0f;
    if (output < 0.0f) output = 0.0f;

    // PWM输出控制 (通过固态继电器)
    set_heater_pwm_duty(output);

    pid->last_error = error;
    pid->last_time = current_time;
}
```

### 2.2.2 泵系统控制

**调速泵控制** (来源: 第11页MPB025BBB规格)
```c
// 调速泵控制配置 (基于第11页技术参数)
typedef struct {
    char model[16];           // "MPB025BBB"
    uint16_t voltage_rating;  // 24V (额定电压)
    uint16_t power_rating;    // 25W (额定功率)
    uint16_t speed_min;       // 200 RPM (最低转速)
    uint16_t speed_max;       // 5000 RPM (最高转速)
    float control_voltage_min; // 0.2V (控制电压下限)
    float control_voltage_max; // 5.0V (控制电压上限)
    uint16_t response_time;   // <500ms (响应时间)
} variable_pump_spec_t;

// 调速泵控制函数 (参考第16页调速控制)
void set_pump_speed(uint8_t pump_id, uint16_t target_rpm) {
    // 转速限制检查
    if (target_rpm < 200) target_rpm = 200;
    if (target_rpm > 5000) target_rpm = 5000;

    // 转速到控制电压的线性转换
    float control_voltage = 0.2f + (target_rpm - 200.0f) * (4.8f / 4800.0f);

    // 通过DAC输出控制电压 (0.2-5V)
    uint16_t dac_value = (uint16_t)(control_voltage * 4095.0f / 5.0f); // 12bit DAC

    // 输出到对应的DAC通道
    if (pump_id == 0) {
        set_dac_output(DAC_CHANNEL_1, dac_value);  // 墨桶泵
    } else if (pump_id == 1) {
        set_dac_output(DAC_CHANNEL_2, dac_value);  // 回墨泵
    }
}
```

---

# 第三章 LED指示灯管理系统

## 3.1 LED硬件配置 (基于第20页架构图分析)

根据第20页硬件架构图中的LED标识，系统配置了5路状态指示LED：

### 3.1.1 LED功能映射表 (参考架构图标识)

```c
// LED功能定义 (基于第20页架构图LED标识)
typedef enum {
    LED_POWER_INDICATOR = 0,     // 2PN1*2D*1 - 电源指示灯 (红色)
    LED_NETWORK_STATUS,          // 2PN1*2D*2 - 网络状态灯 (绿色)
    LED_SYSTEM_RUNNING,          // 2PN1*2D*3 - 系统运行灯 (黄色)
    LED_COMMUNICATION,           // 2PN1*2D*4 - 通信状态灯 (蓝色)
    LED_FAULT_ALARM,            // 2PN1*2D*5 - 故障报警灯 (白色)
    LED_MAX_COUNT
} led_function_t;

// LED控制结构体
typedef struct {
    uint8_t led_id;              // LED编号 (0-4)
    led_state_t state;           // 当前状态
    uint8_t brightness;          // 亮度 (0-100%)
    uint32_t blink_period;       // 闪烁周期 (ms)
    uint32_t last_toggle;        // 上次切换时间
    bool is_on;                  // 当前亮灭状态
    gpio_pin_t gpio_pin;         // 对应的GPIO管脚
} led_control_t;
```

### 3.1.2 LED状态指示规则

```c
// LED状态指示规则表 (基于系统状态映射)
static const led_rule_t led_rules[] = {
    // 电源指示灯 (红色) - 硬件直连24V电源
    {LED_POWER_INDICATOR, SYSTEM_POWER_ON,  LED_STATE_ON},
    {LED_POWER_INDICATOR, SYSTEM_POWER_OFF, LED_STATE_OFF},

    // 网络状态灯 (绿色) - 基于YT8512C PHY状态
    {LED_NETWORK_STATUS, NETWORK_CONNECTED,    LED_STATE_ON},
    {LED_NETWORK_STATUS, NETWORK_CONNECTING,   LED_STATE_BLINK_SLOW},   // 1Hz
    {LED_NETWORK_STATUS, NETWORK_DISCONNECTED, LED_STATE_OFF},
    {LED_NETWORK_STATUS, NETWORK_ERROR,        LED_STATE_BLINK_FAST},   // 2Hz

    // 系统运行灯 (黄色) - 基于主控MCU状态
    {LED_SYSTEM_RUNNING, SYSTEM_NORMAL,     LED_STATE_BLINK_SLOW},   // 正常心跳
    {LED_SYSTEM_RUNNING, SYSTEM_BUSY,       LED_STATE_BLINK_FAST},   // 高负载
    {LED_SYSTEM_RUNNING, SYSTEM_ERROR,      LED_STATE_OFF},          // 系统错误

    // 通信状态灯 (蓝色) - 基于EtherCAT/TCP通信
    {LED_COMMUNICATION, COMM_ETHERCAT_ACTIVE, LED_STATE_ON},
    {LED_COMMUNICATION, COMM_TCP_ACTIVE,      LED_STATE_BLINK_SLOW},
    {LED_COMMUNICATION, COMM_IDLE,            LED_STATE_OFF},
    {LED_COMMUNICATION, COMM_ERROR,           LED_STATE_BLINK_ULTRA}, // 5Hz

    // 故障报警灯 (白色) - 基于系统故障等级
    {LED_FAULT_ALARM, FAULT_NONE,          LED_STATE_OFF},
    {LED_FAULT_ALARM, FAULT_WARNING,       LED_STATE_BLINK_SLOW},
    {LED_FAULT_ALARM, FAULT_ERROR,         LED_STATE_BLINK_FAST},
    {LED_FAULT_ALARM, FAULT_CRITICAL,      LED_STATE_ON},           // 严重故障常亮
};
```

### 3.1.3 LED驱动电路实现

```c
// LED管理任务 (1ms周期执行)
void led_manager_task(void) {
    static led_control_t led_controls[LED_MAX_COUNT];
    uint32_t current_time = get_system_tick();

    for (int i = 0; i < LED_MAX_COUNT; i++) {
        led_control_t *led = &led_controls[i];

        switch (led->state) {
            case LED_STATE_OFF:
                gpio_write_pin(led->gpio_pin, GPIO_LOW);
                led->is_on = false;
                break;

            case LED_STATE_ON:
                gpio_write_pin(led->gpio_pin, GPIO_HIGH);
                led->is_on = true;
                break;

            case LED_STATE_BLINK_SLOW:  // 1Hz闪烁
                if (current_time - led->last_toggle >= 500) {
                    led->is_on = !led->is_on;
                    gpio_write_pin(led->gpio_pin, led->is_on ? GPIO_HIGH : GPIO_LOW);
                    led->last_toggle = current_time;
                }
                break;

            case LED_STATE_BLINK_FAST:  // 2Hz闪烁
                if (current_time - led->last_toggle >= 250) {
                    led->is_on = !led->is_on;
                    gpio_write_pin(led->gpio_pin, led->is_on ? GPIO_HIGH : GPIO_LOW);
                    led->last_toggle = current_time;
                }
                break;

            case LED_STATE_BLINK_ULTRA: // 5Hz快闪
                if (current_time - led->last_toggle >= 100) {
                    led->is_on = !led->is_on;
                    gpio_write_pin(led->gpio_pin, led->is_on ? GPIO_HIGH : GPIO_LOW);
                    led->last_toggle = current_time;
                }
                break;
        }
    }
}
```

---

# 第四章 人机界面(HMI)系统

## 4.1 LCD显示系统 (基于第18页CH12832B-12规格)

### 4.1.1 显示屏硬件配置

```c
// 显示屏配置 (基于第18页接口规格)
typedef struct {
    char model[16];           // "CH12832B-12"
    uint8_t resolution_x;     // 128 (像素宽度)
    uint8_t resolution_y;     // 32 (像素高度)
    uint8_t interface_type;   // SPI接口
    uint8_t supply_voltage;   // 3.3V (工作电压)
    uint16_t refresh_rate;    // 60Hz (刷新频率)
    bool backlight_control;   // true (背光控制)
} lcd_display_spec_t;
```

### 4.1.2 显示页面管理

```c
// 显示页面定义 (基于系统功能需求)
typedef enum {
    DISPLAY_PAGE_MAIN = 0,      // 主页面 - 系统状态总览
    DISPLAY_PAGE_SENSOR,        // 传感器数据页面
    DISPLAY_PAGE_ACTUATOR,      // 执行器状态页面
    DISPLAY_PAGE_NETWORK,       // 网络信息页面
    DISPLAY_PAGE_FAULT,         // 故障信息页面
    DISPLAY_PAGE_CONFIG,        // 配置参数页面
    DISPLAY_PAGE_IO_STATUS,     // IO状态页面 (基于第17页IO定义)
    DISPLAY_PAGE_MAX
} display_page_t;

// 主页面显示内容 (系统总览)
void display_main_page(display_content_t *content) {
    // 标题行 (8像素高度)
    snprintf(content->title, sizeof(content->title), "UV Ink Service V1.0");

    // 第一行 (8像素) - 温度和压力
    snprintf(content->line1, sizeof(content->line1), "T:%.1f°C P:%.1fkPa",
             get_temperature_sensor(0), get_pressure_sensor(0));

    // 第二行 (8像素) - 液位和流量
    snprintf(content->line2, sizeof(content->line2), "Level:%.1f%% Flow:%.1f",
             get_liquid_level_sensor(0), get_flow_rate());

    // 第三行 (8像素) - 系统状态
    snprintf(content->line3, sizeof(content->line3), "Sys:%s Net:%s",
             get_system_status_string(), get_network_status_string());
}

// 传感器数据页面 (详细数据)
void display_sensor_page(display_content_t *content) {
    snprintf(content->title, sizeof(content->title), "Sensor Data");

    // 温度传感器数据 (基于第15页PT100处理)
    snprintf(content->line1, sizeof(content->line1), "T1:%.1f T2:%.1f T3:%.1f",
             get_pt100_temperature(0), get_pt100_temperature(1), get_pt100_temperature(2));

    // 压力传感器数据 (基于第14页压力处理)
    snprintf(content->line2, sizeof(content->line2), "P1:%.2f P2:%.2f kPa",
             get_pressure_sensor(0), get_pressure_sensor(1));

    // 液位传感器数据 (基于第13页液位处理)
    snprintf(content->line3, sizeof(content->line3), "L1:%.1f%% L2:%.1f%%",
             get_liquid_level_sensor(0), get_liquid_level_sensor(1));
}
```

---

# 第五章 通信系统设计

## 5.1 EtherCAT工业总线 (基于第20页GDSCN832R2U6)

### 5.1.1 EtherCAT硬件配置

```c
// EtherCAT配置 (基于第18页接口规格 + 第20页架构)
typedef struct {
    char controller_model[16]; // "GDSCN832R2U6"
    uint8_t port_count;        // 2 (双端口)
    uint32_t baudrate;         // 100Mbps
    bool hardware_realtime;    // true (硬件实时)
    bool distributed_clock;    // true (分布式时钟)
    uint16_t sync_period;      // 1ms (同步周期)
    uint16_t process_data_size; // 64bytes (过程数据大小)
} ethercat_config_t;
```

### 5.1.2 EtherCAT数据交换

```c
// EtherCAT过程数据定义 (基于第17页IO地址映射)
typedef struct {
    // 数字输入 (8bytes) - 对应第17页I0.0-I0.7
    union {
        uint8_t digital_input_bytes[8];
        struct {
            bool ink_tank_level_1 : 1;      // I0.0 - 墨桶液位开关1
            bool ink_tank_level_2 : 1;      // I0.1 - 墨桶液位开关2
            bool waste_tank_level : 1;      // I0.2 - 废桶液位开关
            bool cartridge_level_1 : 1;     // I0.3 - 墨盒液位开关1
            bool cartridge_level_2 : 1;     // I0.4 - 墨盒液位开关2
            bool reserved_input_5 : 1;      // I0.5 - 预留
            bool reserved_input_6 : 1;      // I0.6 - 预留
            bool reserved_input_7 : 1;      // I0.7 - 预留
        } digital_inputs;
    };

    // 模拟输入 (12bytes) - 对应第17页IW1-IW6
    uint16_t analog_inputs[6];    // IW1-IW6: 压力、液位模拟量

    // 温度输入 (4bytes) - 对应第17页T10-T11
    uint16_t temperature_inputs[2]; // T10-T11: PT100温度

    // 数字输出 (8bytes) - 对应第17页Q0.0-Q0.7
    union {
        uint8_t digital_output_bytes[8];
        struct {
            bool ink_pump_start : 1;        // Q0.0 - 墨桶泵启动
            bool return_pump_start : 1;     // Q0.1 - 回墨泵启动
            bool recycle_valve_open : 1;    // Q0.2 - 回收电磁阀
            bool cartridge_heater : 1;      // Q0.3 - 墨盒加热
            bool line_heater : 1;           // Q0.4 - 明尼常加热
            bool water_supply_valve : 1;    // Q0.5 - 供水回收电磁阀
            bool waste_ink_valve : 1;       // Q0.6 - 废桶供墨电磁阀
            bool tank_ink_valve : 1;        // Q0.7 - 墨桶供墨电磁阀
        } digital_outputs;
    };

    // 模拟输出 (8bytes) - 对应第17页QW1-QW4
    uint16_t analog_outputs[4];   // QW1-QW4: 泵速调节输出

    // 系统状态 (4bytes)
    uint16_t system_status;       // 系统状态字
    uint16_t fault_code;          // 故障代码

} ethercat_process_data_t;
```

## 5.2 网络组网方案 (基于第21-23页组网设计)

### 5.2.1 单工位系统 (第21页设计)

```c
// 单工位TCP/IP直连方案
typedef struct {
    uint32_t controller_ip;       // 控制器IP地址
    uint32_t host_ip;            // 上位机IP地址
    uint16_t communication_port; // 通信端口 (默认502)
    uint16_t heartbeat_interval; // 心跳间隔 (ms)
    uint8_t connection_timeout;  // 连接超时 (s)
} single_station_network_t;
```

### 5.2.2 小型系统组网 (第22页设计)

```c
// 多控制板TCP/IP组网方案
typedef struct {
    uint8_t controller_count;    // 控制器数量 (2-8台)
    uint32_t controller_ips[8];  // 各控制器IP列表
    uint32_t gateway_ip;         // 网关IP地址
    uint8_t subnet_mask;         // 子网掩码 (/24)
    uint16_t sync_period;        // 同步周期 (100ms)
} small_system_network_t;
```

### 5.2.3 大型系统组网 (第23页设计)

```c
// EtherCAT+Modbus混合组网方案
typedef struct {
    // EtherCAT主站配置
    uint8_t ethercat_slave_count;  // EtherCAT从站数量
    uint16_t ethercat_cycle_time;  // EtherCAT循环时间 (1ms)

    // Modbus RTU配置
    uint8_t modbus_slave_id;       // Modbus从站ID
    uint32_t modbus_baudrate;      // Modbus波特率 (115200)

    // 系统总体配置
    uint8_t total_stations;        // 总工位数量 (16-64)
    uint16_t data_exchange_period; // 数据交换周期 (10ms)
} large_system_network_t;
```

---

# 第六章 系统监控与诊断

## 6.1 系统健康监控

### 6.1.1 性能监控指标

```c
// 系统性能监控 (基于GD32F427性能特性)
typedef struct {
    // CPU性能监控
    uint8_t cpu_usage_percent;      // CPU使用率 (%)
    uint32_t free_heap_memory;      // 剩余堆内存 (bytes)
    uint32_t stack_usage_max;       // 最大栈使用量 (bytes)
    uint32_t task_switch_count;     // 任务切换计数

    // 硬件监控
    float mcu_core_temperature;     // MCU核心温度 (°C)
    float supply_voltage_3v3;       // 3.3V电源电压
    float supply_voltage_5v;        // 5V电源电压
    float supply_voltage_24v;       // 24V电源电压

    // 通信性能监控
    uint32_t ethercat_frame_count;  // EtherCAT帧计数
    uint32_t tcp_packet_count;      // TCP数据包计数
    uint16_t network_latency_ms;    // 网络延迟 (ms)
    uint32_t communication_errors;  // 通信错误计数

    // 存储监控
    uint32_t flash_write_cycles;    // Flash写入次数
    uint32_t eeprom_write_count;    // EEPROM写入计数
    bool storage_wear_warning;      // 存储器磨损警告
} system_health_monitor_t;
```

### 6.1.2 故障检测与报警

```c
// 故障检测代码定义 (基于系统功能模块)
typedef enum {
    FAULT_NONE = 0x0000,

    // 传感器故障 (0x1000系列)
    FAULT_TEMP_SENSOR_1_OPEN    = 0x1001,  // 温度传感器1开路
    FAULT_TEMP_SENSOR_1_SHORT   = 0x1002,  // 温度传感器1短路
    FAULT_PRESSURE_SENSOR_1_FAULT = 0x1011, // 压力传感器1故障
    FAULT_PRESSURE_SENSOR_2_FAULT = 0x1012, // 压力传感器2故障
    FAULT_LIQUID_LEVEL_1_FAULT  = 0x1021,  // 液位传感器1故障
    FAULT_LIQUID_LEVEL_2_FAULT  = 0x1022,  // 液位传感器2故障

    // 执行器故障 (0x2000系列)
    FAULT_HEATER_1_OPEN         = 0x2001,  // 加热器1开路
    FAULT_HEATER_2_OPEN         = 0x2002,  // 加热器2开路
    FAULT_PUMP_1_OVERCURRENT    = 0x2011,  // 泵1过流
    FAULT_PUMP_2_OVERCURRENT    = 0x2012,  // 泵2过流
    FAULT_VALVE_1_FAULT         = 0x2021,  // 电磁阀1故障
    FAULT_VALVE_2_FAULT         = 0x2022,  // 电磁阀2故障

    // 系统故障 (0x3000系列)
    FAULT_POWER_VOLTAGE_LOW     = 0x3001,  // 电源电压低
    FAULT_POWER_VOLTAGE_HIGH    = 0x3002,  // 电源电压高
    FAULT_MCU_OVERTEMPERATURE   = 0x3003,  // MCU过温
    FAULT_MEMORY_ERROR          = 0x3004,  // 内存错误
    FAULT_WATCHDOG_RESET        = 0x3005,  // 看门狗复位

    // 通信故障 (0x4000系列)
    FAULT_ETHERCAT_DISCONNECTED = 0x4001,  // EtherCAT断开
    FAULT_ETHERNET_LINK_DOWN    = 0x4002,  // 以太网链路断开
    FAULT_COMMUNICATION_TIMEOUT = 0x4003,  // 通信超时
    FAULT_PROTOCOL_ERROR        = 0x4004,  // 协议错误

    FAULT_MAX_CODE              = 0xFFFF
} fault_code_t;
```

---

# 第七章 配置管理系统

## 7.1 系统配置参数

### 7.1.1 配置参数结构 (基于系统全功能需求)

```c
// 完整系统配置参数 (基于全系统功能需求)
typedef struct {
    // 配置文件头部信息
    uint32_t config_version;        // 配置版本号
    uint32_t config_size;           // 配置数据大小
    uint32_t config_crc32;          // CRC32校验值
    char device_serial[32];         // 设备序列号

    // 网络配置 (基于第21-23页组网方案)
    struct {
        uint32_t ip_address;        // IP地址
        uint32_t subnet_mask;       // 子网掩码
        uint32_t gateway_address;   // 网关地址
        uint16_t tcp_port;          // TCP通信端口
        uint8_t ethercat_slave_id;  // EtherCAT从站ID
        uint16_t heartbeat_interval; // 心跳间隔 (ms)
    } network_config;

    // 控制参数配置 (基于PID控制需求)
    struct {
        // 温度控制PID参数 (基于第15页温度处理)
        float temp_pid_kp[3];       // 温度PID比例系数 (3路)
        float temp_pid_ki[3];       // 温度PID积分系数
        float temp_pid_kd[3];       // 温度PID微分系数
        float temp_target[3];       // 目标温度 (°C)
        float temp_alarm_high[3];   // 温度上限报警 (°C)
        float temp_alarm_low[3];    // 温度下限报警 (°C)

        // 压力控制PID参数 (基于第14页压力处理)
        float pressure_pid_kp[2];   // 压力PID比例系数 (2路)
        float pressure_pid_ki[2];   // 压力PID积分系数
        float pressure_pid_kd[2];   // 压力PID微分系数
        float pressure_target[2];   // 目标压力 (kPa)
        float pressure_alarm_high[2]; // 压力上限报警
        float pressure_alarm_low[2];  // 压力下限报警

        // 液位控制参数 (基于第13页液位处理)
        float level_target[2];      // 目标液位 (%)
        float level_alarm_high[2];  // 液位上限报警 (%)
        float level_alarm_low[2];   // 液位下限报警 (%)
    } control_config;

    // 传感器校准参数 (基于各传感器规格)
    struct {
        // 温度传感器校准 (PT100)
        float temp_sensor_offset[3];    // 温度传感器偏移量 (°C)
        float temp_sensor_scale[3];     // 温度传感器缩放系数
        float temp_wire_resistance[3];  // 导线电阻补偿 (Ω)

        // 压力传感器校准 (4-20mA)
        float pressure_sensor_offset[2]; // 压力传感器偏移量 (kPa)
        float pressure_sensor_scale[2];  // 压力传感器缩放系数
        float pressure_zero_point[2];    // 压力零点校准 (mA)

        // 液位传感器校准 (4-20mA)
        float level_sensor_offset[2];   // 液位传感器偏移量 (%)
        float level_sensor_scale[2];    // 液位传感器缩放系数
        float level_zero_point[2];      // 液位零点校准 (mA)
    } calibration_config;

    // 系统运行参数
    struct {
        uint16_t adc_sample_period;     // ADC采样周期 (ms)
        uint16_t control_loop_period;   // 控制回路周期 (ms)
        uint16_t communication_period;  // 通信周期 (ms)
        uint8_t led_brightness;         // LED亮度 (0-100%)
        bool enable_display;            // 使能LCD显示
        bool enable_logging;            // 使能日志记录
        bool enable_auto_tuning;        // 使能PID自整定
        uint8_t system_language;        // 系统语言 (0=中文, 1=英文)
    } system_config;

    // 安全保护参数
    struct {
        uint16_t watchdog_timeout;      // 看门狗超时时间 (ms)
        float over_temp_threshold;      // 过温保护阈值 (°C)
        float over_pressure_threshold;  // 过压保护阈值 (kPa)
        float under_voltage_threshold;  // 欠压保护阈值 (V)
        bool enable_emergency_stop;     // 使能紧急停止
        uint16_t fault_recovery_delay;  // 故障恢复延时 (s)
    } safety_config;

} system_config_t;
```

### 7.1.2 配置存储管理

```c
// 配置存储管理函数 (基于Flash存储)
typedef struct {
    uint32_t flash_base_address;    // Flash基地址
    uint32_t flash_sector_size;     // Flash扇区大小 (4KB)
    uint32_t config_max_size;       // 配置最大大小
    uint8_t backup_copy_count;      // 备份副本数量
    bool write_protection;          // 写保护状态
} config_storage_t;

// 配置管理函数接口
bool config_load_from_flash(system_config_t *config);
bool config_save_to_flash(const system_config_t *config);
bool config_restore_factory_default(system_config_t *config);
bool config_validate_integrity(const system_config_t *config);
uint32_t config_calculate_crc32(const system_config_t *config);
bool config_backup_create(const system_config_t *config);
bool config_backup_restore(system_config_t *config, uint8_t backup_index);
```

---

# 第八章 实时任务调度系统

## 8.1 任务优先级设计 (基于实时性需求)

### 8.1.1 任务优先级分配

```c
// 任务优先级定义 (数值越小优先级越高) - 基于EtherCAT实时性优化
#define TASK_PRIORITY_EMERGENCY      (0)   // 紧急处理任务 - 最高优先级
#define TASK_PRIORITY_ETHERCAT       (1)   // EtherCAT通信 - 严格1ms实时要求 ⭐
#define TASK_PRIORITY_SAFETY         (2)   // 安全监控任务 - 安全相关
#define TASK_PRIORITY_WATCHDOG       (3)   // 看门狗任务 - 系统保护
#define TASK_PRIORITY_CONTROL        (4)   // 控制算法任务 - 实时控制
#define TASK_PRIORITY_ADC            (5)   // ADC采集任务 - 数据采集
#define TASK_PRIORITY_SENSOR         (6)   // 传感器处理 - 数据处理
#define TASK_PRIORITY_ACTUATOR       (7)   // 执行器控制 - 设备控制
#define TASK_PRIORITY_TCP_HIGH       (8)   // TCP高优先级通信
#define TASK_PRIORITY_LED            (9)   // LED管理 - 指示系统
#define TASK_PRIORITY_DISPLAY        (10)  // 显示任务 - 人机界面
#define TASK_PRIORITY_TCP_LOW        (11)  // TCP低优先级通信
#define TASK_PRIORITY_LOGGING        (12)  // 日志记录 - 后台任务
#define TASK_PRIORITY_CONFIG         (13)  // 配置管理 - 后台任务
#define TASK_PRIORITY_STATISTICS     (14)  // 性能统计 - 最低优先级

// 任务时间片分配 - 优化EtherCAT实时性
#define TASK_TIMESLICE_EMERGENCY     (1)    // 紧急任务 - 立即响应
#define TASK_TIMESLICE_ETHERCAT      (1)    // EtherCAT任务 - 1ms严格周期 ⭐
#define TASK_TIMESLICE_SAFETY        (10)   // 安全任务 - 10ms
#define TASK_TIMESLICE_CONTROL       (10)   // 控制任务 - 10ms实时控制
#define TASK_TIMESLICE_ADC           (5)    // ADC采集 - 5ms高频采样
#define TASK_TIMESLICE_COMMUNICATION (50)   // 通信任务 - 50ms通信周期
#define TASK_TIMESLICE_SENSOR        (100)  // 传感器 - 100ms处理周期
#define TASK_TIMESLICE_HMI           (200)  // 人机界面 - 200ms更新
#define TASK_TIMESLICE_BACKGROUND    (1000) // 后台任务 - 1s周期
```

### 8.1.2 任务调度器实现

```c
// 任务控制块定义
typedef struct {
    char task_name[16];             // 任务名称
    task_function_t task_function;  // 任务函数指针
    uint8_t priority;              // 任务优先级
    uint32_t period_ms;            // 任务周期 (ms)
    uint32_t last_run_time;        // 上次运行时间
    uint32_t max_exec_time;        // 最大执行时间
    uint32_t total_run_count;      // 总运行次数
    bool enabled;                  // 任务使能状态
    bool critical;                 // 关键任务标志
    uint32_t timeout_ms;           // 任务超时时间
} task_control_block_t;

// 系统任务列表 (基于EtherCAT实时性优化需求)
static task_control_block_t system_tasks[] = {
    //   任务名称        任务函数                      优先级                 周期  运行时间统计  使能  关键  超时
    {"Emergency",    emergency_handler_task,      TASK_PRIORITY_EMERGENCY,  1,    0, 0, 0, true,  true,  5},
    {"EtherCAT",     ethercat_communication_task, TASK_PRIORITY_ETHERCAT,   1,    0, 0, 0, true,  true,  3},  // ⭐ 1ms严格实时
    {"Safety",       safety_monitor_task,         TASK_PRIORITY_SAFETY,     10,   0, 0, 0, true,  true,  20},
    {"Watchdog",     watchdog_feed_task,          TASK_PRIORITY_WATCHDOG,   100,  0, 0, 0, true,  true,  200},
    {"Control",      pid_control_task,            TASK_PRIORITY_CONTROL,    10,   0, 0, 0, true,  true,  50},
    {"ADC",          adc_acquisition_task,        TASK_PRIORITY_ADC,        5,    0, 0, 0, true,  true,  20},
    {"Sensor",       sensor_processing_task,      TASK_PRIORITY_SENSOR,     100,  0, 0, 0, true,  false, 500},
    {"Actuator",     actuator_control_task,       TASK_PRIORITY_ACTUATOR,   50,   0, 0, 0, true,  false, 200},
    {"TCP-High",     tcp_communication_task,      TASK_PRIORITY_TCP_HIGH,   50,   0, 0, 0, true,  false, 1000},
    {"LED",          led_manager_task,            TASK_PRIORITY_LED,        100,  0, 0, 0, true,  false, 500},
    {"Display",      display_update_task,         TASK_PRIORITY_DISPLAY,    200,  0, 0, 0, true,  false, 1000},
    {"TCP-Low",      tcp_low_priority_task,       TASK_PRIORITY_TCP_LOW,    100,  0, 0, 0, true,  false, 2000},
    {"Logging",      log_manager_task,            TASK_PRIORITY_LOGGING,    1000, 0, 0, 0, true,  false, 5000},
    {"Config",       config_manager_task,         TASK_PRIORITY_CONFIG,     5000, 0, 0, 0, true,  false, 10000},
    {"Stats",        statistics_task,             TASK_PRIORITY_STATISTICS, 10000, 0, 0, 0, true,  false, 30000},
};
```

### 8.1.3 EtherCAT实时性优化设计

**优先级提升的技术考量**:

EtherCAT作为确定性实时工业以太网协议，对时序有极严格的要求：

1. **循环时间要求**: 标准EtherCAT系统要求1ms循环时间，最快可达125μs
2. **抖动控制**: 时序抖动必须控制在微秒级别
3. **硬件支持**: GDSCN832R2U6芯片提供硬件实时保证
4. **分布式时钟**: 需要精确的时钟同步，误差<1μs

**实时性保证措施**:

```c
// EtherCAT实时任务特殊处理
void ethercat_communication_task(void) {
    static uint32_t last_cycle_time = 0;
    static uint32_t max_jitter = 0;

    uint32_t current_time = get_high_precision_tick(); // 微秒精度

    // 1. 时序监控 (检测抖动)
    if (last_cycle_time > 0) {
        uint32_t cycle_time = current_time - last_cycle_time;
        uint32_t jitter = abs((int32_t)(cycle_time - 1000)); // 1000μs标准周期

        if (jitter > max_jitter) {
            max_jitter = jitter;
            if (jitter > 50) { // 抖动超过50μs记录警告
                LOG_WARN(MODULE_ETHERCAT, "Cycle jitter: %d us", jitter);
            }
        }
    }

    // 2. 禁用中断 (确保原子操作)
    uint32_t interrupt_state = disable_global_interrupts();

    // 3. EtherCAT数据交换 (硬件辅助)
    ethercat_process_data_exchange();

    // 4. 更新过程数据映射 (基于第17页IO定义)
    update_ethercat_input_data();   // 传感器数据 -> EtherCAT输入
    update_ethercat_output_data();  // EtherCAT输出 -> 执行器控制

    // 5. 恢复中断
    restore_global_interrupts(interrupt_state);

    // 6. 分布式时钟同步
    ethercat_sync_distributed_clock();

    last_cycle_time = current_time;
}

// EtherCAT任务调度特殊处理
static inline void schedule_ethercat_task(void) {
    // 使用硬件定时器触发，确保精确1ms周期
    timer_set_period(ETHERCAT_TIMER, 1000); // 1000μs = 1ms
    timer_enable_interrupt(ETHERCAT_TIMER);

    // 设置最高中断优先级 (0级)
    nvic_set_priority(ETHERCAT_TIMER_IRQn, 0);
}
```

**与控制任务的协调**:

```c
// 确保控制任务与EtherCAT同步
void pid_control_task(void) {
    // 等待EtherCAT数据更新完成
    while (ethercat_data_updating) {
        // 短暂等待，不超过100μs
        delay_microseconds(10);
    }

    // 执行控制算法 (使用最新的传感器数据)
    execute_pid_control_algorithms();
}
```

---

# 第九章 故障诊断与安全保护

## 9.1 多级安全保护系统

### 9.1.1 硬件级保护 (基于第10-11页执行器规格)

```c
// 硬件保护配置 (基于原始设计安全要求)
typedef struct {
    // 电源保护
    float voltage_24v_min;          // 24V电源最小值 (21.6V)
    float voltage_24v_max;          // 24V电源最大值 (26.4V)
    float voltage_3v3_min;          // 3.3V电源最小值 (3.0V)
    float voltage_3v3_max;          // 3.3V电源最大值 (3.6V)

    // 温度保护 (基于第9页传感器范围)
    float temp_protection_max;      // 最高保护温度 (650°C)
    float temp_warning_threshold;   // 温度警告阈值 (580°C)
    float mcu_temp_max;            // MCU最高温度 (85°C)

    // 电流保护 (基于第10-11页执行器电流)
    float heater_current_max;       // 加热器最大电流 (0.8A)
    float pump_current_max;         // 泵最大电流 (1.2A)
    float valve_current_max;        // 电磁阀最大电流 (0.4A)

    // 压力保护 (基于第9页压力传感器范围)
    float pressure_max_limit;       // 最高压力限制 (110MPa)
    float pressure_min_limit;       // 最低压力限制 (-110kPa)
    float pressure_alarm_high;      // 压力高报警 (95MPa)
    float pressure_alarm_low;       // 压力低报警 (-90kPa)
} hardware_protection_t;
```

### 9.1.2 软件级保护机制

```c
// 软件保护状态机
typedef enum {
    PROTECTION_STATE_NORMAL = 0,    // 正常运行状态
    PROTECTION_STATE_WARNING,       // 警告状态 - 继续运行但监控
    PROTECTION_STATE_ALARM,         // 报警状态 - 限制部分功能
    PROTECTION_STATE_FAULT,         // 故障状态 - 停止关键功能
    PROTECTION_STATE_EMERGENCY,     // 紧急状态 - 立即停机保护
    PROTECTION_STATE_MAINTENANCE    // 维护状态 - 手动控制模式
} protection_state_t;

// 安全保护任务 (高优先级,10ms周期)
void safety_protection_task(void) {
    static protection_state_t current_state = PROTECTION_STATE_NORMAL;
    static uint32_t fault_count = 0;
    static uint32_t last_check_time = 0;

    uint32_t current_time = get_system_tick();
    if (current_time - last_check_time < 10) return; // 10ms检查周期

    // 1. 检查系统关键参数
    bool critical_fault = false;
    bool warning_fault = false;

    // 温度检查 (基于PT100传感器)
    for (int i = 0; i < 3; i++) {
        float temp = get_pt100_temperature(i);
        if (temp > 650.0f) {
            critical_fault = true;
            trigger_fault(FAULT_TEMP_SENSOR_1_OVERHEAT + i);
        } else if (temp > 580.0f) {
            warning_fault = true;
            trigger_warning(WARNING_TEMP_HIGH_1 + i);
        }
    }

    // 压力检查 (基于4-20mA传感器)
    for (int i = 0; i < 2; i++) {
        float pressure = get_pressure_sensor(i);
        if (pressure > 110000.0f || pressure < -110.0f) {
            critical_fault = true;
            trigger_fault(FAULT_PRESSURE_SENSOR_1_FAULT + i);
        } else if (pressure > 95000.0f || pressure < -90.0f) {
            warning_fault = true;
            trigger_warning(WARNING_PRESSURE_HIGH_1 + i);
        }
    }

    // 电源监控
    float voltage_24v = get_supply_voltage_24v();
    if (voltage_24v < 21.6f || voltage_24v > 26.4f) {
        critical_fault = true;
        trigger_fault(FAULT_POWER_VOLTAGE_ABNORMAL);
    }

    // 通信监控
    if (is_ethercat_disconnected() || is_tcp_timeout()) {
        warning_fault = true;
        trigger_warning(WARNING_COMMUNICATION_FAULT);
    }

    // 2. 状态机处理
    switch (current_state) {
        case PROTECTION_STATE_NORMAL:
            if (critical_fault) {
                current_state = PROTECTION_STATE_EMERGENCY;
                execute_emergency_shutdown();
            } else if (warning_fault) {
                current_state = PROTECTION_STATE_WARNING;
                activate_warning_procedures();
            }
            break;

        case PROTECTION_STATE_WARNING:
            if (critical_fault) {
                current_state = PROTECTION_STATE_EMERGENCY;
                execute_emergency_shutdown();
            } else if (!warning_fault) {
                current_state = PROTECTION_STATE_NORMAL;
                deactivate_warning_procedures();
            }
            fault_count++;
            break;

        case PROTECTION_STATE_EMERGENCY:
            // 紧急状态下只有手动复位才能恢复
            if (is_manual_reset_requested() && !critical_fault) {
                current_state = PROTECTION_STATE_NORMAL;
                execute_system_recovery();
                fault_count = 0;
            }
            break;
    }

    // 3. 更新LED指示
    update_fault_led_status(current_state);

    last_check_time = current_time;
}
```

### 9.1.3 紧急处理机制

```c
// 紧急停机处理 (最高优先级任务)
void execute_emergency_shutdown(void) {
    // 立即关闭所有加热器 (AC220V继电器)
    set_heater_output(HEATER_CARTRIDGE_1, false);
    set_heater_output(HEATER_CARTRIDGE_2, false);
    set_heater_output(HEATER_LINE, false);

    // 停止所有泵运行
    set_pump_output(PUMP_INK_SUPPLY, false);
    set_pump_output(PUMP_INK_RETURN, false);
    set_variable_pump_speed(PUMP_VARIABLE_1, 0);
    set_variable_pump_speed(PUMP_VARIABLE_2, 0);

    // 关闭所有电磁阀
    set_valve_output(VALVE_INK_SUPPLY, false);
    set_valve_output(VALVE_INK_RETURN, false);
    set_valve_output(VALVE_WASTE_SUPPLY, false);
    set_valve_output(VALVE_WATER_SUPPLY, false);

    // 激活故障指示LED (白色LED常亮)
    led_set_state(LED_FAULT_ALARM, LED_STATE_ON);

    // 记录紧急停机事件
    log_emergency_event("Emergency shutdown executed", get_system_timestamp());

    // 发送故障通报
    send_fault_notification_to_host();
}
```

---

# 第十章 软件模块文件组织

## 10.1 按四层架构组织的目录结构

基于GD32F427平台的四层软件架构，目录结构严格按照架构层次组织：

```
ink_supply_control_firmware/
├── src/                                    # 源代码目录
│   ├── main.c                             # 主程序入口
│   │
│   ├── 01_bsp_layer/                      # 底层驱动 (BSP Layer) ⭐
│   │   ├── board_support/                 # 板级支持包
│   │   │   ├── system_init.c/h            # 系统初始化
│   │   │   ├── clock_config.c/h           # 时钟配置
│   │   │   ├── interrupt_handler.c/h      # 中断处理
│   │   │   └── memory_manager.c/h         # 内存管理
│   │   │
│   │   ├── gd32f427_drivers/              # GD32F427底层驱动
│   │   │   ├── gd32f427_hal/              # GD32 HAL库封装
│   │   │   ├── gpio_driver.c/h            # GPIO底层驱动
│   │   │   ├── adc_driver.c/h             # ADC底层驱动
│   │   │   ├── dac_driver.c/h             # DAC底层驱动
│   │   │   ├── pwm_driver.c/h             # PWM底层驱动
│   │   │   ├── uart_driver.c/h            # UART底层驱动
│   │   │   ├── spi_driver.c/h             # SPI底层驱动
│   │   │   ├── i2c_driver.c/h             # I2C底层驱动
│   │   │   ├── timer_driver.c/h           # 定时器底层驱动
│   │   │   └── dma_driver.c/h             # DMA底层驱动
│   │   │
│   │   └── external_chips/                # 外部芯片驱动
│   │       ├── yt8512c_phy.c/h            # 以太网PHY芯片 (YT8512C)
│   │       ├── gdscn832r2u6_ethercat.c/h  # EtherCAT芯片 (GDSCN832R2U6)
│   │       └── ch12832b_lcd.c/h           # LCD显示芯片 (CH12832B-12)
│   │
│   ├── 02_hal_layer/                      # 硬件抽象层 (HAL Layer) ⭐
│   │   ├── sensor_hal/                    # 传感器硬件抽象
│   │   │   ├── adc_interface.c/h          # ADC接口抽象
│   │   │   ├── sensor_interface.c/h       # 传感器通用接口
│   │   │   ├── liquid_level_hal.c/h       # 液位传感器HAL
│   │   │   ├── pressure_hal.c/h           # 压力传感器HAL
│   │   │   └── temperature_hal.c/h        # 温度传感器HAL
│   │   │
│   │   ├── actuator_hal/                  # 执行器硬件抽象
│   │   │   ├── pwm_interface.c/h          # PWM接口抽象
│   │   │   ├── relay_interface.c/h        # 继电器接口抽象
│   │   │   ├── heater_hal.c/h             # 加热器HAL
│   │   │   ├── pump_hal.c/h               # 泵HAL
│   │   │   └── valve_hal.c/h              # 电磁阀HAL
│   │   │
│   │   ├── communication_hal/             # 通信硬件抽象
│   │   │   ├── ethernet_interface.c/h     # 以太网接口抽象
│   │   │   ├── serial_interface.c/h       # 串口接口抽象
│   │   │   ├── ethercat_hal.c/h           # EtherCAT HAL
│   │   │   └── tcp_ip_hal.c/h             # TCP/IP HAL
│   │   │
│   │   ├── hmi_hal/                       # 人机界面硬件抽象
│   │   │   ├── led_interface.c/h          # LED接口抽象
│   │   │   ├── display_interface.c/h      # 显示接口抽象
│   │   │   └── key_interface.c/h          # 按键接口抽象 (如果有)
│   │   │
│   │   └── system_hal/                    # 系统硬件抽象
│   │       ├── power_monitor_hal.c/h      # 电源监控HAL
│   │       ├── watchdog_hal.c/h           # 看门狗HAL
│   │       └── flash_storage_hal.c/h      # Flash存储HAL
│   │
│   ├── 03_middleware_layer/               # 中间件层 (Middleware Layer) ⭐
│   │   ├── rtos/                          # 实时操作系统中间件
│   │   │   ├── task_scheduler.c/h         # 任务调度器
│   │   │   ├── task_manager.c/h           # 任务管理
│   │   │   ├── semaphore.c/h              # 信号量
│   │   │   ├── mutex.c/h                  # 互斥锁
│   │   │   ├── message_queue.c/h          # 消息队列
│   │   │   └── timer_service.c/h          # 定时服务
│   │   │
│   │   ├── communication_stack/           # 通信协议栈中间件
│   │   │   ├── ethercat_protocol.c/h      # EtherCAT协议栈
│   │   │   ├── tcp_ip_stack.c/h           # TCP/IP协议栈
│   │   │   ├── modbus_protocol.c/h        # Modbus协议栈
│   │   │   ├── custom_protocol.c/h        # 自定义协议
│   │   │   └── protocol_manager.c/h       # 协议管理器
│   │   │
│   │   ├── data_processing/               # 数据处理中间件
│   │   │   ├── digital_filter.c/h         # 数字滤波算法
│   │   │   ├── signal_processing.c/h      # 信号处理算法
│   │   │   ├── data_fusion.c/h            # 数据融合算法
│   │   │   ├── calibration_engine.c/h     # 校准引擎
│   │   │   └── data_converter.c/h         # 数据转换器
│   │   │
│   │   ├── control_algorithms/            # 控制算法中间件
│   │   │   ├── pid_controller.c/h         # PID控制器
│   │   │   ├── adaptive_pid.c/h           # 自适应PID
│   │   │   ├── fuzzy_control.c/h          # 模糊控制
│   │   │   ├── state_machine.c/h          # 状态机引擎
│   │   │   └── control_manager.c/h        # 控制管理器
│   │   │
│   │   ├── safety_middleware/             # 安全保护中间件
│   │   │   ├── safety_monitor.c/h         # 安全监控
│   │   │   ├── fault_detection.c/h        # 故障检测
│   │   │   ├── protection_logic.c/h       # 保护逻辑
│   │   │   ├── emergency_handler.c/h      # 紧急处理
│   │   │   └── watchdog_manager.c/h       # 看门狗管理
│   │   │
│   │   └── utils/                         # 工具中间件
│   │       ├── math_utils.c/h             # 数学工具
│   │       ├── string_utils.c/h           # 字符串工具
│   │       ├── crc_checksum.c/h           # CRC校验
│   │       ├── ring_buffer.c/h            # 环形缓冲区
│   │       └── memory_pool.c/h            # 内存池管理
│   │
│   └── 04_application_layer/              # 应用层 (Application Layer) ⭐
│       ├── control_applications/          # 控制应用
│       │   ├── ink_supply_control.c/h     # 供墨控制应用
│       │   ├── temperature_control.c/h    # 温度控制应用
│       │   ├── pressure_control.c/h       # 压力控制应用
│       │   ├── liquid_level_control.c/h   # 液位控制应用
│       │   └── flow_control.c/h           # 流量控制应用
│       │
│       ├── sensor_applications/           # 传感器应用
│       │   ├── sensor_manager.c/h         # 传感器管理器
│       │   ├── liquid_level_app.c/h       # 液位传感器应用 (FRD-8061)
│       │   ├── pressure_app.c/h           # 压力传感器应用 (HP10MY)
│       │   ├── temperature_app.c/h        # 温度传感器应用 (FTT518)
│       │   └── sensor_calibration_app.c/h # 传感器校准应用
│       │
│       ├── actuator_applications/         # 执行器应用
│       │   ├── actuator_manager.c/h       # 执行器管理器
│       │   ├── heater_app.c/h             # 加热器应用
│       │   ├── pump_app.c/h               # 泵应用
│       │   ├── valve_app.c/h              # 电磁阀应用
│       │   └── actuator_protection_app.c/h # 执行器保护应用
│       │
│       ├── communication_applications/    # 通信应用
│       │   ├── network_manager.c/h        # 网络管理器
│       │   ├── ethercat_app.c/h           # EtherCAT应用
│       │   ├── tcp_server_app.c/h         # TCP服务器应用
│       │   └── protocol_router.c/h        # 协议路由器
│       │
│       ├── hmi_applications/              # 人机界面应用
│       │   ├── hmi_manager.c/h            # HMI管理器
│       │   ├── led_indicator_app.c/h      # LED指示应用
│       │   ├── display_app.c/h            # 显示应用 (CH12832B-12)
│       │
│       ├── system_applications/           # 系统应用
│       │   ├── system_manager.c/h         # 系统管理器
│       │   ├── config_app.c/h             # 配置管理应用
│       │   ├── logging_app.c/h            # 日志记录应用
│       │   ├── diagnostics_app.c/h        # 系统诊断应用
│       │
│       └── main_application/              # 主应用
│           ├── application_main.c/h       # 应用主程序
│           ├── system_startup.c/h         # 系统启动
│           ├── task_initialization.c/h    # 任务初始化
│           └── application_config.c/h     # 应用配置
│
├── inc/                                   # 头文件目录 (按层次组织)
│   ├── 01_bsp_layer/                      # BSP层头文件
│   │   ├── board_config.h                 # 板级配置
│   │   ├── hardware_defines.h             # 硬件定义
│   │   └── chip_drivers.h                 # 芯片驱动头文件
│   │
│   ├── 02_hal_layer/                      # HAL层头文件
│   │   ├── hal_interfaces.h               # HAL接口定义
│   │   ├── sensor_types.h                 # 传感器类型定义
│   │   └── actuator_types.h               # 执行器类型定义
│   │
│   ├── 03_middleware_layer/               # 中间件层头文件
│   │   ├── rtos_config.h                  # RTOS配置
│   │   ├── protocol_defines.h             # 协议定义
│   │   └── algorithm_config.h             # 算法配置
│   │
│   ├── 04_application_layer/              # 应用层头文件
│   │   ├── application_config.h           # 应用配置
│   │   ├── system_defines.h               # 系统定义
│   │   └── user_interface_config.h        # 用户界面配置
│   │
│   ├── main.h                             # 主头文件
│   ├── system_config.h                    # 系统配置
│   ├── error_codes.h                      # 错误代码
│   └── version.h                          # 版本信息
│
├── lib/                                   # 第三方库
│   ├── GD32F4xx_HAL_Driver/               # GD32 HAL库
│   ├── CMSIS/                             # ARM CMSIS库
│   └── lwip/                              # 轻量级TCP/IP协议栈 
│   └── FreeRTOS/                          # FREERTOS 
│
├── docs/                                  # 设计文档 (参考文档)
├── test/                                  # 测试代码
├── tools/                                 # 开发工具
├── build/                                 # 构建输出目录
├── Makefile                               # 构建配置
├── CMakeLists.txt                         # CMake配置 
├── .gitignore                             # Git忽略文件
├── README.md                              # 项目说明
└── CHANGELOG.md                           # 变更日志
```

## 10.2 架构层次关系说明

### 10.2.1 四层架构调用关系

```c
// 层次调用关系示意 (只能向下调用，不能跨层调用)

┌─────────────────────────────────────────────────────────────────┐
│                    04_application_layer                         │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐  │  ↑
│  │控制应用模块  │  │传感器应用    │  │通信应用模块  │  │HMI应用  │  │  │
│  │             │  │模块         │  │             │  │模块     │  │  │
│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘  │  │
└─────────────────────┬───────────────────────────────────────────┘  │
                      │ 调用                                         │
┌─────────────────────▼───────────────────────────────────────────┐  │
│                    03_middleware_layer                          │  │ 业
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐  │  │ 务
│  │RTOS中间件   │  │通信协议栈    │  │控制算法引擎  │  │安全保护 │  │  │ 逻
│  │             │  │中间件       │  │中间件       │  │中间件   │  │  │ 辑
│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘  │  │
└─────────────────────┬───────────────────────────────────────────┘  │
                      │ 调用                                         │
┌─────────────────────▼───────────────────────────────────────────┐  │
│                    02_hal_layer                                 │  │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐  │  │ 硬
│  │传感器HAL    │  │执行器HAL     │  │通信HAL      │  │系统HAL  │  │  │ 件
│  │             │  │             │  │             │  │        │  │  │ 抽
│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘  │  │ 象
└─────────────────────┬───────────────────────────────────────────┘  │
                      │ 调用                                         │
┌─────────────────────▼───────────────────────────────────────────┐  │
│                    01_bsp_layer                                 │  │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐  │  │ 硬
│  │板级支持包    │  │GD32F427驱动 │  │外部芯片驱动  │  │中断处理 │  │  │ 件
│  │             │  │             │  │             │  │        │  │  │ 驱
│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘  │  │ 动
└─────────────────────────────────────────────────────────────────┘  ↓
```

### 10.2.2 层次职责划分

**第1层 - BSP层 (01_bsp_layer)**:
- **职责**: 硬件寄存器级操作、中断处理、时钟配置
- **特点**: 与具体硬件平台强相关，移植时需要修改
- **调用**: 只能调用HAL库和CMSIS标准接口
- **被调用**: 为HAL层提供底层硬件抽象

**第2层 - HAL层 (02_hal_layer)**:
- **职责**: 硬件功能抽象，隐藏硬件实现细节
- **特点**: 提供标准化的硬件接口，支持多种硬件平台
- **调用**: 只能调用BSP层接口
- **被调用**: 为中间件层提供设备无关的硬件接口

**第3层 - 中间件层 (03_middleware_layer)**:
- **职责**: 协议栈、算法引擎、RTOS服务、数据处理
- **特点**: 业务逻辑无关，可复用的功能组件
- **调用**: 只能调用HAL层接口
- **被调用**: 为应用层提供高级服务和算法

**第4层 - 应用层 (04_application_layer)**:
- **职责**: 业务逻辑实现、用户需求实现
- **特点**: 与具体应用场景相关
- **调用**: 只能调用中间件层接口
- **被调用**: 系统最顶层，不被其他层调用

### 10.2.3 层间接口规范

```c
// 层间接口调用规范示例

// ❌ 错误: 应用层直接调用BSP层 (跨层调用)
void temperature_control_app(void) {
    // 错误!!! 应用层直接操作ADC寄存器
    ADC0_RDATA = adc_read_channel(ADC_CHANNEL_1);
}

// ✅ 正确: 应用层通过中间件层调用
void temperature_control_app(void) {
    // 正确: 应用层 -> 中间件层
    float temperature = sensor_data_processor_get_temperature(TEMP_SENSOR_1);

    // 正确: 应用层 -> 中间件层 -> HAL层 -> BSP层
    pid_control_execute(PID_TEMPERATURE, temperature);
}

// ✅ 正确: 中间件层调用HAL层
float sensor_data_processor_get_temperature(uint8_t sensor_id) {
    // 正确: 中间件层 -> HAL层
    uint16_t raw_adc = temperature_hal_read_adc(sensor_id);

    // 中间件层处理数据
    float temperature = pt100_convert_resistance_to_temperature(raw_adc);
    return temperature;
}

// ✅ 正确: HAL层调用BSP层
uint16_t temperature_hal_read_adc(uint8_t sensor_id) {
    // 正确: HAL层 -> BSP层
    return adc_driver_read_channel(get_adc_channel_by_sensor_id(sensor_id));
}
```

### 10.2.4 编译依赖关系

```makefile
# Makefile中的编译顺序体现层次关系

# 1. 首先编译BSP层 (最底层，无依赖)
BSP_SOURCES = src/01_bsp_layer/**/*.c

# 2. 然后编译HAL层 (依赖BSP层)
HAL_SOURCES = src/02_hal_layer/**/*.c

# 3. 接着编译中间件层 (依赖HAL层)
MIDDLEWARE_SOURCES = src/03_middleware_layer/**/*.c

# 4. 最后编译应用层 (依赖中间件层)
APPLICATION_SOURCES = src/04_application_layer/**/*.c

# 编译顺序
$(BUILD_DIR)/01_bsp.o: $(BSP_SOURCES)
$(BUILD_DIR)/02_hal.o: $(HAL_SOURCES) $(BUILD_DIR)/01_bsp.o
$(BUILD_DIR)/03_middleware.o: $(MIDDLEWARE_SOURCES) $(BUILD_DIR)/02_hal.o
$(BUILD_DIR)/04_application.o: $(APPLICATION_SOURCES) $(BUILD_DIR)/03_middleware.o
```

这样的目录结构和组织方式清晰地体现了四层架构的层次关系，确保了：

🔹 **层次清晰**: 通过目录命名 (01/02/03/04) 明确层次顺序
🔹 **职责分明**: 每层专注于特定职责，降低耦合度
🔹 **易于维护**: 层次化管理便于代码维护和升级
🔹 **可移植性**: BSP层和HAL层分离，便于硬件平台移植
🔹 **可复用性**: 中间件层可在不同项目间复用

---

# 第十一章 关键算法优化

## 11.1 自适应PID控制算法

### 11.1.1 基于模糊逻辑的PID自整定

```c
// 自适应PID控制器 (基于模糊逻辑整定)
typedef struct {
    // 基础PID参数
    float kp, ki, kd;                    // 当前PID参数
    float kp_base, ki_base, kd_base;     // 基础PID参数

    // 自适应参数
    float error_threshold_small;         // 小误差阈值
    float error_threshold_large;         // 大误差阈值
    float error_rate_threshold;          // 误差变化率阈值
    float adaptation_rate;               // 自适应速率

    // 历史数据
    float error_history[10];             // 误差历史记录
    uint8_t history_index;               // 历史索引
    uint32_t stable_count;               // 稳定计数
    uint32_t last_update_time;           // 上次更新时间

    // 状态标志
    bool adaptive_mode_enabled;          // 自适应模式使能
    bool system_stable;                  // 系统稳定标志
    uint8_t control_mode;                // 控制模式 (0=手动, 1=自动, 2=自适应)

} adaptive_pid_controller_t;

// 自适应PID控制函数 (基于温度/压力控制需求)
float adaptive_pid_control(adaptive_pid_controller_t *pid, float setpoint, float process_value) {
    uint32_t current_time = get_system_tick();
    float dt = (current_time - pid->last_update_time) / 1000.0f; // 转换为秒

    if (dt <= 0.001f) return 0.0f; // 避免除零错误

    // 计算当前误差和误差变化率
    float error = setpoint - process_value;
    float abs_error = fabs(error);

    // 更新误差历史
    pid->error_history[pid->history_index] = error;
    pid->history_index = (pid->history_index + 1) % 10;

    // 计算误差变化率
    float error_rate = 0.0f;
    if (pid->history_index >= 2) {
        int prev_index = (pid->history_index + 8) % 10; // 前两个样本
        error_rate = (error - pid->error_history[prev_index]) / dt;
    }

    // 自适应参数调整 (基于模糊逻辑规则)
    if (pid->adaptive_mode_enabled) {
        // 规则1: 大误差时增加比例增益，减少积分增益
        if (abs_error > pid->error_threshold_large) {
            pid->kp = pid->kp_base * (1.0f + pid->adaptation_rate);
            pid->ki = pid->ki_base * (1.0f - pid->adaptation_rate * 0.5f);
            pid->kd = pid->kd_base * (1.0f + pid->adaptation_rate * 0.3f);
            pid->stable_count = 0;
        }
        // 规则2: 小误差时恢复标准参数
        else if (abs_error < pid->error_threshold_small) {
            pid->stable_count++;
            if (pid->stable_count > 50) { // 稳定50个周期后恢复
                pid->kp = pid->kp_base;
                pid->ki = pid->ki_base;
                pid->kd = pid->kd_base;
                pid->system_stable = true;
            }
        }
        // 规则3: 误差变化率大时增加微分增益
        else if (fabs(error_rate) > pid->error_rate_threshold) {
            pid->kd = pid->kd_base * (1.0f + pid->adaptation_rate * 0.5f);
        }
    }

    // 执行标准PID计算 (带积分分离)
    static float integral_sum = 0.0f;
    static float last_error = 0.0f;

    // 积分分离 (大误差时不积分)
    if (abs_error < pid->error_threshold_large) {
        integral_sum += error * dt;

        // 积分限幅防止积分饱和
        float integral_limit = 100.0f / pid->ki; // 根据输出限制计算积分限制
        if (integral_sum > integral_limit) integral_sum = integral_limit;
        if (integral_sum < -integral_limit) integral_sum = -integral_limit;
    }

    // 计算微分项 (带低通滤波)
    float derivative = (error - last_error) / dt;
    static float filtered_derivative = 0.0f;
    filtered_derivative = 0.8f * filtered_derivative + 0.2f * derivative; // 低通滤波

    // PID输出计算
    float pid_output = pid->kp * error + pid->ki * integral_sum + pid->kd * filtered_derivative;

    // 输出限制
    if (pid_output > 100.0f) pid_output = 100.0f;
    if (pid_output < -100.0f) pid_output = -100.0f;

    // 更新历史数据
    last_error = error;
    pid->last_update_time = current_time;

    return pid_output;
}
```

### 11.1.2 数字滤波算法优化

```c
// 多种数字滤波算法集成 (基于传感器噪声特性)
typedef struct {
    // 滑动平均滤波
    float moving_avg_buffer[16];         // 滑动平均缓冲区
    uint8_t moving_avg_index;            // 当前索引
    uint8_t moving_avg_size;             // 窗口大小

    // 卡尔曼滤波参数
    float kalman_q;                      // 过程噪声协方差
    float kalman_r;                      // 测量噪声协方差
    float kalman_x;                      // 状态估计
    float kalman_p;                      // 估计误差协方差
    float kalman_k;                      // 卡尔曼增益

    // 中值滤波
    float median_buffer[5];              // 中值滤波缓冲区
    uint8_t median_index;                // 中值滤波索引

    // 限幅滤波
    float limit_max;                     // 上限值
    float limit_min;                     // 下限值
    float last_valid_value;              // 上次有效值

} digital_filter_t;

// 综合滤波处理函数
float digital_filter_process(digital_filter_t *filter, float raw_value) {
    float filtered_value = raw_value;

    // 1. 限幅滤波 (去除明显异常值)
    if (filtered_value > filter->limit_max || filtered_value < filter->limit_min) {
        filtered_value = filter->last_valid_value; // 使用上次有效值
    }

    // 2. 中值滤波 (去除脉冲干扰)
    filter->median_buffer[filter->median_index] = filtered_value;
    filter->median_index = (filter->median_index + 1) % 5;

    // 计算中值 (5点中值)
    float temp_array[5];
    memcpy(temp_array, filter->median_buffer, sizeof(temp_array));

    // 简单排序求中值
    for (int i = 0; i < 4; i++) {
        for (int j = i + 1; j < 5; j++) {
            if (temp_array[i] > temp_array[j]) {
                float temp = temp_array[i];
                temp_array[i] = temp_array[j];
                temp_array[j] = temp;
            }
        }
    }
    filtered_value = temp_array[2]; // 中值

    // 3. 卡尔曼滤波 (最优估计)
    // 预测步骤
    float x_pred = filter->kalman_x;
    float p_pred = filter->kalman_p + filter->kalman_q;

    // 更新步骤
    filter->kalman_k = p_pred / (p_pred + filter->kalman_r);
    filter->kalman_x = x_pred + filter->kalman_k * (filtered_value - x_pred);
    filter->kalman_p = (1.0f - filter->kalman_k) * p_pred;

    filtered_value = filter->kalman_x;

    // 4. 滑动平均滤波 (平滑输出)
    filter->moving_avg_buffer[filter->moving_avg_index] = filtered_value;
    filter->moving_avg_index = (filter->moving_avg_index + 1) % filter->moving_avg_size;

    float sum = 0.0f;
    for (int i = 0; i < filter->moving_avg_size; i++) {
        sum += filter->moving_avg_buffer[i];
    }
    filtered_value = sum / filter->moving_avg_size;

    // 更新上次有效值
    filter->last_valid_value = filtered_value;

    return filtered_value;
}
```

---

# 总结

本综合技术设计文档整合了供墨系统控制板卡的完整技术方案，涵盖了从硬件架构到软件实现的全方面内容：

## 主要技术特点

1. **先进的硬件平台**: 基于GD32F427VGT6主控芯片，200MHz主频，支持复杂控制算法
2. **完整的通信能力**: 支持EtherCAT工业总线和标准以太网，满足不同组网需求
3. **精密的信号处理**: 15bit ADC采集，支持4-20mA和PT100信号处理
4. **完善的人机界面**: LED指示系统、LCD显示屏、完整的状态反馈
5. **可靠的安全保护**: 多级安全保护机制，故障检测与诊断系统
6. **灵活的配置管理**: 完整的参数配置和存储管理系统

## 技术创新点

1. **自适应PID控制**: 基于模糊逻辑的PID参数自整定算法
2. **多重数字滤波**: 综合多种滤波算法提高数据质量
3. **分层软件架构**: 四层架构设计，模块化程度高，易于维护
4. **实时任务调度**: 基于优先级的实时任务调度系统
5. **完整监控系统**: 系统健康监控、性能统计、故障诊断一体化

## 文档参考体系

本文档基于以下参考资料编写：
- **什方科技供墨系统控制板卡设计方案V1.1** (原始24页PNG设计图)
- **设计方案目录索引与导航文档** (技术索引系统)
- **硬件架构表格和解读文档** (硬件技术分析)
- **原有软件架构文档** (基础软件设计)
- **补充软件架构文档** (功能扩展设计)

本文档为什方科技InkCore电芯绝缘涂层打印机供墨系统的软件开发提供了完整的技术指导和实现方案。

---

**文档版本**: V1.0
**创建日期**: 2025-09-26
**创建者**: 什方科技软硬件研发部
**适用产品**: InkCore电芯绝缘涂层打印机供墨系统控制板卡
**技术平台**: GD32F427VGT6 + EtherCAT + TCP/IP
**文档类型**: 综合技术设计文档
**参考架构**: UV Ink Service V1.0 (第20页硬件功能架构图)