# ä¾›å¢¨ç³»ç»Ÿæ§åˆ¶æ¿å¡ç®€åŒ–å®ç°è®¾è®¡æ–‡æ¡£ (GD32F427å‹ç¼©ç‰ˆ6å‘¨) v4

## æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£åŸºäºã€Šä¾›å¢¨ç³»ç»Ÿæ§åˆ¶æ¿å¡ç®€åŒ–å®ç°è®¾è®¡æ–‡æ¡£v3ã€‹ï¼Œé’ˆå¯¹GD32F427VGT6èŠ¯ç‰‡ï¼Œ**ä¿æŒæ‰€æœ‰v1åŠŸèƒ½éœ€æ±‚ä¸å˜**ï¼Œé€šè¿‡**æœ€å¤§åŒ–ä½¿ç”¨ç°æˆåº“**å’Œ**ç®€åŒ–ä»£ç ç»„ç»‡**æ¥å®ç°6å‘¨å†…å®Œæˆçš„ç°å®ç›®æ ‡ã€‚é‡ç‚¹æ˜¯**åŠŸèƒ½å®Œæ•´+å®ç°ç®€åŒ–+6å‘¨å¯è¡Œ**ã€‚

## ğŸ“‹ å‹ç¼©ç­–ç•¥ - éœ€æ±‚ä¸å˜ï¼Œå®ç°æç®€

### ç®€åŒ–åŸåˆ™
âœ… **æœ€å¤§åŒ–å¤ç”¨ç°æˆåº“**: FreeRTOS + lwIP + EtherCATå¼€æºåº“ + GD32 HALåº“
âœ… **æ‰å¹³åŒ–ç›®å½•ç»“æ„**: å‡å°‘å±‚æ¬¡ï¼Œæ¯ä¸ªåŠŸèƒ½ä¸€ä¸ªæ–‡ä»¶
âœ… **åˆå¹¶ç›¸ä¼¼æ¨¡å—**: ä¼ æ„Ÿå™¨åˆå¹¶ã€æ‰§è¡Œå™¨åˆå¹¶ã€é€šä¿¡åˆå¹¶
âœ… **å»é™¤å†—ä½™è®¾è®¡**: ä¸­é—´ä»¶å±‚å¤§å¹…ç²¾ç®€ï¼Œç›´æ¥è°ƒç”¨HAL
âœ… **ä¿æŒæ‰€æœ‰åŠŸèƒ½**: FRD-8061ã€HP10MYã€FTT518ã€MRA-23D3ã€MPB025BBBã€EtherCATã€TCP/IPã€LCDã€LEDå…¨ä¿ç•™

---

# ç¬¬ä¸€ç«  æç®€ä»£ç ç›®å½•ç»“æ„ (6å‘¨å¯è¡Œ)

## 1.1 å‹ç¼©ç‰ˆé¡¹ç›®ç»“æ„

```
ink_supply_gd32f427_6weeks/
â”œâ”€â”€ ğŸ“ src/                                # æºä»£ç ç›®å½• (æç®€)
â”‚   â”œâ”€â”€ ğŸ“„ main.c                          # ä¸»ç¨‹åºå…¥å£
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“ app/                            # åº”ç”¨å±‚ (åŠŸèƒ½åˆå¹¶)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ sensors.c/h                 # 3ç§ä¼ æ„Ÿå™¨é›†æˆ (FRD8061+HP10MY+FTT518)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ actuators.c/h               # 3ç§æ‰§è¡Œå™¨é›†æˆ (MRA23D3+MPB025BBB+é˜€é—¨)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ control.c/h                 # PIDæ§åˆ¶ç®—æ³• (æ¸©åº¦+å‹åŠ›+æ¶²ä½)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ communication.c/h           # åŒåè®®é€šä¿¡ (EtherCAT+TCP/IP)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ display.c/h                 # æ˜¾ç¤ºç³»ç»Ÿ (LCD+5è·¯LED)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ safety.c/h                  # å®‰å…¨ä¿æŠ¤ (æ•…éšœæ£€æµ‹+ç´§æ€¥åœæœº)
â”‚   â”‚   â””â”€â”€ ğŸ“„ config.c/h                  # é…ç½®ç®¡ç† (Flashå­˜å‚¨+å‚æ•°)
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“ middleware/                     # ä¸­é—´ä»¶å±‚ (æœ€å°åŒ–)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ filter.c/h                  # æ•°å­—æ»¤æ³¢ (æ»‘åŠ¨å¹³å‡+å¡å°”æ›¼)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ pid.c/h                     # PIDç®—æ³• (ç®€åŒ–ç‰ˆ)
â”‚   â”‚   â””â”€â”€ ğŸ“„ tasks.c/h                   # FreeRTOSä»»åŠ¡ç®¡ç†
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“ hal/                            # ç¡¬ä»¶æŠ½è±¡å±‚ (åŸºäºGD32 HAL)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ adc_hal.c/h                 # ADCå¤„ç† (ä¼ æ„Ÿå™¨é‡‡é›†)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ pwm_hal.c/h                 # PWMå¤„ç† (æ‰§è¡Œå™¨æ§åˆ¶)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ gpio_hal.c/h                # GPIOå¤„ç† (æ•°å­—IO)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ uart_hal.c/h                # UARTå¤„ç† (è°ƒè¯•+é€šä¿¡)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ spi_hal.c/h                 # SPIå¤„ç† (LCDæ˜¾ç¤º)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ eth_hal.c/h                 # ä»¥å¤ªç½‘å¤„ç† (ç½‘ç»œé€šä¿¡)
â”‚   â”‚   â””â”€â”€ ğŸ“„ flash_hal.c/h               # Flashå¤„ç† (é…ç½®å­˜å‚¨)
â”‚   â”‚
â”‚   â””â”€â”€ ğŸ“ drivers/                        # è®¾å¤‡é©±åŠ¨å±‚ (ç°æˆåº“)
â”‚       â”œâ”€â”€ ğŸ“„ lcd_driver.c/h              # CH12832B LCDé©±åŠ¨
â”‚       â””â”€â”€ ğŸ“„ eth_driver.c/h              # ä»¥å¤ªç½‘PHYé©±åŠ¨
â”‚
â”œâ”€â”€ ğŸ“ lib/                                # ç¬¬ä¸‰æ–¹åº“ (ç°æˆåº“ç›´æ¥ä½¿ç”¨)
â”‚   â”œâ”€â”€ ğŸ“ GD32F4xx_HAL/                   # GD32å®˜æ–¹HALåº“
â”‚   â”œâ”€â”€ ğŸ“ FreeRTOS/                       # FreeRTOS v10.4.6
â”‚   â”œâ”€â”€ ğŸ“ lwip/                           # lwIP v2.1.3
â”‚   â””â”€â”€ ğŸ“ ethercat/                       # EtherCATå¼€æºåº“
â”‚
â”œâ”€â”€ ğŸ“ config/                             # é…ç½®æ–‡ä»¶
â”‚   â”œâ”€â”€ ğŸ“„ FreeRTOSConfig.h                # FreeRTOSé…ç½®
â”‚   â”œâ”€â”€ ğŸ“„ lwipopts.h                      # lwIPé…ç½®
â”‚   â”œâ”€â”€ ğŸ“„ gd32f4xx_hal_conf.h            # HALåº“é…ç½®
â”‚   â””â”€â”€ ğŸ“„ system_config.h                 # ç³»ç»Ÿå‚æ•°é…ç½®
â”‚
â”œâ”€â”€ ğŸ“„ Makefile                            # æ„å»ºè„šæœ¬
â”œâ”€â”€ ğŸ“„ README.md                           # é¡¹ç›®è¯´æ˜
â””â”€â”€ ğŸ“„ .gitignore                          # Gité…ç½®
```

## 1.2 ä¸»ç¨‹åºæ¡†æ¶ (æç®€ç‰ˆ)

```c
/**
 * @file    main.c
 * @brief   ä¾›å¢¨ç³»ç»Ÿä¸»ç¨‹åº - 6å‘¨ç®€åŒ–ç‰ˆ
 * @version V4.0 (å‹ç¼©ç‰ˆ)
 * @date    2025-09-27
 * @note    ä¿æŒv1æ‰€æœ‰åŠŸèƒ½ï¼Œæœ€å¤§åŒ–ä½¿ç”¨ç°æˆåº“
 */

#include "gd32f4xx.h"
#include "FreeRTOS.h"
#include "task.h"

// åº”ç”¨æ¨¡å— (æ¯ä¸ªåŠŸèƒ½ä¸€ä¸ªæ–‡ä»¶)
#include "sensors.h"      // 3ç§ä¼ æ„Ÿå™¨é›†æˆ
#include "actuators.h"    // 3ç§æ‰§è¡Œå™¨é›†æˆ
#include "control.h"      // PIDæ§åˆ¶ç®—æ³•
#include "communication.h"// åŒåè®®é€šä¿¡
#include "display.h"      // LCD+LEDæ˜¾ç¤º
#include "safety.h"       // å®‰å…¨ä¿æŠ¤
#include "config.h"       // é…ç½®ç®¡ç†

/**
 * @brief  ä¸»å‡½æ•° - æç®€å¯åŠ¨æµç¨‹
 */
int main(void)
{
    // 1. ç³»ç»Ÿæ—¶é’Ÿé…ç½® (200MHz)
    system_clock_config();

    // 2. HALåº“åˆå§‹åŒ–
    hal_init();

    // 3. ç¡¬ä»¶åˆå§‹åŒ–
    hardware_init();

    // 4. åº”ç”¨æ¨¡å—åˆå§‹åŒ– (ä¿æŒv1æ‰€æœ‰åŠŸèƒ½)
    sensors_init();         // FRD-8061 + HP10MY + FTT518
    actuators_init();       // MRA-23D3 + MPB025BBB + é˜€é—¨
    control_init();         // PIDæ§åˆ¶
    communication_init();   // EtherCAT + TCP/IP
    display_init();         // LCD + LED
    safety_init();          // å®‰å…¨ä¿æŠ¤
    config_init();          // é…ç½®ç®¡ç†

    // 5. åˆ›å»ºFreeRTOSä»»åŠ¡ (ç®€åŒ–ä»»åŠ¡ç»“æ„)
    xTaskCreate(sensor_task,    "Sensor",  512, NULL, 5, NULL);
    xTaskCreate(actuator_task,  "Actuator",512, NULL, 4, NULL);
    xTaskCreate(control_task,   "Control", 512, NULL, 6, NULL);
    xTaskCreate(comm_task,      "Comm",    1024,NULL, 3, NULL);
    xTaskCreate(display_task,   "Display", 512, NULL, 2, NULL);
    xTaskCreate(safety_task,    "Safety",  256, NULL, 7, NULL);

    // 6. å¯åŠ¨è°ƒåº¦å™¨
    vTaskStartScheduler();

    // ä¸åº”è¯¥åˆ°è¾¾è¿™é‡Œ
    while(1);
}

/**
 * @brief  ç¡¬ä»¶åˆå§‹åŒ– - ä½¿ç”¨GD32 HALåº“ç®€åŒ–
 */
static void hardware_init(void)
{
    // GPIOåˆå§‹åŒ– (LED + æ•°å­—IO)
    gpio_hal_init();

    // ADCåˆå§‹åŒ– (ä¼ æ„Ÿå™¨é‡‡é›†)
    adc_hal_init();

    // PWMåˆå§‹åŒ– (æ‰§è¡Œå™¨æ§åˆ¶)
    pwm_hal_init();

    // UARTåˆå§‹åŒ– (è°ƒè¯•è¾“å‡º)
    uart_hal_init();

    // SPIåˆå§‹åŒ– (LCDæ˜¾ç¤º)
    spi_hal_init();

    // ä»¥å¤ªç½‘åˆå§‹åŒ– (ç½‘ç»œé€šä¿¡)
    eth_hal_init();

    // Flashåˆå§‹åŒ– (é…ç½®å­˜å‚¨)
    flash_hal_init();
}
```

## 1.3 ä¼ æ„Ÿå™¨æ¨¡å— (3åˆ1é›†æˆ)

```c
/**
 * @file    sensors.c
 * @brief   ä¼ æ„Ÿå™¨é›†æˆæ¨¡å— - FRD8061+HP10MY+FTT518
 * @version V4.0 (å‹ç¼©ç‰ˆ)
 * @date    2025-09-27
 * @note    ä¿æŒv1æ‰€æœ‰ä¼ æ„Ÿå™¨åŠŸèƒ½ï¼Œä»£ç åˆå¹¶ç®€åŒ–
 */

#include "sensors.h"
#include "adc_hal.h"
#include "filter.h"
#include "FreeRTOS.h"
#include "task.h"

// ä¼ æ„Ÿå™¨æ•°æ®ç»“æ„ (ä¿æŒv1åŠŸèƒ½)
typedef struct {
    float liquid_level[2];    // FRD-8061æ¶²ä½ä¼ æ„Ÿå™¨ (mm)
    float pressure[2];        // HP10MYå‹åŠ›ä¼ æ„Ÿå™¨ (kPa)
    float temperature[3];     // FTT518æ¸©åº¦ä¼ æ„Ÿå™¨ (Â°C)
    uint32_t timestamp;       // æ—¶é—´æˆ³
    bool fault_status[7];     // æ•…éšœçŠ¶æ€
} sensor_data_t;

static sensor_data_t g_sensor_data;

/**
 * @brief  ä¼ æ„Ÿå™¨ç³»ç»Ÿåˆå§‹åŒ–
 */
void sensors_init(void)
{
    // åˆå§‹åŒ–ADCé€šé“
    adc_hal_config_channel(ADC_CH_LIQUID_LEVEL_1, ADC_15BIT);
    adc_hal_config_channel(ADC_CH_LIQUID_LEVEL_2, ADC_15BIT);
    adc_hal_config_channel(ADC_CH_PRESSURE_1, ADC_15BIT);
    adc_hal_config_channel(ADC_CH_PRESSURE_2, ADC_15BIT);
    adc_hal_config_channel(ADC_CH_TEMP_1_SIGNAL, ADC_15BIT);
    adc_hal_config_channel(ADC_CH_TEMP_1_REF, ADC_15BIT);
    adc_hal_config_channel(ADC_CH_TEMP_2_SIGNAL, ADC_15BIT);
    adc_hal_config_channel(ADC_CH_TEMP_2_REF, ADC_15BIT);
    adc_hal_config_channel(ADC_CH_TEMP_3_SIGNAL, ADC_15BIT);
    adc_hal_config_channel(ADC_CH_TEMP_3_REF, ADC_15BIT);

    // åˆå§‹åŒ–æ•°å­—æ»¤æ³¢å™¨
    filter_init();

    memset(&g_sensor_data, 0, sizeof(sensor_data_t));
}

/**
 * @brief  ä¼ æ„Ÿå™¨ä»»åŠ¡ - 10mså‘¨æœŸé‡‡é›†
 */
void sensor_task(void *pvParameters)
{
    TickType_t xLastWakeTime = xTaskGetTickCount();

    while(1)
    {
        // ä¸¥æ ¼10mså‘¨æœŸ
        vTaskDelayUntil(&xLastWakeTime, pdMS_TO_TICKS(10));

        // 1. æ¶²ä½ä¼ æ„Ÿå™¨å¤„ç† (ä¿æŒv1ç®—æ³•)
        for(int i = 0; i < 2; i++) {
            uint16_t adc_val = adc_hal_read_channel(ADC_CH_LIQUID_LEVEL_1 + i);
            float raw_level = convert_4_20ma_to_level(adc_val);

            if(raw_level >= 0) {
                g_sensor_data.liquid_level[i] = filter_process(FILTER_LIQUID_LEVEL_1 + i, raw_level);
                g_sensor_data.fault_status[i] = false;
            } else {
                g_sensor_data.fault_status[i] = true;
            }
        }

        // 2. å‹åŠ›ä¼ æ„Ÿå™¨å¤„ç† (ä¿æŒv1ç®—æ³•)
        for(int i = 0; i < 2; i++) {
            uint16_t adc_val = adc_hal_read_channel(ADC_CH_PRESSURE_1 + i);
            float raw_pressure = convert_4_20ma_to_pressure(adc_val);

            if(raw_pressure > -900.0f) {
                g_sensor_data.pressure[i] = filter_process(FILTER_PRESSURE_1 + i, raw_pressure);
                g_sensor_data.fault_status[2 + i] = false;
            } else {
                g_sensor_data.fault_status[2 + i] = true;
            }
        }

        // 3. æ¸©åº¦ä¼ æ„Ÿå™¨å¤„ç† (ä¿æŒv1ç®—æ³•)
        for(int i = 0; i < 3; i++) {
            uint16_t adc_signal = adc_hal_read_channel(ADC_CH_TEMP_1_SIGNAL + i*2);
            uint16_t adc_ref = adc_hal_read_channel(ADC_CH_TEMP_1_REF + i*2);
            float raw_temp = convert_pt100_to_temperature(adc_signal, adc_ref);

            if(raw_temp > -50.0f && raw_temp < 700.0f) {
                g_sensor_data.temperature[i] = filter_process(FILTER_TEMPERATURE_1 + i, raw_temp);
                g_sensor_data.fault_status[4 + i] = false;
            } else {
                g_sensor_data.fault_status[4 + i] = true;
            }
        }

        g_sensor_data.timestamp = xTaskGetTickCount();
    }
}

/**
 * @brief  4-20mAè½¬æ¶²ä½ (ä¿æŒv1ç®—æ³•)
 */
static float convert_4_20ma_to_level(uint16_t adc_value)
{
    // 15bit ADCè½¬æ¢ (ä¸v1æ–‡æ¡£ç¬¬84è¡Œä¸€è‡´)
    float voltage = (float)adc_value * 3.3f / 32768.0f;
    float current = voltage / 250.0f * 1000.0f;  // mA

    if(current < 4.0f || current > 20.0f) return -1.0f;

    float level = (current - 4.0f) * 2000.0f / 16.0f;  // mm
    return level;
}

/**
 * @brief  4-20mAè½¬å‹åŠ› (ä¿æŒv1ç®—æ³•)
 */
static float convert_4_20ma_to_pressure(uint16_t adc_value)
{
    // 15bit ADCè½¬æ¢ (ä¸v1æ–‡æ¡£ç¬¬97è¡Œä¸€è‡´)
    float voltage = (float)adc_value * 3.3f / 32768.0f;
    float current = voltage / 250.0f * 1000.0f;

    if(current < 3.5f || current > 20.5f) return -999.0f;

    // å‹åŠ›èŒƒå›´æ˜ å°„ (4mA=-100kPa, 20mA=100MPa)
    float pressure = -100.0f + (current - 4.0f) * (100100.0f / 16.0f);
    return pressure;
}

/**
 * @brief  PT100è½¬æ¸©åº¦ (ä¿æŒv1ç®—æ³•)
 */
static float convert_pt100_to_temperature(uint16_t adc_signal, uint16_t adc_ref)
{
    // PT100ä¸‰çº¿åˆ¶å¤„ç† (ä¸v1æ–‡æ¡£ç¬¬589è¡Œä¸€è‡´)
    const float excitation_current = 0.001f;  // 1mA
    const float reference_resistor = 1000.0f; // 1kÎ©

    float voltage_signal = (float)adc_signal * 3.3f / 32768.0f;
    float voltage_ref = (float)adc_ref * 3.3f / 32768.0f;

    float resistance_signal = voltage_signal / excitation_current;
    float wire_resistance = (reference_resistor - voltage_ref / excitation_current) / 2.0f;
    float pt100_resistance = resistance_signal - 2.0f * wire_resistance;

    // PT100ç”µé˜»-æ¸©åº¦è½¬æ¢
    float temperature = (pt100_resistance - 100.0f) / (100.0f * 0.003851f);
    return temperature;
}

// å…¬å…±æ¥å£å‡½æ•° (ä¿æŒv1æ¥å£å…¼å®¹)
float get_liquid_level(uint8_t sensor_id) {
    return (sensor_id < 2) ? g_sensor_data.liquid_level[sensor_id] : 0.0f;
}

float get_pressure(uint8_t sensor_id) {
    return (sensor_id < 2) ? g_sensor_data.pressure[sensor_id] : 0.0f;
}

float get_temperature(uint8_t sensor_id) {
    return (sensor_id < 3) ? g_sensor_data.temperature[sensor_id] : 0.0f;
}

bool get_sensor_fault(uint8_t sensor_id) {
    return (sensor_id < 7) ? g_sensor_data.fault_status[sensor_id] : true;
}
```

## 1.4 æ‰§è¡Œå™¨æ¨¡å— (3åˆ1é›†æˆ)

```c
/**
 * @file    actuators.c
 * @brief   æ‰§è¡Œå™¨é›†æˆæ¨¡å— - MRA23D3+MPB025BBB+é˜€é—¨
 * @version V4.0 (å‹ç¼©ç‰ˆ)
 * @date    2025-09-27
 * @note    ä¿æŒv1æ‰€æœ‰æ‰§è¡Œå™¨åŠŸèƒ½ï¼Œä»£ç åˆå¹¶ç®€åŒ–
 */

#include "actuators.h"
#include "pwm_hal.h"
#include "gpio_hal.h"
#include "FreeRTOS.h"
#include "task.h"

// æ‰§è¡Œå™¨çŠ¶æ€ç»“æ„ (ä¿æŒv1åŠŸèƒ½)
typedef struct {
    bool heater_status[3];      // MRA-23D3åŠ çƒ­å™¨çŠ¶æ€
    float heater_power[3];      // åŠ çƒ­å™¨åŠŸç‡ (0-100%)
    uint16_t pump_speed[2];     // MPB025BBBæ³µè½¬é€Ÿ (RPM)
    bool pump_status[2];        // æ³µè¿è¡ŒçŠ¶æ€
    bool valve_status[8];       // ç”µç£é˜€çŠ¶æ€
    uint32_t last_update;       // æœ€åæ›´æ–°æ—¶é—´
} actuator_status_t;

static actuator_status_t g_actuator_status;

/**
 * @brief  æ‰§è¡Œå™¨ç³»ç»Ÿåˆå§‹åŒ–
 */
void actuators_init(void)
{
    // åˆå§‹åŒ–PWMé€šé“ (æ³µè°ƒé€Ÿ)
    pwm_hal_config_channel(PWM_CH_PUMP_1, 1000);  // 1kHz PWM
    pwm_hal_config_channel(PWM_CH_PUMP_2, 1000);

    // åˆå§‹åŒ–GPIO (åŠ çƒ­å™¨+é˜€é—¨)
    gpio_hal_config_output(GPIO_HEATER_1);
    gpio_hal_config_output(GPIO_HEATER_2);
    gpio_hal_config_output(GPIO_HEATER_3);
    gpio_hal_config_output(GPIO_VALVE_1);
    gpio_hal_config_output(GPIO_VALVE_2);
    gpio_hal_config_output(GPIO_VALVE_3);
    gpio_hal_config_output(GPIO_VALVE_4);
    gpio_hal_config_output(GPIO_VALVE_5);
    gpio_hal_config_output(GPIO_VALVE_6);
    gpio_hal_config_output(GPIO_VALVE_7);
    gpio_hal_config_output(GPIO_VALVE_8);

    memset(&g_actuator_status, 0, sizeof(actuator_status_t));
}

/**
 * @brief  æ‰§è¡Œå™¨ä»»åŠ¡ - 50mså‘¨æœŸæ§åˆ¶
 */
void actuator_task(void *pvParameters)
{
    TickType_t xLastWakeTime = xTaskGetTickCount();

    while(1)
    {
        // 50mså‘¨æœŸæ‰§è¡Œ
        vTaskDelayUntil(&xLastWakeTime, pdMS_TO_TICKS(50));

        // æ›´æ–°æ‰€æœ‰æ‰§è¡Œå™¨è¾“å‡º
        update_actuator_outputs();

        g_actuator_status.last_update = xTaskGetTickCount();
    }
}

/**
 * @brief  æ›´æ–°æ‰§è¡Œå™¨è¾“å‡º
 */
static void update_actuator_outputs(void)
{
    // 1. æ›´æ–°åŠ çƒ­å™¨è¾“å‡º (MRA-23D3å›ºæ€ç»§ç”µå™¨)
    for(int i = 0; i < 3; i++) {
        if(g_actuator_status.heater_status[i] && g_actuator_status.heater_power[i] > 0.0f) {
            // ç®€åŒ–PWMæ§åˆ¶ (10kHzè½½é¢‘)
            uint16_t duty = (uint16_t)(g_actuator_status.heater_power[i] * 10.0f);
            pwm_hal_set_duty_cycle(PWM_CH_HEATER_1 + i, duty);
        } else {
            pwm_hal_set_duty_cycle(PWM_CH_HEATER_1 + i, 0);
        }
    }

    // 2. æ›´æ–°æ³µé€Ÿè¾“å‡º (MPB025BBBè°ƒé€Ÿæ³µ)
    for(int i = 0; i < 2; i++) {
        if(g_actuator_status.pump_status[i]) {
            // è½¬é€Ÿåˆ°æ§åˆ¶ç”µå‹è½¬æ¢ (ä¿æŒv1ç®—æ³•)
            uint16_t target_rpm = g_actuator_status.pump_speed[i];
            if(target_rpm < 200) target_rpm = 200;
            if(target_rpm > 5000) target_rpm = 5000;

            float control_voltage = 0.2f + (target_rpm - 200.0f) * (4.8f / 4800.0f);
            uint16_t pwm_duty = (uint16_t)(control_voltage * 1000.0f / 5.0f);

            pwm_hal_set_duty_cycle(PWM_CH_PUMP_1 + i, pwm_duty);
        } else {
            pwm_hal_set_duty_cycle(PWM_CH_PUMP_1 + i, 0);
        }
    }

    // 3. æ›´æ–°é˜€é—¨è¾“å‡º (æ•°å­—è¾“å‡º)
    for(int i = 0; i < 8; i++) {
        gpio_hal_write_pin(GPIO_VALVE_1 + i, g_actuator_status.valve_status[i]);
    }
}

// å…¬å…±æ¥å£å‡½æ•° (ä¿æŒv1æ¥å£å…¼å®¹)
void set_heater_power(uint8_t heater_id, float power_percent) {
    if(heater_id < 3) {
        g_actuator_status.heater_power[heater_id] = power_percent;
        g_actuator_status.heater_status[heater_id] = (power_percent > 0.0f);
    }
}

void set_pump_speed(uint8_t pump_id, uint16_t target_rpm) {
    if(pump_id < 2) {
        g_actuator_status.pump_speed[pump_id] = target_rpm;
        g_actuator_status.pump_status[pump_id] = (target_rpm > 0);
    }
}

void set_valve_state(uint8_t valve_id, bool open) {
    if(valve_id < 8) {
        g_actuator_status.valve_status[valve_id] = open;
    }
}

bool get_heater_status(uint8_t heater_id) {
    return (heater_id < 3) ? g_actuator_status.heater_status[heater_id] : false;
}

uint16_t get_pump_speed(uint8_t pump_id) {
    return (pump_id < 2) ? g_actuator_status.pump_speed[pump_id] : 0;
}

bool get_valve_state(uint8_t valve_id) {
    return (valve_id < 8) ? g_actuator_status.valve_status[valve_id] : false;
}
```

---

# ç¬¬äºŒç«  6å‘¨å‹ç¼©å¼€å‘è®¡åˆ’

## 2.1 æç®€6å‘¨æ—¶é—´è¡¨

### ç¬¬1å‘¨: åŸºç¡€å¹³å° + HALåº“
- **Day 1-2**: GD32F427å¼€å‘æ¿ + å¼€å‘ç¯å¢ƒæ­å»º
- **Day 3-4**: GD32 HALåº“ + FreeRTOSåŸºç¡€é›†æˆ
- **Day 5-7**: HALå±‚æ¥å£å°è£… (ADC+PWM+GPIO+UART+SPI+ETH+Flash)

### ç¬¬2å‘¨: ä¼ æ„Ÿå™¨+æ‰§è¡Œå™¨ (æ ¸å¿ƒåŠŸèƒ½)
- **Day 1-3**: sensors.cå®ç° (FRD8061+HP10MY+FTT518é›†æˆ)
- **Day 4-7**: actuators.cå®ç° (MRA23D3+MPB025BBB+é˜€é—¨é›†æˆ)

### ç¬¬3å‘¨: æ§åˆ¶ç®—æ³•+é€šä¿¡
- **Day 1-3**: control.cå®ç° (PIDæ§åˆ¶ç®—æ³•)
- **Day 4-7**: communication.cå®ç° (EtherCAT+TCP/IP)

### ç¬¬4å‘¨: æ˜¾ç¤º+å®‰å…¨
- **Day 1-3**: display.cå®ç° (LCD+LED)
- **Day 4-7**: safety.cå®ç° (æ•…éšœæ£€æµ‹+ç´§æ€¥åœæœº)

### ç¬¬5å‘¨: é…ç½®+ç³»ç»Ÿé›†æˆ
- **Day 1-2**: config.cå®ç° (Flashå­˜å‚¨+å‚æ•°ç®¡ç†)
- **Day 3-7**: å®Œæ•´ç³»ç»Ÿé›†æˆæµ‹è¯•

### ç¬¬6å‘¨: æµ‹è¯•+ä¼˜åŒ–
- **Day 1-3**: åŠŸèƒ½æµ‹è¯• (æ‰€æœ‰v1åŠŸèƒ½éªŒè¯)
- **Day 4-7**: æ€§èƒ½ä¼˜åŒ– + æ–‡æ¡£æ•´ç†

## 2.2 æˆåŠŸå…³é”®å› ç´ 

### ğŸ”§ **æŠ€æœ¯ç­–ç•¥**
1. **æœ€å¤§åŒ–ä½¿ç”¨ç°æˆåº“**: GD32 HAL + FreeRTOS + lwIP + EtherCATå¼€æºåº“
2. **åŠŸèƒ½åˆå¹¶å®ç°**: æ¯ç±»åŠŸèƒ½ä¸€ä¸ªæ–‡ä»¶ï¼Œå‡å°‘æ¨¡å—é—´è°ƒç”¨
3. **æ¥å£ä¿æŒç®€å•**: ç›´æ¥å‡½æ•°è°ƒç”¨ï¼Œå»é™¤å¤æ‚çš„æŠ½è±¡å±‚
4. **æµ‹è¯•é©±åŠ¨å¼€å‘**: æ¯å‘¨æœ«éªŒè¯åŠŸèƒ½ï¼ŒåŠæ—¶å‘ç°é—®é¢˜

### ğŸ“Š **é£é™©æ§åˆ¶**
1. **EtherCATé£é™©**: å¦‚æœ‰é—®é¢˜ï¼Œä¼˜å…ˆä¿è¯TCP/IPåŠŸèƒ½
2. **ç²¾åº¦é£é™©**: ä¼ æ„Ÿå™¨ç²¾åº¦è¦æ±‚é€‚å½“æ”¾å®½ï¼Œä¼˜å…ˆä¿è¯åŠŸèƒ½
3. **è¿›åº¦é£é™©**: æ¯å‘¨è®¾å®šæœ€å°å¯éªŒè¯åŠŸèƒ½ï¼Œåˆ†é˜¶æ®µäº¤ä»˜

è¿™ä¸ªå‹ç¼©ç‰ˆè®¾è®¡åœ¨ä¿æŒv1æ‰€æœ‰åŠŸèƒ½çš„å‰æä¸‹ï¼Œé€šè¿‡æç®€çš„ä»£ç ç»„ç»‡å’Œæœ€å¤§åŒ–ä½¿ç”¨ç°æˆåº“ï¼Œå°†å¼€å‘å‘¨æœŸå‹ç¼©åˆ°ç°å®å¯è¡Œçš„6å‘¨ï¼Œæ˜¯ä¸€ä¸ªå¹³è¡¡åŠŸèƒ½å®Œæ•´æ€§å’Œå¼€å‘æ•ˆç‡çš„æœ€ä¼˜æ–¹æ¡ˆã€‚

### 1.3.1 ä¸»ç¨‹åºå…¥å£ (main.c)

```c
/**
 * @file    main.c
 * @brief   ä¾›å¢¨ç³»ç»Ÿæ§åˆ¶æ¿å¡ä¸»ç¨‹åºå…¥å£
 * @version V4.0
 * @date    2025-09-27
 * @note    åŸºäºGD32F427VGT6ï¼Œä¿æŒv3ç‰ˆæœ¬æ‰€æœ‰åŠŸèƒ½
 */

#include "system_config.h"
#include "board_init.h"
#include "task_scheduler.h"
#include "system_manager.h"
#include "error_handler.h"

// FreeRTOSå¤´æ–‡ä»¶
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "semphr.h"

// åº”ç”¨æ¨¡å—å¤´æ–‡ä»¶
#include "sensor_task.h"
#include "actuator_task.h"
#include "control_task.h"
#include "comm_task.h"
#include "hmi_task.h"
#include "safety_task.h"
#include "config_task.h"

/**
 * @brief  ä¸»å‡½æ•°
 * @param  None
 * @retval int ç¨‹åºé€€å‡ºçŠ¶æ€
 */
int main(void)
{
    // 1. ç³»ç»ŸåŸºç¡€åˆå§‹åŒ–
    system_early_init();

    // 2. æ¿çº§ç¡¬ä»¶åˆå§‹åŒ–
    if (board_init() != BOARD_INIT_SUCCESS) {
        error_handler(ERROR_BOARD_INIT_FAILED);
    }

    // 3. ç³»ç»Ÿç®¡ç†å™¨åˆå§‹åŒ–
    if (system_manager_init() != SYSTEM_INIT_SUCCESS) {
        error_handler(ERROR_SYSTEM_INIT_FAILED);
    }

    // 4. åº”ç”¨æ¨¡å—åˆå§‹åŒ–
    init_application_modules();

    // 5. åˆ›å»ºFreeRTOSä»»åŠ¡ (åŸºäºv3è®¾è®¡)
    create_system_tasks();

    // 6. å¯åŠ¨ä»»åŠ¡è°ƒåº¦å™¨
    vTaskStartScheduler();

    // æ­£å¸¸æƒ…å†µä¸‹ä¸ä¼šæ‰§è¡Œåˆ°è¿™é‡Œ
    error_handler(ERROR_SCHEDULER_FAILED);

    return 0;
}

/**
 * @brief  ç³»ç»Ÿæ—©æœŸåˆå§‹åŒ–
 * @param  None
 * @retval None
 */
static void system_early_init(void)
{
    // GD32F427ç³»ç»Ÿæ—¶é’Ÿé…ç½®ä¸º200MHz
    system_clock_config();

    // ä¸­æ–­ä¼˜å…ˆçº§åˆ†ç»„é…ç½®
    nvic_priority_group_set(NVIC_PRIGROUP_PRE4_SUB0);

    // ç³»ç»Ÿæ»´ç­”å®šæ—¶å™¨é…ç½® (1ms)
    systick_config();

    // çœ‹é—¨ç‹—åˆå§‹åŒ– (æ—©æœŸä¿æŠ¤)
    watchdog_early_init();
}

/**
 * @brief  åº”ç”¨æ¨¡å—åˆå§‹åŒ–
 * @param  None
 * @retval None
 */
static void init_application_modules(void)
{
    // ä¼ æ„Ÿå™¨ç³»ç»Ÿåˆå§‹åŒ– (ä¿æŒv3æ‰€æœ‰ä¼ æ„Ÿå™¨)
    sensor_manager_init();

    // æ‰§è¡Œå™¨ç³»ç»Ÿåˆå§‹åŒ– (ä¿æŒv3æ‰€æœ‰æ‰§è¡Œå™¨)
    actuator_manager_init();

    // é€šä¿¡ç³»ç»Ÿåˆå§‹åŒ– (ä¿æŒv3åŒåè®®)
    comm_manager_init();

    // HMIç³»ç»Ÿåˆå§‹åŒ– (ä¿æŒv3æ˜¾ç¤ºåŠŸèƒ½)
    hmi_manager_init();

    // å®‰å…¨ç³»ç»Ÿåˆå§‹åŒ– (ä¿æŒv3å®‰å…¨åŠŸèƒ½)
    safety_manager_init();

    // é…ç½®ç®¡ç†åˆå§‹åŒ– (ä¿æŒv3é…ç½®åŠŸèƒ½)
    config_manager_init();
}

/**
 * @brief  åˆ›å»ºç³»ç»Ÿä»»åŠ¡ (åŸºäºv3è®¾è®¡ï¼Œä¼˜åŒ–ä¼˜å…ˆçº§)
 * @param  None
 * @retval None
 */
static void create_system_tasks(void)
{
    BaseType_t result;

    // ä»»åŠ¡å¥æŸ„å®šä¹‰
    TaskHandle_t sensor_task_handle;
    TaskHandle_t actuator_task_handle;
    TaskHandle_t control_task_handle;
    TaskHandle_t comm_task_handle;
    TaskHandle_t hmi_task_handle;
    TaskHandle_t safety_task_handle;
    TaskHandle_t config_task_handle;

    // 1. ä¼ æ„Ÿå™¨ä»»åŠ¡ (é«˜ä¼˜å…ˆçº§) - ä¿æŒv3è®¾è®¡
    result = xTaskCreate(
        sensor_task,                    // ä»»åŠ¡å‡½æ•°
        "SensorTask",                   // ä»»åŠ¡åç§°
        SENSOR_TASK_STACK_SIZE,         // æ ˆå¤§å° 512words
        NULL,                           // å‚æ•°
        SENSOR_TASK_PRIORITY,           // ä¼˜å…ˆçº§ 5
        &sensor_task_handle             // ä»»åŠ¡å¥æŸ„
    );
    if (result != pdPASS) {
        error_handler(ERROR_TASK_CREATE_FAILED);
    }

    // 2. æ‰§è¡Œå™¨ä»»åŠ¡ (é«˜ä¼˜å…ˆçº§) - ä¿æŒv3è®¾è®¡
    result = xTaskCreate(
        actuator_task,
        "ActuatorTask",
        ACTUATOR_TASK_STACK_SIZE,       // 512words
        NULL,
        ACTUATOR_TASK_PRIORITY,         // ä¼˜å…ˆçº§ 4
        &actuator_task_handle
    );
    if (result != pdPASS) {
        error_handler(ERROR_TASK_CREATE_FAILED);
    }

    // 3. æ§åˆ¶ä»»åŠ¡ (é«˜ä¼˜å…ˆçº§) - ä¿æŒv3 PIDæ§åˆ¶
    result = xTaskCreate(
        control_task,
        "ControlTask",
        CONTROL_TASK_STACK_SIZE,        // 1024words
        NULL,
        CONTROL_TASK_PRIORITY,          // ä¼˜å…ˆçº§ 6
        &control_task_handle
    );
    if (result != pdPASS) {
        error_handler(ERROR_TASK_CREATE_FAILED);
    }

    // 4. é€šä¿¡ä»»åŠ¡ (ä¸­ç­‰ä¼˜å…ˆçº§) - ä¿æŒv3åŒåè®®
    result = xTaskCreate(
        comm_task,
        "CommTask",
        COMM_TASK_STACK_SIZE,           // 2048words (ç½‘ç»œæ ˆéœ€è¦æ›´å¤§ç©ºé—´)
        NULL,
        COMM_TASK_PRIORITY,             // ä¼˜å…ˆçº§ 3
        &comm_task_handle
    );
    if (result != pdPASS) {
        error_handler(ERROR_TASK_CREATE_FAILED);
    }

    // 5. HMIä»»åŠ¡ (ä¸­ç­‰ä¼˜å…ˆçº§) - ä¿æŒv3æ˜¾ç¤ºåŠŸèƒ½
    result = xTaskCreate(
        hmi_task,
        "HMITask",
        HMI_TASK_STACK_SIZE,            // 1024words
        NULL,
        HMI_TASK_PRIORITY,              // ä¼˜å…ˆçº§ 2
        &hmi_task_handle
    );
    if (result != pdPASS) {
        error_handler(ERROR_TASK_CREATE_FAILED);
    }

    // 6. å®‰å…¨ä»»åŠ¡ (æœ€é«˜ä¼˜å…ˆçº§) - ä¿æŒv3å®‰å…¨åŠŸèƒ½
    result = xTaskCreate(
        safety_task,
        "SafetyTask",
        SAFETY_TASK_STACK_SIZE,         // 512words
        NULL,
        SAFETY_TASK_PRIORITY,           // ä¼˜å…ˆçº§ 7 (æœ€é«˜)
        &safety_task_handle
    );
    if (result != pdPASS) {
        error_handler(ERROR_TASK_CREATE_FAILED);
    }

    // 7. é…ç½®ä»»åŠ¡ (ä½ä¼˜å…ˆçº§) - ä¿æŒv3é…ç½®åŠŸèƒ½
    result = xTaskCreate(
        config_task,
        "ConfigTask",
        CONFIG_TASK_STACK_SIZE,         // 1024words
        NULL,
        CONFIG_TASK_PRIORITY,           // ä¼˜å…ˆçº§ 1 (ä½)
        &config_task_handle
    );
    if (result != pdPASS) {
        error_handler(ERROR_TASK_CREATE_FAILED);
    }
}
```

### 1.3.2 ä¼ æ„Ÿå™¨æ¨¡å—å®ç° (ä¿æŒv3å…¨åŠŸèƒ½)

```c
/**
 * @file    sensor_task.c
 * @brief   ä¼ æ„Ÿå™¨ä»»åŠ¡å®ç° - ä¿æŒv3ç‰ˆæœ¬æ‰€æœ‰ä¼ æ„Ÿå™¨åŠŸèƒ½
 * @version V4.0
 * @date    2025-09-27
 */

#include "sensor_task.h"
#include "frd8061_liquid_level.h"
#include "hp10my_pressure.h"
#include "ftt518_temperature.h"
#include "sensor_filter.h"
#include "sensor_calibration.h"
#include "system_config.h"

// FreeRTOSå¤´æ–‡ä»¶
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "semphr.h"

// ä¼ æ„Ÿå™¨æ•°æ®ç»“æ„ (åŸºäºv3è®¾è®¡)
typedef struct {
    // FRD-8061æ¶²ä½ä¼ æ„Ÿå™¨æ•°æ® (ä¿æŒv3é…ç½®)
    struct {
        float raw_value;        // åŸå§‹å€¼ (mm)
        float filtered_value;   // æ»¤æ³¢å€¼ (mm)
        float calibrated_value; // æ ¡å‡†å€¼ (mm)
        uint32_t timestamp;     // æ—¶é—´æˆ³
        bool fault_status;      // æ•…éšœçŠ¶æ€
        uint16_t fault_code;    // æ•…éšœä»£ç 
    } liquid_level[2];          // 2è·¯æ¶²ä½ä¼ æ„Ÿå™¨

    // HP10MYå‹åŠ›ä¼ æ„Ÿå™¨æ•°æ® (ä¿æŒv3é…ç½®)
    struct {
        float raw_value;        // åŸå§‹å€¼ (kPa)
        float filtered_value;   // æ»¤æ³¢å€¼ (kPa)
        float calibrated_value; // æ ¡å‡†å€¼ (kPa)
        uint32_t timestamp;     // æ—¶é—´æˆ³
        bool fault_status;      // æ•…éšœçŠ¶æ€
        uint16_t fault_code;    // æ•…éšœä»£ç 
    } pressure[2];              // 2è·¯å‹åŠ›ä¼ æ„Ÿå™¨

    // FTT518æ¸©åº¦ä¼ æ„Ÿå™¨æ•°æ® (ä¿æŒv3é…ç½®)
    struct {
        float raw_value;        // åŸå§‹å€¼ (Â°C)
        float filtered_value;   // æ»¤æ³¢å€¼ (Â°C)
        float calibrated_value; // æ ¡å‡†å€¼ (Â°C)
        float resistance;       // PT100ç”µé˜»å€¼ (Î©)
        uint32_t timestamp;     // æ—¶é—´æˆ³
        bool fault_status;      // æ•…éšœçŠ¶æ€
        uint16_t fault_code;    // æ•…éšœä»£ç 
    } temperature[3];           // 3è·¯æ¸©åº¦ä¼ æ„Ÿå™¨

} sensor_data_t;

// å…¨å±€ä¼ æ„Ÿå™¨æ•°æ® (ä¸v3æ¥å£å…¼å®¹)
sensor_data_t g_sensor_data;

/**
 * @brief  ä¼ æ„Ÿå™¨ä»»åŠ¡ä¸»å‡½æ•° (ä¿æŒv3è®¾è®¡æ¨¡å¼)
 * @param  pvParameters ä»»åŠ¡å‚æ•°
 * @retval None
 */
void sensor_task(void *pvParameters)
{
    TickType_t xLastWakeTime;
    uint32_t task_counter = 0;

    // ä»»åŠ¡åˆå§‹åŒ–
    sensor_task_init();

    // åˆå§‹åŒ–æ—¶é—´åŸºå‡†
    xLastWakeTime = xTaskGetTickCount();

    while (1) {
        // ä¸¥æ ¼10mså‘¨æœŸæ‰§è¡Œ
        vTaskDelayUntil(&xLastWakeTime, pdMS_TO_TICKS(10));

        task_counter++;

        // 1. æ¶²ä½ä¼ æ„Ÿå™¨å¤„ç† (ä¿æŒv3ç®—æ³•)
        for (int i = 0; i < 2; i++) {
            // è¯»å–åŸå§‹æ•°æ® (ä¿æŒv3æ¥å£)
            float raw_level = read_liquid_level_frd8061(i);
            g_sensor_data.liquid_level[i].raw_value = raw_level;

            // æ•…éšœæ£€æµ‹
            if (raw_level < 0) {
                g_sensor_data.liquid_level[i].fault_status = true;
                g_sensor_data.liquid_level[i].fault_code = FAULT_LIQUID_LEVEL_1_FAULT + i;
            } else {
                g_sensor_data.liquid_level[i].fault_status = false;
                g_sensor_data.liquid_level[i].fault_code = 0;

                // æ•°å­—æ»¤æ³¢å¤„ç†
                float filtered_level = sensor_filter_process(FILTER_LIQUID_LEVEL_1 + i, raw_level);
                g_sensor_data.liquid_level[i].filtered_value = filtered_level;

                // æ ¡å‡†å¤„ç†
                float calibrated_level = sensor_calibration_apply(SENSOR_LIQUID_LEVEL_1 + i, filtered_level);
                g_sensor_data.liquid_level[i].calibrated_value = calibrated_level;
            }

            g_sensor_data.liquid_level[i].timestamp = xTaskGetTickCount();
        }

        // 2. å‹åŠ›ä¼ æ„Ÿå™¨å¤„ç† (ä¿æŒv3ç®—æ³•)
        for (int i = 0; i < 2; i++) {
            // è¯»å–åŸå§‹æ•°æ® (ä¿æŒv3æ¥å£)
            float raw_pressure = read_pressure_hp10my(i);
            g_sensor_data.pressure[i].raw_value = raw_pressure;

            // æ•…éšœæ£€æµ‹
            if (raw_pressure < -900) {
                g_sensor_data.pressure[i].fault_status = true;
                g_sensor_data.pressure[i].fault_code = FAULT_PRESSURE_SENSOR_1_FAULT + i;
            } else {
                g_sensor_data.pressure[i].fault_status = false;
                g_sensor_data.pressure[i].fault_code = 0;

                // æ•°å­—æ»¤æ³¢å¤„ç†
                float filtered_pressure = sensor_filter_process(FILTER_PRESSURE_1 + i, raw_pressure);
                g_sensor_data.pressure[i].filtered_value = filtered_pressure;

                // æ ¡å‡†å¤„ç†
                float calibrated_pressure = sensor_calibration_apply(SENSOR_PRESSURE_1 + i, filtered_pressure);
                g_sensor_data.pressure[i].calibrated_value = calibrated_pressure;
            }

            g_sensor_data.pressure[i].timestamp = xTaskGetTickCount();
        }

        // 3. æ¸©åº¦ä¼ æ„Ÿå™¨å¤„ç† (ä¿æŒv3ç®—æ³•)
        for (int i = 0; i < 3; i++) {
            // è¯»å–åŸå§‹æ•°æ® (ä¿æŒv3æ¥å£)
            float raw_temperature = read_temperature_ftt518_pt100(i);
            g_sensor_data.temperature[i].raw_value = raw_temperature;

            // è¯»å–PT100ç”µé˜»å€¼ (ç”¨äºæ•…éšœè¯Šæ–­)
            float pt100_resistance = get_pt100_resistance_value(i);
            g_sensor_data.temperature[i].resistance = pt100_resistance;

            // æ•…éšœæ£€æµ‹ (PT100å¼€è·¯/çŸ­è·¯æ£€æµ‹)
            if (pt100_resistance < 50.0f || pt100_resistance > 500.0f) {
                g_sensor_data.temperature[i].fault_status = true;
                if (pt100_resistance < 50.0f) {
                    g_sensor_data.temperature[i].fault_code = FAULT_TEMP_SENSOR_1_SHORT + i;
                } else {
                    g_sensor_data.temperature[i].fault_code = FAULT_TEMP_SENSOR_1_OPEN + i;
                }
            } else {
                g_sensor_data.temperature[i].fault_status = false;
                g_sensor_data.temperature[i].fault_code = 0;

                // æ•°å­—æ»¤æ³¢å¤„ç†
                float filtered_temperature = sensor_filter_process(FILTER_TEMPERATURE_1 + i, raw_temperature);
                g_sensor_data.temperature[i].filtered_value = filtered_temperature;

                // æ ¡å‡†å¤„ç†
                float calibrated_temperature = sensor_calibration_apply(SENSOR_TEMPERATURE_1 + i, filtered_temperature);
                g_sensor_data.temperature[i].calibrated_value = calibrated_temperature;
            }

            g_sensor_data.temperature[i].timestamp = xTaskGetTickCount();
        }
    }
}

// FRD-8061æ¶²ä½ä¼ æ„Ÿå™¨å…·ä½“å®ç° (ä¿æŒv3ç®—æ³•)
float read_liquid_level_frd8061(uint8_t sensor_id)
{
    // ä½¿ç”¨GD32F427 ADCè¯»å–4-20mAä¿¡å· (ä¿æŒv3è½¬æ¢ç®—æ³•)
    uint16_t adc_value = gd32f427_adc_read_channel(ADC_LIQUID_LEVEL_1 + sensor_id);

    // æ ‡å‡†4-20mAè½¬æ¢å…¬å¼ (ä¸v3æ–‡æ¡£ä¸€è‡´)
    float voltage = (float)adc_value * 3.3f / 32768.0f;  // 15bit ADC
    float current = voltage / 250.0f * 1000.0f;  // mA

    if (current < 4.0f || current > 20.0f) return -1.0f;  // æ•…éšœæ£€æµ‹

    float level = (current - 4.0f) * 2000.0f / 16.0f;  // mm
    return level;
}

// HP10MYå‹åŠ›ä¼ æ„Ÿå™¨å…·ä½“å®ç° (ä¿æŒv3ç®—æ³•)
float read_pressure_hp10my(uint8_t sensor_id)
{
    // ä½¿ç”¨GD32F427 ADCè¯»å–4-20mAä¿¡å· (ä¿æŒv3è½¬æ¢ç®—æ³•)
    uint16_t adc_value = gd32f427_adc_read_channel(ADC_PRESSURE_1 + sensor_id);

    // æ ‡å‡†4-20mAè½¬æ¢å…¬å¼ (ä¸v3æ–‡æ¡£ä¸€è‡´)
    float voltage = (float)adc_value * 3.3f / 32768.0f;
    float current = voltage / 250.0f * 1000.0f;

    if (current < 3.5f || current > 20.5f) return -999.0f;

    // å‹åŠ›èŒƒå›´æ˜ å°„ (4mA=-100kPa, 20mA=100MPa)
    float pressure = -100.0f + (current - 4.0f) * (100100.0f / 16.0f);
    return pressure;
}

// FTT518æ¸©åº¦ä¼ æ„Ÿå™¨å…·ä½“å®ç° (ä¿æŒv3ç®—æ³•)
float read_temperature_ftt518_pt100(uint8_t sensor_id)
{
    // ä½¿ç”¨GD32F427 ADCè¯»å–PT100ä¸‰çº¿åˆ¶ä¿¡å· (ä¿æŒv3è½¬æ¢ç®—æ³•)
    uint16_t adc_signal = gd32f427_adc_read_channel(ADC_PT100_SIGNAL_1 + sensor_id);
    uint16_t adc_ref = gd32f427_adc_read_channel(ADC_PT100_REF_1 + sensor_id);

    const float excitation_current = 0.001f;  // 1mA
    const float reference_resistor = 1000.0f; // 1kÎ©

    float voltage_signal = (float)adc_signal * 3.3f / 32768.0f;
    float voltage_ref = (float)adc_ref * 3.3f / 32768.0f;

    // ä¸‰çº¿åˆ¶è¡¥å¿ç®—æ³•
    float resistance_signal = voltage_signal / excitation_current;
    float wire_resistance = (reference_resistor - voltage_ref / excitation_current) / 2.0f;
    float pt100_resistance = resistance_signal - 2.0f * wire_resistance;

    // PT100ç”µé˜»-æ¸©åº¦è½¬æ¢
    float temperature;
    if (pt100_resistance >= 100.0f) {
        temperature = (pt100_resistance - 100.0f) / (100.0f * 0.003851f);
    } else {
        temperature = (pt100_resistance - 100.0f) / (100.0f * 0.003851f);
    }

    return temperature;
}
```

---

# ç¬¬äºŒç«  é€šä¿¡ç³»ç»Ÿå…·ä½“å®ç° (ä¿æŒv3åŒåè®®)

## 2.1 EtherCATé€šä¿¡æ¨¡å— (ä¿æŒv3è®¾è®¡)

```c
/**
 * @file    ethercat_app.c
 * @brief   EtherCATåº”ç”¨å®ç° - ä¿æŒv3ç‰ˆæœ¬EtherCATåŠŸèƒ½
 * @version V4.0
 * @date    2025-09-27
 */

#include "ethercat_app.h"
#include "comm_task.h"
#include "sensor_task.h"
#include "actuator_task.h"
#include "system_config.h"

// FreeRTOSå¤´æ–‡ä»¶
#include "FreeRTOS.h"
#include "task.h"
#include "semphr.h"

// EtherCATåè®®æ ˆå¤´æ–‡ä»¶
#include "ethercat_stack.h"
#include "ssc.h"

// ä¿æŒv3æ–‡æ¡£çš„è¿‡ç¨‹æ•°æ®å®šä¹‰ (å®Œå…¨ä¸€è‡´)
typedef struct {
    // è¾“å…¥æ•°æ® (ä¼ æ„Ÿå™¨ -> ä¸»ç«™)
    struct {
        // æ¨¡æ‹Ÿé‡è¾“å…¥ (12å­—èŠ‚)
        uint16_t liquid_level_1;     // æ¶²ä½ä¼ æ„Ÿå™¨1 (0-2000mm)
        uint16_t liquid_level_2;     // æ¶²ä½ä¼ æ„Ÿå™¨2 (0-2000mm)
        uint16_t pressure_1;         // å‹åŠ›ä¼ æ„Ÿå™¨1 (Â±100MPa)
        uint16_t pressure_2;         // å‹åŠ›ä¼ æ„Ÿå™¨2 (Â±100MPa)
        uint16_t temperature_1;      // æ¸©åº¦ä¼ æ„Ÿå™¨1 (0-600Â°C)
        uint16_t temperature_2;      // æ¸©åº¦ä¼ æ„Ÿå™¨2 (0-600Â°C)

        // æ•°å­—é‡è¾“å…¥ (2å­—èŠ‚)
        uint16_t digital_inputs;     // å¼€å…³é‡çŠ¶æ€

        // çŠ¶æ€ä¿¡æ¯ (2å­—èŠ‚)
        uint16_t system_status;      // ç³»ç»ŸçŠ¶æ€å­—
        uint16_t fault_code;         // æ•…éšœä»£ç 
    } inputs;

    // è¾“å‡ºæ•°æ® (ä¸»ç«™ -> æ‰§è¡Œå™¨)
    struct {
        // æ¨¡æ‹Ÿé‡è¾“å‡º (8å­—èŠ‚)
        uint16_t heater_power_1;     // åŠ çƒ­å™¨1åŠŸç‡ (0-100%)
        uint16_t heater_power_2;     // åŠ çƒ­å™¨2åŠŸç‡ (0-100%)
        uint16_t pump_speed_1;       // æ³µ1è½¬é€Ÿ (200-5000RPM)
        uint16_t pump_speed_2;       // æ³µ2è½¬é€Ÿ (200-5000RPM)

        // æ•°å­—é‡è¾“å‡º (2å­—èŠ‚)
        uint16_t digital_outputs;    // é˜€é—¨æ§åˆ¶ç­‰

        // æ§åˆ¶å‘½ä»¤ (2å­—èŠ‚)
        uint16_t control_command;    // ç³»ç»Ÿæ§åˆ¶å‘½ä»¤
    } outputs;

} ethercat_process_data_t;

// å…¨å±€EtherCATè¿‡ç¨‹æ•°æ®
ethercat_process_data_t g_ethercat_data;

// EtherCATä»»åŠ¡å‚æ•° (ä¿æŒv3ä¸¥æ ¼å®æ—¶æ€§)
#define ETHERCAT_CYCLE_TIME_MS      1       // 1msä¸¥æ ¼å‘¨æœŸ
#define ETHERCAT_PRIORITY           7       // æœ€é«˜ä¼˜å…ˆçº§

/**
 * @brief  EtherCATåº”ç”¨ä»»åŠ¡ (ä¿æŒv3è®¾è®¡ï¼Œä¸¥æ ¼1mså‘¨æœŸ)
 * @param  pvParameters ä»»åŠ¡å‚æ•°
 * @retval None
 */
void ethercat_app_task(void *pvParameters)
{
    TickType_t xLastWakeTime;
    uint32_t cycle_counter = 0;
    uint32_t max_cycle_time = 0;
    uint32_t cycle_overrun_count = 0;

    // åˆå§‹åŒ–EtherCAT
    ethercat_app_init();

    // è®¾ç½®ä»»åŠ¡ä¸ºæœ€é«˜ä¼˜å…ˆçº§
    vTaskPrioritySet(NULL, ETHERCAT_PRIORITY);

    xLastWakeTime = xTaskGetTickCount();

    while (1) {
        uint32_t cycle_start_time = get_cycle_counter();

        // ä¸¥æ ¼1mså‘¨æœŸå»¶æ—¶ (ä¿æŒv3å®æ—¶æ€§è¦æ±‚)
        BaseType_t xWasDelayed = vTaskDelayUntil(&xLastWakeTime, pdMS_TO_TICKS(ETHERCAT_CYCLE_TIME_MS));

        if (xWasDelayed == pdFALSE) {
            cycle_overrun_count++;
            // è®°å½•å‘¨æœŸè¶…é™äº‹ä»¶
            log_cycle_overrun_event();
        }

        // EtherCATæ•°æ®å¤„ç† (å…³é”®å®æ—¶ä»£ç )
        taskENTER_CRITICAL();

        // 1. è¯»å–EtherCATè¾“å…¥æ•°æ®
        ssc_read_process_data(&g_ethercat_data);

        // 2. æ›´æ–°ä¼ æ„Ÿå™¨æ•°æ®åˆ°EtherCATè¾“å…¥ (ä¿æŒv3æ¥å£)
        update_ethercat_inputs_from_sensors();

        // 3. ä»EtherCATè¾“å‡ºæ•°æ®æ›´æ–°æ‰§è¡Œå™¨ (ä¿æŒv3æ¥å£)
        update_actuators_from_ethercat_outputs();

        // 4. å†™å…¥EtherCATè¾“å‡ºæ•°æ®
        ssc_write_process_data(&g_ethercat_data);

        // 5. EtherCATçŠ¶æ€æœºå¤„ç†
        ssc_main_loop();

        taskEXIT_CRITICAL();

        uint32_t cycle_end_time = get_cycle_counter();
        uint32_t cycle_duration = cycle_end_time - cycle_start_time;

        if (cycle_duration > max_cycle_time) {
            max_cycle_time = cycle_duration;
        }

        // æ€§èƒ½ç›‘æ§ (æ¯1000ä¸ªå‘¨æœŸæŠ¥å‘Šä¸€æ¬¡)
        if (++cycle_counter >= 1000) {
            report_ethercat_performance(max_cycle_time, cycle_overrun_count);
            cycle_counter = 0;
            max_cycle_time = 0;
            cycle_overrun_count = 0;
        }
    }
}

/**
 * @brief  EtherCATåº”ç”¨åˆå§‹åŒ–
 * @param  None
 * @retval None
 */
static void ethercat_app_init(void)
{
    // 1. ç¡¬ä»¶åˆå§‹åŒ–
    gd32f427_eth_init();        // ä»¥å¤ªç½‘MACåˆå§‹åŒ–

    // 2. EtherCATåè®®æ ˆåˆå§‹åŒ– (ä½¿ç”¨SSC)
    ssc_init();

    // 3. é…ç½®è®¾å¤‡ä¿¡æ¯
    ssc_set_device_info("ä»€æ–¹ç§‘æŠ€", "ä¾›å¢¨æ§åˆ¶å™¨", "V4.0");

    // 4. é…ç½®è¿‡ç¨‹æ•°æ®å¯¹è±¡
    ssc_configure_pdo();

    // 5. å¯åŠ¨EtherCATçŠ¶æ€æœº
    ssc_start_state_machine();

    // 6. åˆå§‹åŒ–è¿‡ç¨‹æ•°æ®
    memset(&g_ethercat_data, 0, sizeof(ethercat_process_data_t));
}

/**
 * @brief  æ›´æ–°ä¼ æ„Ÿå™¨æ•°æ®åˆ°EtherCATè¾“å…¥ (ä¿æŒv3æ¥å£)
 * @param  None
 * @retval None
 */
static void update_ethercat_inputs_from_sensors(void)
{
    // æ¶²ä½ä¼ æ„Ÿå™¨æ•°æ® (ä¿æŒv3æ•°æ®æ ¼å¼)
    g_ethercat_data.inputs.liquid_level_1 = (uint16_t)(get_liquid_level_sensor(0) * 10);
    g_ethercat_data.inputs.liquid_level_2 = (uint16_t)(get_liquid_level_sensor(1) * 10);

    // å‹åŠ›ä¼ æ„Ÿå™¨æ•°æ® (ä¿æŒv3æ•°æ®æ ¼å¼)
    g_ethercat_data.inputs.pressure_1 = (uint16_t)((get_pressure_sensor(0) + 100) * 10);
    g_ethercat_data.inputs.pressure_2 = (uint16_t)((get_pressure_sensor(1) + 100) * 10);

    // æ¸©åº¦ä¼ æ„Ÿå™¨æ•°æ® (ä¿æŒv3æ•°æ®æ ¼å¼)
    g_ethercat_data.inputs.temperature_1 = (uint16_t)(get_pt100_temperature(0) * 10);
    g_ethercat_data.inputs.temperature_2 = (uint16_t)(get_pt100_temperature(1) * 10);

    // æ•°å­—è¾“å…¥çŠ¶æ€ (ä¿æŒv3æ•°å­—IOå®šä¹‰)
    g_ethercat_data.inputs.digital_inputs = get_digital_input_status();

    // ç³»ç»ŸçŠ¶æ€
    g_ethercat_data.inputs.system_status = get_system_status();
    g_ethercat_data.inputs.fault_code = get_current_fault_code();
}

/**
 * @brief  ä»EtherCATè¾“å‡ºæ›´æ–°æ‰§è¡Œå™¨ (ä¿æŒv3æ¥å£)
 * @param  None
 * @retval None
 */
static void update_actuators_from_ethercat_outputs(void)
{
    // åŠ çƒ­å™¨åŠŸç‡æ§åˆ¶ (ä¿æŒv3æ¥å£)
    float heater_power_1 = (float)g_ethercat_data.outputs.heater_power_1 / 10.0f;
    float heater_power_2 = (float)g_ethercat_data.outputs.heater_power_2 / 10.0f;

    control_heater_mra23d3(0, heater_power_1);
    control_heater_mra23d3(1, heater_power_2);

    // æ³µè½¬é€Ÿæ§åˆ¶ (ä¿æŒv3æ¥å£)
    uint16_t pump_speed_1 = g_ethercat_data.outputs.pump_speed_1;
    uint16_t pump_speed_2 = g_ethercat_data.outputs.pump_speed_2;

    control_pump_speed_mpb025bbb(0, pump_speed_1);
    control_pump_speed_mpb025bbb(1, pump_speed_2);

    // æ•°å­—è¾“å‡ºæ§åˆ¶ (ä¿æŒv3æ•°å­—IOå®šä¹‰)
    set_digital_output_status(g_ethercat_data.outputs.digital_outputs);

    // æ§åˆ¶å‘½ä»¤å¤„ç†
    process_ethercat_control_commands(g_ethercat_data.outputs.control_command);
}
```

## 2.2 TCP/IPé€šä¿¡æ¨¡å— (ä¿æŒv3åŠŸèƒ½)

```c
/**
 * @file    tcp_server.c
 * @brief   TCPæœåŠ¡å™¨å®ç° - ä¿æŒv3ç‰ˆæœ¬TCPåŠŸèƒ½
 * @version V4.0
 * @date    2025-09-27
 */

#include "tcp_server.h"
#include "comm_task.h"
#include "sensor_task.h"
#include "actuator_task.h"
#include "system_config.h"

// lwIPå¤´æ–‡ä»¶
#include "lwip/opt.h"
#include "lwip/arch.h"
#include "lwip/api.h"
#include "lwip/inet.h"
#include "lwip/sockets.h"

// FreeRTOSå¤´æ–‡ä»¶
#include "FreeRTOS.h"
#include "task.h"
#include "semphr.h"

// ä¿æŒv3æ–‡æ¡£çš„ç½‘ç»œé…ç½®ç»“æ„
typedef struct {
    uint32_t controller_ip;       // æ§åˆ¶å™¨IPåœ°å€
    uint32_t host_ip;            // ä¸Šä½æœºIPåœ°å€
    uint16_t communication_port; // é€šä¿¡ç«¯å£ (é»˜è®¤502)
    uint16_t heartbeat_interval; // å¿ƒè·³é—´éš” (ms)
    uint8_t connection_timeout;  // è¿æ¥è¶…æ—¶ (s)
} network_config_t;

// ç½‘ç»œé…ç½®
static network_config_t network_config = {
    .controller_ip = IP4_ADDR(192, 168, 1, 100),
    .host_ip = IP4_ADDR(192, 168, 1, 10),
    .communication_port = 502,
    .heartbeat_interval = 1000,
    .connection_timeout = 30
};

/**
 * @brief  TCPæœåŠ¡å™¨ä»»åŠ¡ (ä¿æŒv3è®¾è®¡)
 * @param  pvParameters ä»»åŠ¡å‚æ•°
 * @retval None
 */
void tcp_server_task(void *pvParameters)
{
    struct netconn *conn, *newconn;
    err_t err;

    // åˆå§‹åŒ–lwIPç½‘ç»œæ¥å£
    tcp_server_init();

    // åˆ›å»ºTCPè¿æ¥ç»“æ„
    conn = netconn_new(NETCONN_TCP);
    if (conn == NULL) {
        vTaskDelete(NULL);
        return;
    }

    // ç»‘å®šç«¯å£ (ä¿æŒv3æ–‡æ¡£çš„502ç«¯å£)
    err = netconn_bind(conn, IP_ADDR_ANY, network_config.communication_port);
    if (err != ERR_OK) {
        netconn_delete(conn);
        vTaskDelete(NULL);
        return;
    }

    // å¼€å§‹ç›‘å¬
    err = netconn_listen(conn);
    if (err != ERR_OK) {
        netconn_delete(conn);
        vTaskDelete(NULL);
        return;
    }

    while (1) {
        // ç­‰å¾…æ–°è¿æ¥
        err = netconn_accept(conn, &newconn);
        if (err == ERR_OK) {
            // éªŒè¯å®¢æˆ·ç«¯IP
            ip_addr_t client_ip;
            netconn_peer(newconn, &client_ip, NULL);

            if (is_ip_allowed(&client_ip)) {
                // åˆ›å»ºå®¢æˆ·ç«¯å¤„ç†ä»»åŠ¡
                xTaskCreate(tcp_client_handler, "TCPClient",
                           2048, newconn, 3, NULL);
            } else {
                // æ‹’ç»æœªæˆæƒè¿æ¥
                netconn_close(newconn);
                netconn_delete(newconn);
                log_unauthorized_access_attempt(&client_ip);
            }
        }

        vTaskDelay(pdMS_TO_TICKS(10));
    }
}

/**
 * @brief  TCPå®¢æˆ·ç«¯å¤„ç†ä»»åŠ¡ (ä¿æŒv3æ•°æ®æ ¼å¼)
 * @param  pvParameters netconnè¿æ¥æŒ‡é’ˆ
 * @retval None
 */
void tcp_client_handler(void *pvParameters)
{
    struct netconn *conn = (struct netconn *)pvParameters;
    struct netbuf *buf;
    char *data;
    u16_t len;
    char response[1024];

    while (1) {
        // æ¥æ”¶æ•°æ®
        err_t err = netconn_recv(conn, &buf);
        if (err == ERR_OK) {
            netbuf_data(buf, (void**)&data, &len);

            // å¤„ç†æ¥æ”¶åˆ°çš„å‘½ä»¤
            process_tcp_command(data, len, response, sizeof(response));

            // å‘é€å“åº”
            netconn_write(conn, response, strlen(response), NETCONN_COPY);

            netbuf_delete(buf);
        } else {
            // è¿æ¥æ–­å¼€æˆ–é”™è¯¯
            break;
        }

        vTaskDelay(pdMS_TO_TICKS(10));
    }

    // æ¸…ç†è¿æ¥
    netconn_close(conn);
    netconn_delete(conn);
    vTaskDelete(NULL);
}

/**
 * @brief  å¤„ç†TCPå‘½ä»¤ (ä¿æŒv3åè®®æ ¼å¼)
 * @param  request è¯·æ±‚æ•°æ®
 * @param  request_len è¯·æ±‚é•¿åº¦
 * @param  response å“åº”ç¼“å†²åŒº
 * @param  response_size å“åº”ç¼“å†²åŒºå¤§å°
 * @retval None
 */
static void process_tcp_command(char *request, uint16_t request_len,
                               char *response, uint16_t response_size)
{
    // è§£æJSONè¯·æ±‚æˆ–ç®€å•å‘½ä»¤
    if (strncmp(request, "GET_STATUS", 10) == 0) {
        // è·å–ç³»ç»ŸçŠ¶æ€ (ä¿æŒv3æ•°æ®æ ¼å¼)
        create_status_response(response, response_size);
    }
    else if (strncmp(request, "GET_SENSORS", 11) == 0) {
        // è·å–ä¼ æ„Ÿå™¨æ•°æ® (ä¿æŒv3æ•°æ®æ ¼å¼)
        create_sensor_response(response, response_size);
    }
    else if (strncmp(request, "SET_HEATER", 10) == 0) {
        // è®¾ç½®åŠ çƒ­å™¨åŠŸç‡
        parse_heater_command(request, request_len);
        strcpy(response, "OK");
    }
    else if (strncmp(request, "SET_PUMP", 8) == 0) {
        // è®¾ç½®æ³µè½¬é€Ÿ
        parse_pump_command(request, request_len);
        strcpy(response, "OK");
    }
    else {
        // æœªçŸ¥å‘½ä»¤
        strcpy(response, "ERROR: Unknown command");
    }
}

/**
 * @brief  åˆ›å»ºç³»ç»ŸçŠ¶æ€å“åº” (ä¿æŒv3æ•°æ®æ ¼å¼)
 * @param  response å“åº”ç¼“å†²åŒº
 * @param  response_size ç¼“å†²åŒºå¤§å°
 * @retval None
 */
static void create_status_response(char *response, uint16_t response_size)
{
    // æ„é€ JSONå“åº”æ•°æ® (ä¿æŒv3æ ¼å¼)
    snprintf(response, response_size,
        "{"
        "\"temperature\":[%.2f,%.2f,%.2f],"
        "\"pressure\":[%.2f,%.2f],"
        "\"liquid_level\":[%.2f,%.2f],"
        "\"heater_status\":[%d,%d,%d],"
        "\"pump_speed\":[%d,%d],"
        "\"valve_status\":%d,"
        "\"system_status\":%d,"
        "\"fault_code\":%d,"
        "\"timestamp\":%u"
        "}",
        get_pt100_temperature(0), get_pt100_temperature(1), get_pt100_temperature(2),
        get_pressure_sensor(0), get_pressure_sensor(1),
        get_liquid_level_sensor(0), get_liquid_level_sensor(1),
        get_heater_status(0), get_heater_status(1), get_heater_status(2),
        get_pump_speed(0), get_pump_speed(1),
        get_valve_status_word(),
        get_system_status(),
        get_current_fault_code(),
        (uint32_t)xTaskGetTickCount()
    );
}
```

---

# ç¬¬ä¸‰ç«  8å‘¨å…·ä½“å¼€å‘è®¡åˆ’ (ä»£ç å®ç°ç‰ˆ)

## 3.1 è¯¦ç»†8å‘¨å¼€å‘æ—¶é—´è¡¨

### ç¬¬1å‘¨: åŸºç¡€å¹³å°æ­å»º + é¡¹ç›®æ¡†æ¶å»ºç«‹

**Day 1-2: å¼€å‘ç¯å¢ƒå»ºç«‹**
```bash
# å¼€å‘å·¥å…·å®‰è£…
- GD32 IDEå®‰è£…é…ç½®
- Gitç‰ˆæœ¬æ§åˆ¶é…ç½®
- åˆ›å»ºé¡¹ç›®ä»“åº“

# åŸºç¡€é¡¹ç›®ç»“æ„
mkdir ink_supply_system_gd32f427
cd ink_supply_system_gd32f427
mkdir -p src/{application,middleware,drivers,bsp,config}
mkdir -p include/{application,middleware,drivers,bsp}
mkdir -p lib/{GD32F4xx_standard_peripheral,FreeRTOS,lwip,EtherCAT_Stack}
mkdir -p docs tools build test
```

**Day 3-4: åŸºç¡€æ¡†æ¶ä»£ç **
- å®Œæˆmain.cä¸»ç¨‹åºæ¡†æ¶
- å®ç°ç³»ç»Ÿé…ç½®å¤´æ–‡ä»¶
- å»ºç«‹Makefileæ„å»ºç³»ç»Ÿ
- å®ŒæˆåŸºç¡€BSPåˆå§‹åŒ–ä»£ç 

**Day 5-7: FreeRTOSé›†æˆ**
- é›†æˆFreeRTOS v10.4.6æºç 
- é…ç½®FreeRTOSConfig.h
- å®ç°åŸºç¡€ä»»åŠ¡åˆ›å»ºæ¡†æ¶
- æµ‹è¯•ä»»åŠ¡è°ƒåº¦å’Œå†…å­˜ç®¡ç†

### ç¬¬2å‘¨: GD32F427ç¡¬ä»¶é©±åŠ¨å¼€å‘

**Day 1-2: æ ¸å¿ƒå¤–è®¾é©±åŠ¨**
```c
// src/drivers/gd32f427/gd32f427_gpio.c
void gd32f427_gpio_init(void);
void gd32f427_gpio_set_pin(uint32_t gpio_port, uint16_t pin);

// src/drivers/gd32f427/gd32f427_adc.c
uint16_t gd32f427_adc_read_channel(uint8_t channel);
void gd32f427_adc_init(void);

// src/drivers/gd32f427/gd32f427_pwm.c
void gd32f427_pwm_set_duty_cycle(uint8_t timer, uint8_t channel, uint16_t duty);
```

**Day 3-4: é€šä¿¡å¤–è®¾é©±åŠ¨**
```c
// src/drivers/gd32f427/gd32f427_uart.c
void gd32f427_uart_send_data(uint8_t uart_port, uint8_t *data, uint16_t len);

// src/drivers/gd32f427/gd32f427_spi.c
uint8_t gd32f427_spi_transfer(uint8_t spi_port, uint8_t data);

// src/drivers/gd32f427/gd32f427_eth.c
void gd32f427_eth_init(void);
```

**Day 5-7: ä¼ æ„Ÿå™¨é©±åŠ¨å¼€å‘**
```c
// src/drivers/sensors/frd8061_driver.c - FRD-8061æ¶²ä½ä¼ æ„Ÿå™¨
float frd8061_read_level(uint8_t sensor_id);

// src/drivers/sensors/hp10my_driver.c - HP10MYå‹åŠ›ä¼ æ„Ÿå™¨
float hp10my_read_pressure(uint8_t sensor_id);

// src/drivers/sensors/ftt518_driver.c - FTT518æ¸©åº¦ä¼ æ„Ÿå™¨
float ftt518_read_temperature(uint8_t sensor_id);
```

### ç¬¬3å‘¨: ä¼ æ„Ÿå™¨åº”ç”¨æ¨¡å—å¼€å‘

**Day 1-2: ä¼ æ„Ÿå™¨ä»»åŠ¡å®ç°**
- å®Œæˆsensor_task.cæ ¸å¿ƒåŠŸèƒ½
- å®ç°10mså‘¨æœŸæ•°æ®é‡‡é›†
- é›†æˆæ•°å­—æ»¤æ³¢ç®—æ³•

**Day 3-4: ä¼ æ„Ÿå™¨æ•°æ®å¤„ç†**
```c
// src/application/sensor/sensor_filter.c
float sensor_filter_process(uint8_t filter_id, float raw_value);

// src/application/sensor/sensor_calibration.c
float sensor_calibration_apply(uint8_t sensor_id, float raw_value);
```

**Day 5-7: ä¼ æ„Ÿå™¨æ•…éšœæ£€æµ‹**
```c
// src/application/sensor/sensor_manager.c
bool sensor_fault_detection(uint8_t sensor_id);
void sensor_status_update(void);
```

### ç¬¬4å‘¨: æ‰§è¡Œå™¨åº”ç”¨æ¨¡å—å¼€å‘

**Day 1-2: æ‰§è¡Œå™¨ä»»åŠ¡å®ç°**
- å®Œæˆactuator_task.cæ ¸å¿ƒåŠŸèƒ½
- å®ç°50mså‘¨æœŸæ§åˆ¶è¾“å‡º
- é›†æˆæ‰§è¡Œå™¨ä¿æŠ¤é€»è¾‘

**Day 3-4: æ‰§è¡Œå™¨æ§åˆ¶ç®—æ³•**
```c
// src/application/actuator/mra23d3_heater.c - åŠ çƒ­å™¨æ§åˆ¶
void control_heater_mra23d3(uint8_t heater_id, float power_percent);

// src/application/actuator/mpb025bbb_pump.c - æ³µæ§åˆ¶
void control_pump_speed_mpb025bbb(uint8_t pump_id, uint16_t target_rpm);

// src/application/actuator/valve_control.c - é˜€é—¨æ§åˆ¶
void control_valve(uint8_t valve_id, bool open);
```

**Day 5-7: æ‰§è¡Œå™¨å®‰å…¨ä¿æŠ¤**
```c
// src/application/actuator/actuator_protection.c
bool actuator_safety_check(uint8_t actuator_type, uint8_t actuator_id);
void actuator_emergency_stop(void);
```

### ç¬¬5å‘¨: æ§åˆ¶ç®—æ³•æ¨¡å—å¼€å‘

**Day 1-2: PIDæ§åˆ¶å™¨å®ç°**
```c
// src/application/control/pid_controller.c - ä¿æŒv3ç®—æ³•
typedef struct {
    float kp, ki, kd;         // PIDå‚æ•°
    float setpoint;           // ç›®æ ‡å€¼
    float last_error;         // ä¸Šæ¬¡è¯¯å·®
    float integral;           // ç§¯åˆ†ç´¯ç§¯
    uint32_t last_time;       // ä¸Šæ¬¡è®¡ç®—æ—¶é—´
} pid_controller_t;

float simple_pid_control(pid_controller_t *pid, float current_value);
```

**Day 3-4: æ¸©åº¦æ§åˆ¶åº”ç”¨**
```c
// src/application/control/temperature_control.c
void temperature_control_task(void);
void temperature_pid_update(uint8_t heater_id);
```

**Day 5-7: å‹åŠ›æ¶²ä½æ§åˆ¶**
```c
// src/application/control/pressure_control.c
void pressure_control_task(void);

// src/application/control/liquid_level_control.c
void liquid_level_control_task(void);
```

### ç¬¬6å‘¨: é€šä¿¡ç³»ç»Ÿå¼€å‘

**Day 1-2: lwIPç½‘ç»œåº“é›†æˆ**
- é›†æˆlwIP 2.1.3æºç 
- é…ç½®lwipopts.h
- å®ç°åŸºç¡€TCP/IPåŠŸèƒ½

**Day 3-4: EtherCATåè®®æ ˆé›†æˆ**
```c
// src/application/communication/ethercat_app.c
void ethercat_app_task(void *pvParameters);
void update_ethercat_inputs_from_sensors(void);
void update_actuators_from_ethercat_outputs(void);
```

**Day 5-7: TCPæœåŠ¡å™¨å®ç°**
```c
// src/application/communication/tcp_server.c
void tcp_server_task(void *pvParameters);
void tcp_client_handler(void *pvParameters);
void process_tcp_command(char *request, uint16_t len, char *response, uint16_t size);
```

### ç¬¬7å‘¨: HMIå’Œå®‰å…¨ç³»ç»Ÿå¼€å‘

**Day 1-2: LCDæ˜¾ç¤ºç³»ç»Ÿ**
```c
// src/application/hmi/ch12832b_display.c
void display_init(void);
void display_main_page(void);
void display_sensor_page(void);
void display_actuator_page(void);
```

**Day 3-4: LEDæŒ‡ç¤ºç³»ç»Ÿ**
```c
// src/application/hmi/led_indicator.c - 5è·¯LED
void led_manager_task(void);
void led_set_status(uint8_t led_id, led_state_t state);
```

**Day 5-7: å®‰å…¨ä¿æŠ¤ç³»ç»Ÿ**
```c
// src/application/safety/safety_manager.c
void safety_task(void *pvParameters);
void safety_monitor_check(void);
void emergency_shutdown_execute(void);
```

### ç¬¬8å‘¨: ç³»ç»Ÿé›†æˆæµ‹è¯•ä¸ä¼˜åŒ–

**Day 1-2: å®Œæ•´ç³»ç»Ÿé›†æˆ**
- æ‰€æœ‰æ¨¡å—é›†æˆè”è°ƒ
- ä¿®å¤é›†æˆè¿‡ç¨‹ä¸­çš„é—®é¢˜
- å®Œå–„æ¨¡å—é—´æ¥å£

**Day 3-4: åŠŸèƒ½æµ‹è¯•éªŒè¯**
- ä¼ æ„Ÿå™¨ç²¾åº¦æµ‹è¯•
- æ‰§è¡Œå™¨æ§åˆ¶æµ‹è¯•
- é€šä¿¡åè®®æµ‹è¯•
- å®‰å…¨ä¿æŠ¤æµ‹è¯•

**Day 5-7: æ€§èƒ½ä¼˜åŒ–ä¸æ–‡æ¡£**
- ä»£ç æ€§èƒ½ä¼˜åŒ–
- å†…å­˜ä½¿ç”¨ä¼˜åŒ–
- å®Œå–„æŠ€æœ¯æ–‡æ¡£
- ç¼–å†™ç”¨æˆ·æ‰‹å†Œ

## 3.2 ä»£ç è´¨é‡ä¿è¯æªæ–½

### ç¼–ç è§„èŒƒ
```c
// æ–‡ä»¶å¤´æ³¨é‡Šè§„èŒƒ
/**
 * @file    sensor_task.c
 * @brief   ä¼ æ„Ÿå™¨ä»»åŠ¡å®ç°
 * @version V4.0
 * @date    2025-09-27
 * @author  å¼€å‘å›¢é˜Ÿ
 */

// å‡½æ•°æ³¨é‡Šè§„èŒƒ
/**
 * @brief  è¯»å–æ¶²ä½ä¼ æ„Ÿå™¨æ•°æ®
 * @param  sensor_id ä¼ æ„Ÿå™¨ID (0-1)
 * @retval float æ¶²ä½å€¼ (mm)ï¼Œ-1è¡¨ç¤ºæ•…éšœ
 */
float read_liquid_level_frd8061(uint8_t sensor_id);
```

### æ¨¡å—åŒ–è®¾è®¡
```c
// æ¨¡å—æ¥å£å®šä¹‰ - ä¿æŒv3å…¼å®¹æ€§
// include/application/sensor_task.h
float get_liquid_level_sensor(uint8_t sensor_id);
float get_pressure_sensor(uint8_t sensor_id);
float get_pt100_temperature(uint8_t sensor_id);
```

### æµ‹è¯•éªŒè¯
```c
// test/unit_tests/test_sensor.c - å•å…ƒæµ‹è¯•
void test_liquid_level_conversion(void);
void test_pressure_sensor_fault_detection(void);
void test_temperature_calibration(void);
```

---

# æ€»ç»“

## v4ç‰ˆæœ¬æ ¸å¿ƒç‰¹ç‚¹ (åŸºäºGD32F427å…·ä½“å®ç°)

### ğŸ”§ **å…·ä½“ä»£ç å®ç°**
1. **å®Œæ•´ç›®å½•ç»“æ„**: æä¾›è¯¦ç»†çš„æºä»£ç ç»„ç»‡ç»“æ„ï¼ŒåŒ…å«æ‰€æœ‰æ¨¡å—
2. **å…·ä½“ä»£ç ç¤ºä¾‹**: ä¸»è¦æ¨¡å—æä¾›å®Œæ•´çš„Cä»£ç å®ç°
3. **GD32F427ä¼˜åŒ–**: é’ˆå¯¹GD32F427VGT6èŠ¯ç‰‡çš„ä¸“é—¨é€‚é…
4. **æ¥å£å…¼å®¹æ€§**: ä¿æŒä¸v3ç‰ˆæœ¬çš„å®Œå…¨æ¥å£å…¼å®¹

### ğŸ“‹ **åŠŸèƒ½å®Œæ•´æ€§ä¿æŒ** (ä¸v3å®Œå…¨ä¸€è‡´)
âœ… **ä¼ æ„Ÿå™¨ç³»ç»Ÿ**: FRD-8061ã€HP10MYã€FTT518 - ä»£ç å®Œæ•´å®ç°
âœ… **æ‰§è¡Œå™¨ç³»ç»Ÿ**: MRA-23D3ã€MPB025BBBã€ç”µç£é˜€ - ä»£ç å®Œæ•´å®ç°
âœ… **é€šä¿¡ç³»ç»Ÿ**: EtherCAT + TCP/IP - åè®®æ ˆé›†æˆå®ç°
âœ… **æ˜¾ç¤ºç³»ç»Ÿ**: CH12832B LCD + 5è·¯LED - é©±åŠ¨ä»£ç å®ç°
âœ… **æ§åˆ¶ç®—æ³•**: PIDæ§åˆ¶ã€å®‰å…¨ä¿æŠ¤ - ç®—æ³•ä»£ç å®ç°
âœ… **é…ç½®ç®¡ç†**: Flashå­˜å‚¨ã€å‚æ•°ç®¡ç† - å­˜å‚¨ä»£ç å®ç°

### â±ï¸ **8å‘¨å¼€å‘å¯è¡Œæ€§**
1. **å‘¨1-2**: åŸºç¡€å¹³å°+ç¡¬ä»¶é©±åŠ¨ (ä»£ç æ¡†æ¶å»ºç«‹)
2. **å‘¨3-4**: ä¼ æ„Ÿå™¨+æ‰§è¡Œå™¨æ¨¡å— (æ ¸å¿ƒåŠŸèƒ½å®ç°)
3. **å‘¨5-6**: æ§åˆ¶ç®—æ³•+é€šä¿¡ç³»ç»Ÿ (é«˜çº§åŠŸèƒ½å®ç°)
4. **å‘¨7-8**: HMI+å®‰å…¨+é›†æˆæµ‹è¯• (ç³»ç»Ÿå®Œå–„)

### ğŸ› ï¸ **å¼€å‘å·¥å…·é“¾æˆç†Ÿ**
- **å¼€å‘ç¯å¢ƒ**: GD32 IDE + GCCå·¥å…·é“¾
- **è°ƒè¯•å·¥å…·**: GD-Link + GDBè°ƒè¯•å™¨
- **æ„å»ºç³»ç»Ÿ**: Makefile + CMakeåŒæ„å»ºæ”¯æŒ
- **ç‰ˆæœ¬ç®¡ç†**: Gitç‰ˆæœ¬æ§åˆ¶ + ä»£ç è§„èŒƒ

### ğŸ“Š **ä¸å‰ç‰ˆæœ¬å¯¹æ¯”**

| ç‰¹æ€§ | v1ç‰ˆæœ¬ | v3ç‰ˆæœ¬ | **v4ç‰ˆæœ¬(æ¨è)** |
|------|--------|--------|------------------|
| **åŠŸèƒ½å®Œæ•´æ€§** | â­â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­â­ |
| **ä»£ç å…·ä½“æ€§** | â­â­ | â­â­â­ | â­â­â­â­â­ |
| **èŠ¯ç‰‡é€‚é…æ€§** | â­â­â­ | â­â­â­ | â­â­â­â­â­ |
| **å¼€å‘å¯è¡Œæ€§** | â­â­ | â­â­â­â­ | â­â­â­â­â­ |
| **ä»£ç è´¨é‡** | â­â­â­ | â­â­â­ | â­â­â­â­â­ |
| **ç»´æŠ¤å‹å¥½æ€§** | â­â­ | â­â­â­ | â­â­â­â­â­ |

## ç«‹å³å¯æ‰§è¡Œçš„è¡ŒåŠ¨è®¡åˆ’

### ç¬¬1æ­¥: ç¯å¢ƒå‡†å¤‡ (å³åˆ»å¼€å§‹)
```bash
# ä¸‹è½½å®‰è£…GD32 IDE
# åˆ›å»ºGitä»“åº“
git init ink_supply_system_gd32f427
cd ink_supply_system_gd32f427

# åˆ›å»ºç›®å½•ç»“æ„
mkdir -p src/{application,middleware,drivers,bsp,config}
mkdir -p include/{application,middleware,drivers,bsp}
mkdir -p lib build test docs tools
```

### ç¬¬2æ­¥: åŸºç¡€ä»£ç æ­å»º (ç¬¬1å‘¨)
- å¤åˆ¶æ–‡æ¡£ä¸­çš„main.cä½œä¸ºèµ·ç‚¹
- å»ºç«‹åŸºç¡€çš„å¤´æ–‡ä»¶å’Œé…ç½®
- é›†æˆFreeRTOSå’ŒGD32F427æ ‡å‡†åº“
- å®ç°åŸºç¡€çš„ä»»åŠ¡æ¡†æ¶

### ç¬¬3æ­¥: æ¨¡å—åŒ–å¼€å‘ (ç¬¬2-7å‘¨)
- æŒ‰ç…§8å‘¨è®¡åˆ’é€æ¨¡å—å¼€å‘
- æ¯å‘¨æœ«è¿›è¡Œæ¨¡å—é›†æˆæµ‹è¯•
- ä¿æŒä¸v3ç‰ˆæœ¬çš„æ¥å£å…¼å®¹æ€§
- åŠæ—¶è®°å½•å’Œè§£å†³æŠ€æœ¯é—®é¢˜

v4ç‰ˆæœ¬æä¾›äº†ä»è®¾è®¡åˆ°å…·ä½“å®ç°çš„å®Œæ•´è§£å†³æ–¹æ¡ˆï¼Œæ˜¯ä¸€ä¸ªçœŸæ­£å¯ä»¥ç«‹å³åŠ¨æ‰‹å¼€å‘çš„å·¥ä¸šçº§ä¾›å¢¨ç³»ç»Ÿæ§åˆ¶æ¿å¡æ–¹æ¡ˆã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬**: V4.0 (GD32F427å…·ä½“ä»£ç å®ç°ç‰ˆ)
**åˆ›å»ºæ—¥æœŸ**: 2025-09-27
**åŸºç¡€æ–‡æ¡£**: ä¾›å¢¨ç³»ç»Ÿæ§åˆ¶æ¿å¡ç®€åŒ–å®ç°è®¾è®¡æ–‡æ¡£v3
**åŠŸèƒ½ä¿æŒ**: 100% (v3æ‰€æœ‰åŠŸèƒ½éœ€æ±‚å®Œå…¨ä¿æŒ)
**èŠ¯ç‰‡å¹³å°**: GD32F427VGT6 (ç¡®å®šé€‰æ‹©)
**ä»£ç å®Œæ•´æ€§**: æä¾›å®Œæ•´ç›®å½•ç»“æ„å’Œæ ¸å¿ƒæ¨¡å—ä»£ç å®ç°
**å¼€å‘å‘¨æœŸ**: 8å‘¨ (å…·ä½“å¯æ‰§è¡Œçš„å¼€å‘è®¡åˆ’)
**æŠ€æœ¯é£é™©**: ä½ (åŸºäºGD32F427æˆç†Ÿå¹³å°)