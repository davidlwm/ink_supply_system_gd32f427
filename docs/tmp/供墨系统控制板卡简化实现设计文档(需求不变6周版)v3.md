# 供墨系统控制板卡简化实现设计文档 (需求不变6周版) v2

## 文档概述

本文档基于《供墨系统控制板卡综合技术设计文档(分层版)v1》，**保持所有功能需求不变**，通过简化实现方案来降低开发复杂度，适合个人开发者在6周内完成。所有v1文档中的传感器、执行器、通信协议、显示功能等需求完全保留，仅简化实现方式。

## 📋 需求保持不变声明

### 必须保留的功能需求 (基于v1文档)
✅ **传感器系统**: FRD-8061液位传感器、HP10MY压力传感器、FTT518 PT100温度传感器
✅ **执行器系统**: MRA-23D3加热器控制、MPB025BBB调速泵控制、电磁阀控制
✅ **通信系统**: EtherCAT工业总线 + TCP/IP以太网双协议
✅ **显示系统**: CH12832B-12 LCD显示屏、5路LED状态指示
✅ **控制算法**: 温度PID控制、压力控制、液位管理
✅ **安全保护**: 多级保护、故障诊断、紧急停机
✅ **配置管理**: 参数配置、Flash存储、校准管理
✅ **IO功能**: 基于第17页完整IO地址映射表的所有数字IO

### 简化策略 (功能不变，实现简化)
🔸 **使用现成库**: lwip替代自己实现TCP/IP，FreeRTOS替代自己实现调度器
🔸 **成熟方案**: EtherCAT使用现成协议栈，不自己开发
🔸 **工具辅助**: 使用STM32CubeMX类似工具生成基础代码
🔸 **模块化开发**: 优先使用现成驱动模块
🔸 **去除按键**: 人机界面仅显示，不需要键盘输入
🔸 **算法简化**: PID控制等算法使用简单实现，不追求高级特性

---

# 第一章 系统架构设计 (需求保持)

## 1.1 硬件架构完全保持

### 1.1.1 核心硬件规格 (与v1完全一致)

| 参数类型 | 技术规格 | 性能指标 | 实现简化 |
|----------|----------|----------|----------|
| **主控芯片** | GD32F427VGT6 | 200MHz, 1024K Flash, 100PIN | 使用HAL库，减少寄存器操作 |
| **通信协议** | EtherCAT + 以太网 | 100Mbps双协议支持 | 使用现成EtherCAT库+lwip |
| **模拟采集** | 15bit ADC | 多通道高精度采集 | 使用DMA+定时触发，减少CPU负担 |
| **数字IO** | 光电隔离 | 24路数字IO，0.5A输出 | 使用GPIO库，标准化接口 |
| **显示接口** | CH12832B-12 | 128×32点阵LCD | 使用现成驱动库 |

### 1.1.2 传感器系统保持 (基于第8-15页原始设计)

```c
// 保持原有传感器配置，简化驱动实现
typedef struct {
    // FRD-8061液位传感器 (第8页规格)
    struct {
        char model[16];           // "FRD-8061"
        float range_max;          // 2000mm
        float output_min;         // 4.0mA
        float output_max;         // 20.0mA
        uint8_t adc_channel;      // ADC通道号
    } liquid_level;

    // HP10MY压力传感器 (第9页规格)
    struct {
        char model[16];           // "HP10MY"
        float range_max;          // 100000kPa (100MPa)
        float output_min;         // 4.0mA
        float output_max;         // 20.0mA
        uint8_t adc_channel;      // ADC通道号
    } pressure;

    // FTT518 PT100温度传感器 (第9页规格)
    struct {
        char model[16];           // "FTT518"
        char sensor_type[16];     // "PT100 A级"
        float range_max;          // 600°C
        float accuracy_class;     // 0.15%
        uint8_t adc_channel_signal;  // 信号通道
        uint8_t adc_channel_ref;     // 参考通道
    } temperature;
} sensor_system_config_t;

// 简化传感器读取 - 使用标准ADC库
float read_liquid_level_frd8061(uint8_t sensor_id) {
    // 使用HAL库简化ADC读取
    uint16_t adc_value = HAL_ADC_ReadChannel(ADC_LIQUID_LEVEL_1 + sensor_id);

    // 标准4-20mA转换公式 (与v1文档第149行一致)
    float voltage = (float)adc_value * 3.3f / 32768.0f;  // 15bit ADC
    float current = voltage / 250.0f * 1000.0f;  // mA

    if (current < 4.0f || current > 20.0f) return -1.0f;  // 故障检测

    float level = (current - 4.0f) * 2000.0f / 16.0f;  // mm
    return level;
}

float read_pressure_hp10my(uint8_t sensor_id) {
    // 使用HAL库简化ADC读取
    uint16_t adc_value = HAL_ADC_ReadChannel(ADC_PRESSURE_1 + sensor_id);

    // 标准4-20mA转换公式 (与v1文档第195行一致)
    float voltage = (float)adc_value * 3.3f / 32768.0f;
    float current = voltage / 250.0f * 1000.0f;

    if (current < 3.5f || current > 20.5f) return -999.0f;

    // 压力范围映射 (4mA=-100kPa, 20mA=100MPa)
    float pressure = -100.0f + (current - 4.0f) * (100100.0f / 16.0f);
    return pressure;
}

float read_temperature_ftt518_pt100(uint8_t sensor_id) {
    // 使用HAL库读取PT100三线制信号 (与v1文档第231行一致)
    uint16_t adc_signal = HAL_ADC_ReadChannel(ADC_PT100_SIGNAL_1 + sensor_id);
    uint16_t adc_ref = HAL_ADC_ReadChannel(ADC_PT100_REF_1 + sensor_id);

    const float excitation_current = 0.001f;  // 1mA
    const float reference_resistor = 1000.0f; // 1kΩ

    float voltage_signal = (float)adc_signal * 3.3f / 32768.0f;
    float voltage_ref = (float)adc_ref * 3.3f / 32768.0f;

    // 三线制补偿算法
    float resistance_signal = voltage_signal / excitation_current;
    float wire_resistance = (reference_resistor - voltage_ref / excitation_current) / 2.0f;
    float pt100_resistance = resistance_signal - 2.0f * wire_resistance;

    // PT100电阻-温度转换
    float temperature;
    if (pt100_resistance >= 100.0f) {
        temperature = (pt100_resistance - 100.0f) / (100.0f * 0.003851f);
    } else {
        temperature = (pt100_resistance - 100.0f) / (100.0f * 0.003851f);
    }

    return temperature;
}
```

### 1.1.3 执行器系统保持 (基于第10-16页原始设计)

```c
// 保持原有执行器配置，简化控制实现
typedef struct {
    // MRA-23D3加热器控制 (第10页规格)
    struct {
        char model[16];           // "MRA-23D3"
        uint16_t voltage_rating;  // 220V
        uint16_t power_rating;    // 150W/100W
        uint8_t gpio_pin;         // 控制GPIO
        bool current_state;       // 当前状态
    } heaters[3];  // 3路加热器

    // MPB025BBB调速泵 (第11页规格)
    struct {
        char model[16];           // "MPB025BBB"
        uint16_t voltage_rating;  // 24V
        uint16_t power_rating;    // 25W
        uint16_t speed_min;       // 200 RPM
        uint16_t speed_max;       // 5000 RPM
        uint8_t pwm_channel;      // PWM通道
        uint16_t current_speed;   // 当前转速
    } variable_pumps[2];  // 2路调速泵

    // 电磁阀控制
    struct {
        uint8_t gpio_pin;         // 控制GPIO
        bool current_state;       // 当前状态
    } valves[8];  // 8路电磁阀 (基于第17页IO定义)

} actuator_system_config_t;

// 简化执行器控制 - 使用标准GPIO和PWM库
void control_heater_mra23d3(uint8_t heater_id, bool enable) {
    // 使用HAL库简化GPIO控制
    HAL_GPIO_WritePin(heaters[heater_id].gpio_pin, enable ? GPIO_PIN_SET : GPIO_PIN_RESET);
    heaters[heater_id].current_state = enable;
}

void control_pump_speed_mpb025bbb(uint8_t pump_id, uint16_t target_rpm) {
    // 转速限制检查 (与v1文档第336行一致)
    if (target_rpm < 200) target_rpm = 200;
    if (target_rpm > 5000) target_rpm = 5000;

    // 转速到控制电压的线性转换 (与v1文档第341行一致)
    float control_voltage = 0.2f + (target_rpm - 200.0f) * (4.8f / 4800.0f);

    // 使用HAL库简化PWM输出
    uint16_t pwm_duty = (uint16_t)(control_voltage * 1000.0f / 5.0f); // PWM占空比
    HAL_PWM_SetDutyCycle(variable_pumps[pump_id].pwm_channel, pwm_duty);

    variable_pumps[pump_id].current_speed = target_rpm;
}

void control_valve(uint8_t valve_id, bool open) {
    // 使用HAL库简化GPIO控制
    HAL_GPIO_WritePin(valves[valve_id].gpio_pin, open ? GPIO_PIN_SET : GPIO_PIN_RESET);
    valves[valve_id].current_state = open;
}
```

## 1.2 软件架构简化 (功能保持)

### 1.2.1 基于FreeRTOS的四层架构 (使用成熟RTOS)

```c
// 使用FreeRTOS简化任务管理 (保持v1文档的四层架构概念)
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "semphr.h"

// 应用层任务定义 (保持v1功能，简化实现)
void ApplicationLayer_MainTask(void *pvParameters);      // 主应用任务
void ApplicationLayer_ControlTask(void *pvParameters);   // 控制应用任务
void ApplicationLayer_SensorTask(void *pvParameters);    // 传感器应用任务
void ApplicationLayer_NetworkTask(void *pvParameters);   // 网络应用任务
void ApplicationLayer_HMITask(void *pvParameters);       // 人机界面任务

// 中间件层任务定义
void MiddlewareLayer_EtherCATTask(void *pvParameters);   // EtherCAT中间件任务
void MiddlewareLayer_SafetyTask(void *pvParameters);     // 安全保护中间件任务

// 创建FreeRTOS任务 (简化任务创建)
void create_system_tasks(void) {
    // 应用层任务 (高优先级)
    xTaskCreate(ApplicationLayer_ControlTask, "Control", 512, NULL, 4, NULL);
    xTaskCreate(ApplicationLayer_SensorTask, "Sensor", 512, NULL, 3, NULL);
    xTaskCreate(ApplicationLayer_NetworkTask, "Network", 1024, NULL, 2, NULL);
    xTaskCreate(ApplicationLayer_HMITask, "HMI", 512, NULL, 1, NULL);

    // 中间件层任务 (最高优先级)
    xTaskCreate(MiddlewareLayer_EtherCATTask, "EtherCAT", 512, NULL, 5, NULL);
    xTaskCreate(MiddlewareLayer_SafetyTask, "Safety", 256, NULL, 4, NULL);

    // 启动FreeRTOS调度器
    vTaskStartScheduler();
}
```

---

# 第二章 通信系统保持 (简化实现)

## 2.1 EtherCAT工业总线 (使用现成库)

### 2.1.1 EtherCAT协议栈简化 (功能保持)

```c
// 使用现成EtherCAT库，保持v1文档第548页的硬件配置
#include "ethercat_stack.h"  // 假设使用开源EtherCAT库

// 保持v1文档的EtherCAT配置 (第554行)
typedef struct {
    char controller_model[16]; // "GDSCN832R2U6"
    uint8_t port_count;        // 2 (双端口)
    uint32_t baudrate;         // 100Mbps
    bool hardware_realtime;    // true
    bool distributed_clock;    // true
    uint16_t sync_period;      // 1ms
    uint16_t process_data_size; // 64bytes
} ethercat_config_simple_t;

// 保持v1文档的过程数据定义 (第569行)
typedef struct {
    // 完全保持v1文档的数据结构
    union {
        uint8_t digital_input_bytes[8];
        struct {
            bool ink_tank_level_1 : 1;      // I0.0
            bool ink_tank_level_2 : 1;      // I0.1
            bool waste_tank_level : 1;      // I0.2
            bool cartridge_level_1 : 1;     // I0.3
            bool cartridge_level_2 : 1;     // I0.4
            bool reserved_input_5 : 1;      // I0.5
            bool reserved_input_6 : 1;      // I0.6
            bool reserved_input_7 : 1;      // I0.7
        } digital_inputs;
    };

    uint16_t analog_inputs[6];    // IW1-IW6: 压力、液位模拟量
    uint16_t temperature_inputs[2]; // T10-T11: PT100温度

    union {
        uint8_t digital_output_bytes[8];
        struct {
            bool ink_pump_start : 1;        // Q0.0
            bool return_pump_start : 1;     // Q0.1
            bool recycle_valve_open : 1;    // Q0.2
            bool cartridge_heater : 1;      // Q0.3
            bool line_heater : 1;           // Q0.4
            bool water_supply_valve : 1;    // Q0.5
            bool waste_ink_valve : 1;       // Q0.6
            bool tank_ink_valve : 1;        // Q0.7
        } digital_outputs;
    };

    uint16_t analog_outputs[4];   // QW1-QW4: 泵速调节输出
    uint16_t system_status;       // 系统状态字
    uint16_t fault_code;          // 故障代码
} ethercat_process_data_t;

// 简化EtherCAT任务实现 (使用现成库)
void MiddlewareLayer_EtherCATTask(void *pvParameters) {
    static ethercat_process_data_t process_data;
    TickType_t xLastWakeTime;

    // EtherCAT库初始化
    EtherCAT_Initialize();
    EtherCAT_SetSlaveAddress(1);  // 从站地址

    xLastWakeTime = xTaskGetTickCount();

    while(1) {
        // 1ms严格周期 (保持v1文档第914行的实时性要求)
        vTaskDelayUntil(&xLastWakeTime, pdMS_TO_TICKS(1));

        // 使用库函数简化数据交换
        EtherCAT_ReadInputs(&process_data);

        // 更新传感器数据到EtherCAT输入
        process_data.analog_inputs[0] = (uint16_t)(current_pressure_1 * 10);
        process_data.analog_inputs[1] = (uint16_t)(current_pressure_2 * 10);
        process_data.analog_inputs[2] = (uint16_t)(current_liquid_level_1 * 10);
        process_data.analog_inputs[3] = (uint16_t)(current_liquid_level_2 * 10);
        process_data.temperature_inputs[0] = (uint16_t)(current_temperature_1 * 10);
        process_data.temperature_inputs[1] = (uint16_t)(current_temperature_2 * 10);

        // 从EtherCAT输出更新执行器
        control_heater_mra23d3(0, process_data.digital_outputs.cartridge_heater);
        control_heater_mra23d3(1, process_data.digital_outputs.line_heater);
        control_pump_speed_mpb025bbb(0, process_data.analog_outputs[0]);
        control_pump_speed_mpb025bbb(1, process_data.analog_outputs[1]);

        EtherCAT_WriteOutputs(&process_data);
    }
}
```

## 2.2 TCP/IP网络通信 (使用lwip)

### 2.2.1 基于lwip的网络实现 (保持v1功能)

```c
// 使用lwip简化TCP/IP实现，保持v1文档第616页的组网功能
#include "lwip/opt.h"
#include "lwip/arch.h"
#include "lwip/api.h"
#include "lwip/inet.h"
#include "lwip/sockets.h"

// 保持v1文档的网络配置结构 (第621行)
typedef struct {
    uint32_t controller_ip;       // 控制器IP地址
    uint32_t host_ip;            // 上位机IP地址
    uint16_t communication_port; // 通信端口 (默认502)
    uint16_t heartbeat_interval; // 心跳间隔 (ms)
    uint8_t connection_timeout;  // 连接超时 (s)
} network_config_t;

// 简化TCP服务器实现 (使用lwip API)
void ApplicationLayer_NetworkTask(void *pvParameters) {
    struct netconn *conn, *newconn;
    err_t err;

    // 创建TCP连接结构
    conn = netconn_new(NETCONN_TCP);
    if (conn == NULL) {
        vTaskDelete(NULL);
        return;
    }

    // 绑定端口 (保持v1文档的502端口)
    err = netconn_bind(conn, IP_ADDR_ANY, 502);
    if (err != ERR_OK) {
        netconn_delete(conn);
        vTaskDelete(NULL);
        return;
    }

    // 开始监听
    err = netconn_listen(conn);
    if (err != ERR_OK) {
        netconn_delete(conn);
        vTaskDelete(NULL);
        return;
    }

    while (1) {
        // 等待新连接
        err = netconn_accept(conn, &newconn);
        if (err == ERR_OK) {
            // 处理客户端连接
            handle_client_connection(newconn);
            netconn_close(newconn);
            netconn_delete(newconn);
        }

        vTaskDelay(pdMS_TO_TICKS(10));
    }
}

// 处理客户端数据 (保持v1文档的数据格式)
void handle_client_connection(struct netconn *conn) {
    struct netbuf *buf;
    char *data;
    u16_t len;
    char response[512];

    // 接收数据
    if (netconn_recv(conn, &buf) == ERR_OK) {
        netbuf_data(buf, (void**)&data, &len);

        // 构造响应数据 (JSON格式，保持v1功能)
        snprintf(response, sizeof(response),
            "{"
            "\"temperature\":[%.2f,%.2f,%.2f],"
            "\"pressure\":[%.2f,%.2f],"
            "\"liquid_level\":[%.2f,%.2f],"
            "\"heater_status\":[%d,%d,%d],"
            "\"pump_speed\":[%d,%d],"
            "\"valve_status\":%d,"
            "\"system_status\":%d,"
            "\"fault_code\":%d,"
            "\"timestamp\":%u"
            "}",
            current_temperature[0], current_temperature[1], current_temperature[2],
            current_pressure[0], current_pressure[1],
            current_liquid_level[0], current_liquid_level[1],
            heater_status[0], heater_status[1], heater_status[2],
            pump_speed[0], pump_speed[1],
            valve_status_word,
            system_status,
            current_fault_code,
            (uint32_t)xTaskGetTickCount()
        );

        // 发送响应
        netconn_write(conn, response, strlen(response), NETCONN_COPY);

        netbuf_delete(buf);
    }
}
```

---

# 第三章 显示与LED系统保持

## 3.1 LCD显示系统保持 (CH12832B-12)

### 3.1.1 保持v1文档的显示配置 (第476页)

```c
// 完全保持v1文档的显示配置
typedef struct {
    char model[16];           // "CH12832B-12"
    uint8_t resolution_x;     // 128 (像素宽度)
    uint8_t resolution_y;     // 32 (像素高度)
    uint8_t interface_type;   // SPI接口
    uint8_t supply_voltage;   // 3.3V
    uint16_t refresh_rate;    // 60Hz
    bool backlight_control;   // true
} lcd_display_spec_t;

// 使用现成驱动库简化显示实现
#include "ch12832b_driver.h"  // 假设使用现成LCD驱动

// 保持v1文档的显示页面定义 (第497行)
typedef enum {
    DISPLAY_PAGE_MAIN = 0,      // 主页面 - 系统状态总览
    DISPLAY_PAGE_SENSOR,        // 传感器数据页面
    DISPLAY_PAGE_ACTUATOR,      // 执行器状态页面
    DISPLAY_PAGE_NETWORK,       // 网络信息页面
    DISPLAY_PAGE_FAULT,         // 故障信息页面
    DISPLAY_PAGE_CONFIG,        // 配置参数页面
    DISPLAY_PAGE_IO_STATUS,     // IO状态页面
    DISPLAY_PAGE_MAX
} display_page_t;

// 简化HMI任务实现 (使用现成库，去除按键)
void ApplicationLayer_HMITask(void *pvParameters) {
    static uint8_t current_page = DISPLAY_PAGE_MAIN;
    static uint32_t auto_switch_counter = 0;

    // 初始化LCD (使用现成驱动)
    CH12832B_Initialize();
    CH12832B_SetBacklight(true);

    while(1) {
        // 自动切换页面 (去除按键，改为自动循环显示)
        auto_switch_counter++;
        if (auto_switch_counter >= 30) {  // 3秒切换一次页面
            auto_switch_counter = 0;
            current_page = (current_page + 1) % DISPLAY_PAGE_MAX;
        }

        // 根据当前页面显示内容
        switch(current_page) {
            case DISPLAY_PAGE_MAIN:
                display_main_page();      // 保持v1文档第509行的主页面内容
                break;
            case DISPLAY_PAGE_SENSOR:
                display_sensor_page();    // 保持v1文档第527行的传感器页面
                break;
            case DISPLAY_PAGE_ACTUATOR:
                display_actuator_page();
                break;
            case DISPLAY_PAGE_NETWORK:
                display_network_page();
                break;
            case DISPLAY_PAGE_FAULT:
                display_fault_page();
                break;
            case DISPLAY_PAGE_CONFIG:
                display_config_page();
                break;
            case DISPLAY_PAGE_IO_STATUS:
                display_io_status_page();
                break;
        }

        vTaskDelay(pdMS_TO_TICKS(100));  // 100ms刷新
    }
}

// 保持v1文档的主页面显示 (第509行)
void display_main_page(void) {
    char title[32], line1[32], line2[32], line3[32];

    snprintf(title, sizeof(title), "UV Ink Service V1.0");
    snprintf(line1, sizeof(line1), "T:%.1f°C P:%.1fkPa",
             current_temperature[0], current_pressure[0]);
    snprintf(line2, sizeof(line2), "Level:%.1f%% Flow:%.1f",
             current_liquid_level[0], current_flow_rate);
    snprintf(line3, sizeof(line3), "Sys:%s Net:%s",
             get_system_status_string(), get_network_status_string());

    // 使用驱动库显示
    CH12832B_Clear();
    CH12832B_ShowString(0, 0, title, 8);
    CH12832B_ShowString(0, 8, line1, 8);
    CH12832B_ShowString(0, 16, line2, 8);
    CH12832B_ShowString(0, 24, line3, 8);
    CH12832B_Refresh();
}

// 保持v1文档的传感器页面显示 (第527行)
void display_sensor_page(void) {
    char title[32], line1[32], line2[32], line3[32];

    snprintf(title, sizeof(title), "Sensor Data");
    snprintf(line1, sizeof(line1), "T1:%.1f T2:%.1f T3:%.1f",
             current_temperature[0], current_temperature[1], current_temperature[2]);
    snprintf(line2, sizeof(line2), "P1:%.2f P2:%.2f kPa",
             current_pressure[0], current_pressure[1]);
    snprintf(line3, sizeof(line3), "L1:%.1f%% L2:%.1f%%",
             current_liquid_level[0], current_liquid_level[1]);

    CH12832B_Clear();
    CH12832B_ShowString(0, 0, title, 8);
    CH12832B_ShowString(0, 8, line1, 8);
    CH12832B_ShowString(0, 16, line2, 8);
    CH12832B_ShowString(0, 24, line3, 8);
    CH12832B_Refresh();
}
```

## 3.2 LED指示系统保持 (5路LED)

### 3.2.1 完全保持v1文档的LED配置 (第359页)

```c
// 完全保持v1文档的LED功能定义 (第367行)
typedef enum {
    LED_POWER_INDICATOR = 0,     // 电源指示灯 (红色)
    LED_NETWORK_STATUS,          // 网络状态灯 (绿色)
    LED_SYSTEM_RUNNING,          // 系统运行灯 (黄色)
    LED_COMMUNICATION,           // 通信状态灯 (蓝色)
    LED_FAULT_ALARM,            // 故障报警灯 (白色)
    LED_MAX_COUNT
} led_function_t;

// 保持v1文档的LED状态规则 (第392行)
void led_manager_task_simplified(void) {
    static uint32_t blink_counter = 0;
    blink_counter++;

    // 电源指示灯 - 系统正常时常亮
    HAL_GPIO_WritePin(LED_POWER_PIN, system_power_ok ? GPIO_PIN_SET : GPIO_PIN_RESET);

    // 网络状态灯 - 根据网络连接状态
    if (network_connected) {
        HAL_GPIO_WritePin(LED_NETWORK_PIN, GPIO_PIN_SET);  // 连接时常亮
    } else if (network_connecting) {
        // 连接中时1Hz闪烁
        HAL_GPIO_WritePin(LED_NETWORK_PIN, (blink_counter % 500) < 250 ? GPIO_PIN_SET : GPIO_PIN_RESET);
    } else {
        HAL_GPIO_WritePin(LED_NETWORK_PIN, GPIO_PIN_RESET);  // 断开时熄灭
    }

    // 系统运行灯 - 正常时1Hz闪烁
    if (system_status == SYSTEM_NORMAL) {
        HAL_GPIO_WritePin(LED_SYSTEM_PIN, (blink_counter % 500) < 250 ? GPIO_PIN_SET : GPIO_PIN_RESET);
    } else {
        HAL_GPIO_WritePin(LED_SYSTEM_PIN, GPIO_PIN_RESET);
    }

    // 通信状态灯 - EtherCAT活动时常亮
    HAL_GPIO_WritePin(LED_COMMUNICATION_PIN, ethercat_active ? GPIO_PIN_SET : GPIO_PIN_RESET);

    // 故障报警灯 - 有故障时常亮
    HAL_GPIO_WritePin(LED_FAULT_PIN, (current_fault_code != FAULT_NONE) ? GPIO_PIN_SET : GPIO_PIN_RESET);
}
```

---

# 第四章 控制算法简化 (功能保持)

## 4.1 温度控制保持 (简化PID实现)

### 4.1.1 保持PID控制功能，简化算法实现

```c
// 保持v1文档的PID控制结构 (第278行)，简化实现
typedef struct {
    float kp, ki, kd;         // PID参数 (保持)
    float setpoint;           // 目标温度 (保持)
    float last_error;         // 上次误差
    float integral;           // 积分累积
    uint32_t last_time;       // 上次计算时间
} pid_controller_simple_t;

// 简化PID控制算法 (保持v1功能，简化实现)
float simple_pid_control(pid_controller_simple_t *pid, float current_temp) {
    uint32_t current_time = xTaskGetTickCount() * portTICK_PERIOD_MS;
    float dt = (current_time - pid->last_time) / 1000.0f;

    if (dt <= 0.0f) return 0.0f;

    // 简化PID计算 (保持v1文档第294行的基本算法)
    float error = pid->setpoint - current_temp;
    pid->integral += error * dt;

    // 积分限幅 (保持v1文档第298行的防饱和)
    if (pid->integral > 100.0f) pid->integral = 100.0f;
    if (pid->integral < -100.0f) pid->integral = -100.0f;

    float derivative = (error - pid->last_error) / dt;
    float output = pid->kp * error + pid->ki * pid->integral + pid->kd * derivative;

    // 输出限制 (保持v1文档第306行的限制)
    if (output > 100.0f) output = 100.0f;
    if (output < 0.0f) output = 0.0f;

    pid->last_error = error;
    pid->last_time = current_time;

    return output;
}

// 控制任务实现 (保持v1功能)
void ApplicationLayer_ControlTask(void *pvParameters) {
    static pid_controller_simple_t temp_pid[3] = {
        {2.0f, 0.1f, 0.5f, 50.0f, 0, 0, 0},  // 温度控制器1
        {2.0f, 0.1f, 0.5f, 60.0f, 0, 0, 0},  // 温度控制器2
        {2.0f, 0.1f, 0.5f, 55.0f, 0, 0, 0},  // 温度控制器3
    };

    while(1) {
        // 温度控制循环 (保持v1文档的3路温度控制)
        for(int i = 0; i < 3; i++) {
            float pid_output = simple_pid_control(&temp_pid[i], current_temperature[i]);

            // 转换为加热器控制信号 (简化实现)
            bool heater_on = (pid_output > 50.0f);  // 简单开关控制
            control_heater_mra23d3(i, heater_on);
        }

        // 压力控制 (简化实现，保持功能)
        for(int i = 0; i < 2; i++) {
            float pressure_error = target_pressure[i] - current_pressure[i];
            if (pressure_error > 50.0f) {
                // 压力低，增加泵速
                uint16_t new_speed = pump_speed[i] + 100;
                if (new_speed > 5000) new_speed = 5000;
                control_pump_speed_mpb025bbb(i, new_speed);
            } else if (pressure_error < -50.0f) {
                // 压力高，降低泵速
                uint16_t new_speed = pump_speed[i] - 100;
                if (new_speed < 200) new_speed = 200;
                control_pump_speed_mpb025bbb(i, new_speed);
            }
        }

        // 液位管理 (保持v1功能)
        for(int i = 0; i < 2; i++) {
            if (current_liquid_level[i] < 20.0f) {
                // 液位低，开启供墨阀
                control_valve(VALVE_INK_SUPPLY_1 + i, true);
            } else if (current_liquid_level[i] > 80.0f) {
                // 液位高，关闭供墨阀
                control_valve(VALVE_INK_SUPPLY_1 + i, false);
            }
        }

        vTaskDelay(pdMS_TO_TICKS(100));  // 100ms控制周期
    }
}
```

---

# 第五章 配置管理保持 (简化存储)

## 5.1 完全保持v1文档的配置结构

### 5.1.1 保持v1文档的完整配置参数 (第747页)

```c
// 完全保持v1文档的配置结构，简化存储实现
typedef struct {
    // 保持v1文档的配置文件头部信息 (第750行)
    uint32_t config_version;        // 配置版本号
    uint32_t config_size;           // 配置数据大小
    uint32_t config_crc32;          // CRC32校验值
    char device_serial[32];         // 设备序列号

    // 保持v1文档的网络配置 (第756行)
    struct {
        uint32_t ip_address;        // IP地址
        uint32_t subnet_mask;       // 子网掩码
        uint32_t gateway_address;   // 网关地址
        uint16_t tcp_port;          // TCP通信端口
        uint8_t ethercat_slave_id;  // EtherCAT从站ID
        uint16_t heartbeat_interval; // 心跳间隔 (ms)
    } network_config;

    // 保持v1文档的控制参数配置 (第767行)
    struct {
        float temp_pid_kp[3];       // 温度PID比例系数 (3路)
        float temp_pid_ki[3];       // 温度PID积分系数
        float temp_pid_kd[3];       // 温度PID微分系数
        float temp_target[3];       // 目标温度 (°C)
        float temp_alarm_high[3];   // 温度上限报警 (°C)
        float temp_alarm_low[3];    // 温度下限报警 (°C)

        float pressure_pid_kp[2];   // 压力PID比例系数 (2路)
        float pressure_pid_ki[2];   // 压力PID积分系数
        float pressure_pid_kd[2];   // 压力PID微分系数
        float pressure_target[2];   // 目标压力 (kPa)
        float pressure_alarm_high[2]; // 压力上限报警
        float pressure_alarm_low[2];  // 压力下限报警

        float level_target[2];      // 目标液位 (%)
        float level_alarm_high[2];  // 液位上限报警 (%)
        float level_alarm_low[2];   // 液位下限报警 (%)
    } control_config;

    // 保持v1文档的传感器校准参数 (第790行)
    struct {
        float temp_sensor_offset[3];    // 温度传感器偏移量 (°C)
        float temp_sensor_scale[3];     // 温度传感器缩放系数
        float temp_wire_resistance[3];  // 导线电阻补偿 (Ω)

        float pressure_sensor_offset[2]; // 压力传感器偏移量 (kPa)
        float pressure_sensor_scale[2];  // 压力传感器缩放系数
        float pressure_zero_point[2];    // 压力零点校准 (mA)

        float level_sensor_offset[2];   // 液位传感器偏移量 (%)
        float level_sensor_scale[2];    // 液位传感器缩放系数
        float level_zero_point[2];      // 液位零点校准 (mA)
    } calibration_config;

    // 保持v1文档的系统运行参数 (第808行)
    struct {
        uint16_t adc_sample_period;     // ADC采样周期 (ms)
        uint16_t control_loop_period;   // 控制回路周期 (ms)
        uint16_t communication_period;  // 通信周期 (ms)
        uint8_t led_brightness;         // LED亮度 (0-100%)
        bool enable_display;            // 使能LCD显示
        bool enable_logging;            // 使能日志记录
        bool enable_auto_tuning;        // 使能PID自整定
        uint8_t system_language;        // 系统语言 (0=中文, 1=英文)
    } system_config;

    // 保持v1文档的安全保护参数 (第820行)
    struct {
        uint16_t watchdog_timeout;      // 看门狗超时时间 (ms)
        float over_temp_threshold;      // 过温保护阈值 (°C)
        float over_pressure_threshold;  // 过压保护阈值 (kPa)
        float under_voltage_threshold;  // 欠压保护阈值 (V)
        bool enable_emergency_stop;     // 使能紧急停止
        uint16_t fault_recovery_delay;  // 故障恢复延时 (s)
    } safety_config;

} system_config_complete_t;

// 简化配置存储实现 (使用HAL库)
bool config_save_simplified(const system_config_complete_t *config) {
    // 使用HAL库简化Flash操作
    HAL_FLASH_Unlock();

    // 擦除配置扇区
    FLASH_EraseInitTypeDef EraseInitStruct;
    EraseInitStruct.TypeErase = FLASH_TYPEERASE_SECTORS;
    EraseInitStruct.Sector = CONFIG_FLASH_SECTOR;
    EraseInitStruct.NbSectors = 1;
    EraseInitStruct.VoltageRange = FLASH_VOLTAGE_RANGE_3;

    uint32_t SectorError;
    HAL_FLASHEx_Erase(&EraseInitStruct, &SectorError);

    // 写入配置数据
    uint32_t *data = (uint32_t*)config;
    uint32_t addr = CONFIG_FLASH_ADDRESS;

    for(int i = 0; i < sizeof(system_config_complete_t)/4; i++) {
        HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, addr, data[i]);
        addr += 4;
    }

    HAL_FLASH_Lock();
    return true;
}

bool config_load_simplified(system_config_complete_t *config) {
    // 使用HAL库简化Flash读取
    uint32_t *flash_data = (uint32_t*)CONFIG_FLASH_ADDRESS;
    uint32_t *config_data = (uint32_t*)config;

    for(int i = 0; i < sizeof(system_config_complete_t)/4; i++) {
        config_data[i] = flash_data[i];
    }

    // 简化验证 (检查版本号)
    if(config->config_version != EXPECTED_CONFIG_VERSION) {
        // 加载默认配置
        load_default_config(config);
        config_save_simplified(config);
    }

    return true;
}
```

---

# 第六章 安全保护保持 (简化实现)

## 6.1 完全保持v1文档的安全功能

### 6.1.1 保持v1文档的故障代码 (第703页)

```c
// 完全保持v1文档的故障代码定义 (第703行)
typedef enum {
    FAULT_NONE = 0x0000,

    // 传感器故障 (0x1000系列) - 保持
    FAULT_TEMP_SENSOR_1_OPEN    = 0x1001,  // 温度传感器1开路
    FAULT_TEMP_SENSOR_1_SHORT   = 0x1002,  // 温度传感器1短路
    FAULT_PRESSURE_SENSOR_1_FAULT = 0x1011, // 压力传感器1故障
    FAULT_PRESSURE_SENSOR_2_FAULT = 0x1012, // 压力传感器2故障
    FAULT_LIQUID_LEVEL_1_FAULT  = 0x1021,  // 液位传感器1故障
    FAULT_LIQUID_LEVEL_2_FAULT  = 0x1022,  // 液位传感器2故障

    // 执行器故障 (0x2000系列) - 保持
    FAULT_HEATER_1_OPEN         = 0x2001,  // 加热器1开路
    FAULT_HEATER_2_OPEN         = 0x2002,  // 加热器2开路
    FAULT_PUMP_1_OVERCURRENT    = 0x2011,  // 泵1过流
    FAULT_PUMP_2_OVERCURRENT    = 0x2012,  // 泵2过流
    FAULT_VALVE_1_FAULT         = 0x2021,  // 电磁阀1故障
    FAULT_VALVE_2_FAULT         = 0x2022,  // 电磁阀2故障

    // 系统故障 (0x3000系列) - 保持
    FAULT_POWER_VOLTAGE_LOW     = 0x3001,  // 电源电压低
    FAULT_POWER_VOLTAGE_HIGH    = 0x3002,  // 电源电压高
    FAULT_MCU_OVERTEMPERATURE   = 0x3003,  // MCU过温
    FAULT_MEMORY_ERROR          = 0x3004,  // 内存错误
    FAULT_WATCHDOG_RESET        = 0x3005,  // 看门狗复位

    // 通信故障 (0x4000系列) - 保持
    FAULT_ETHERCAT_DISCONNECTED = 0x4001,  // EtherCAT断开
    FAULT_ETHERNET_LINK_DOWN    = 0x4002,  // 以太网链路断开
    FAULT_COMMUNICATION_TIMEOUT = 0x4003,  // 通信超时
    FAULT_PROTOCOL_ERROR        = 0x4004,  // 协议错误

    FAULT_MAX_CODE              = 0xFFFF
} fault_code_t;

// 简化安全监控任务 (保持v1功能)
void MiddlewareLayer_SafetyTask(void *pvParameters) {
    uint32_t fault_status = FAULT_NONE;

    while(1) {
        // 温度保护检查 (保持v1文档第1073行的检查逻辑)
        for (int i = 0; i < 3; i++) {
            float temp = current_temperature[i];
            if (temp > 650.0f) {
                fault_status |= (FAULT_TEMP_SENSOR_1_OPEN + i);
                // 立即关闭加热器 (保持v1文档第1077行的保护动作)
                control_heater_mra23d3(i, false);
            } else if (temp < -50.0f) {
                fault_status |= (FAULT_TEMP_SENSOR_1_SHORT + i);
            }
        }

        // 压力保护检查 (保持v1文档第1084行的检查逻辑)
        for (int i = 0; i < 2; i++) {
            float pressure = current_pressure[i];
            if (pressure > 110000.0f || pressure < -110.0f) {
                fault_status |= (FAULT_PRESSURE_SENSOR_1_FAULT + i);
                // 停止泵运行 (保持v1文档第1089行的保护动作)
                control_pump_speed_mpb025bbb(i, 0);
            }
        }

        // 电源监控 (保持v1文档第1096行的监控)
        float voltage_24v = read_supply_voltage_24v();  // 使用ADC读取
        if (voltage_24v < 21.6f || voltage_24v > 26.4f) {
            fault_status |= FAULT_POWER_VOLTAGE_LOW;
        }

        // 通信监控 (保持v1文档第1103行的监控)
        if (ethercat_connection_lost() || tcp_connection_timeout()) {
            fault_status |= FAULT_COMMUNICATION_TIMEOUT;
        }

        // 更新全局故障状态
        current_fault_code = fault_status;

        // 严重故障时执行紧急停机 (保持v1文档第1152行的处理)
        if (fault_status & 0x3000) {  // 系统故障类
            execute_emergency_shutdown_simplified();
        }

        vTaskDelay(pdMS_TO_TICKS(100));  // 100ms安全检查周期
    }
}

// 简化紧急停机 (保持v1文档第1152行的功能)
void execute_emergency_shutdown_simplified(void) {
    // 立即关闭所有加热器 (保持v1文档第1154行)
    for(int i = 0; i < 3; i++) {
        control_heater_mra23d3(i, false);
    }

    // 停止所有泵运行 (保持v1文档第1159行)
    for(int i = 0; i < 2; i++) {
        control_pump_speed_mpb025bbb(i, 0);
    }

    // 关闭所有电磁阀 (保持v1文档第1166行)
    for(int i = 0; i < 8; i++) {
        control_valve(i, false);
    }

    // 激活故障指示LED (保持v1文档第1171行)
    HAL_GPIO_WritePin(LED_FAULT_PIN, GPIO_PIN_SET);

    // 发送故障通报 (保持v1文档第1178行)
    send_fault_notification_to_host();
}
```

---

# 第七章 简化目录结构 (功能保持)

## 7.1 基于成熟工具的目录结构

```
ink_supply_system_6weeks/
├── src/                                    # 源代码目录
│   ├── main.c                             # 主程序入口
│   │
│   ├── application/                       # 应用层 (保持v1全功能)
│   │   ├── control_app.c/h                # 控制应用 (PID控制等)
│   │   ├── sensor_app.c/h                 # 传感器应用 (3种传感器)
│   │   ├── actuator_app.c/h               # 执行器应用 (加热器+泵+阀)
│   │   ├── network_app.c/h                # 网络应用 (EtherCAT+TCP)
│   │   ├── hmi_app.c/h                    # 人机界面 (LCD+LED)
│   │   ├── safety_app.c/h                 # 安全应用 (保护逻辑)
│   │   └── config_app.c/h                 # 配置应用 (参数管理)
│   │
│   ├── middleware/                        # 中间件层 (使用现成库)
│   │   ├── ethercat_stack/                # EtherCAT协议栈 (第三方库)
│   │   ├── lwip_port/                     # lwip移植层
│   │   ├── freertos_config/               # FreeRTOS配置
│   │   ├── digital_filter.c/h             # 数字滤波算法
│   │   └── pid_controller.c/h             # PID控制器
│   │
│   ├── hal/                               # 硬件抽象层 (使用HAL库)
│   │   ├── adc_hal.c/h                    # ADC HAL (传感器采集)
│   │   ├── gpio_hal.c/h                   # GPIO HAL (数字IO)
│   │   ├── pwm_hal.c/h                    # PWM HAL (泵调速)
│   │   ├── spi_hal.c/h                    # SPI HAL (LCD通信)
│   │   ├── eth_hal.c/h                    # 以太网HAL
│   │   └── flash_hal.c/h                  # Flash HAL (配置存储)
│   │
│   └── drivers/                           # 设备驱动 (使用现成驱动)
│       ├── ch12832b_lcd.c/h               # LCD驱动 (现成库)
│       ├── w5500_eth.c/h                  # 以太网芯片驱动
│       └── sensor_drivers.c/h             # 传感器驱动合集
│
├── lib/                                   # 第三方库 (现成库)
│   ├── GD32F4xx_HAL_Driver/               # GD32 HAL库 (官方)
│   ├── CMSIS/                             # ARM CMSIS库 (官方)
│   ├── FreeRTOS/                          # FreeRTOS (官方)
│   ├── lwip/                              # lwip TCP/IP库 (官方)
│   ├── EtherCAT_Slave_Stack/              # EtherCAT从站库 (开源)
│   └── LCD_Drivers/                       # LCD驱动库合集
│
├── config/                                # 配置文件
│   ├── FreeRTOSConfig.h                   # FreeRTOS配置
│   ├── lwipopts.h                         # lwip配置
│   ├── ethercat_config.h                  # EtherCAT配置
│   └── system_config.h                    # 系统配置
│
├── docs/                                  # 设计文档
│   ├── v1_original_design.md              # 原始v1设计文档
│   ├── simplification_guide.md            # 简化实现指南
│   └── 6week_development_plan.md          # 6周开发计划
│
├── tools/                                 # 开发工具
│   ├── cubemx_project/                    # STM32CubeMX项目 (代码生成)
│   ├── config_tool/                       # 配置工具
│   └── test_scripts/                      # 测试脚本
│
├── build/                                 # 构建输出
├── CMakeLists.txt                         # CMake配置 (现代构建)
├── Makefile                               # 传统Makefile
├── README.md                              # 项目说明
└── .gitignore                             # Git忽略文件
```

---

# 第八章 6周开发计划 (功能不变)

## 8.1 基于现成库的快速开发计划

### 第1周: 平台搭建 + 基础库集成
- **Day 1-2**: GD32F427开发板采购，开发环境搭建
- **Day 3-4**: FreeRTOS + HAL库集成，基础任务运行
- **Day 5-7**: lwip网络库集成，基础网络功能测试

### 第2周: 传感器系统集成 (保持v1全功能)
- **Day 1-2**: 4-20mA传感器ADC采集 (FRD-8061液位 + HP10MY压力)
- **Day 3-4**: PT100温度传感器三线制驱动 (FTT518)
- **Day 5-7**: 传感器数据处理和校准 (保持v1精度要求)

### 第3周: 执行器控制系统 (保持v1全功能)
- **Day 1-2**: MRA-23D3加热器继电器控制 (3路)
- **Day 3-4**: MPB025BBB调速泵PWM控制 (2路)
- **Day 5-7**: 电磁阀控制 + PID控制算法实现

### 第4周: 通信系统集成 (保持v1双协议)
- **Day 1-3**: EtherCAT从站库集成，硬件通信测试
- **Day 4-5**: TCP/IP服务器实现 (基于lwip)
- **Day 6-7**: 双协议数据同步，网络组网测试

### 第5周: HMI + 安全系统 (保持v1全功能)
- **Day 1-2**: CH12832B-12 LCD显示系统 (7个页面)
- **Day 3-4**: 5路LED状态指示系统
- **Day 5-7**: 安全保护和故障诊断系统

### 第6周: 配置管理 + 系统集成测试
- **Day 1-2**: 完整配置管理和Flash存储
- **Day 3-4**: 系统集成测试，性能调优
- **Day 5-7**: 完整功能测试，文档整理

## 8.2 关键成功因素

### 使用现成库降低开发量
🔸 **FreeRTOS**: 任务调度现成解决方案，无需自己实现
🔸 **lwip**: TCP/IP协议栈现成库，大幅减少网络代码
🔸 **EtherCAT库**: 使用开源EtherCAT从站库，避免协议开发
🔸 **HAL库**: GD32官方HAL库，简化底层硬件操作
🔸 **驱动库**: LCD、传感器等使用现成驱动库

### 功能分解并行开发
🔸 **模块化**: 各功能模块独立开发，最后集成
🔸 **接口标准化**: 使用标准接口，降低模块间耦合
🔸 **渐进集成**: 逐步集成功能，及时发现问题

### 测试驱动开发
🔸 **单元测试**: 每个模块独立测试验证
🔸 **集成测试**: 模块组合功能测试
🔸 **系统测试**: 完整系统功能验证

## 8.3 风险控制

### 技术风险
- **EtherCAT复杂度**: 使用成熟开源库降低风险
- **实时性要求**: FreeRTOS保证任务调度实时性
- **硬件兼容性**: 使用官方HAL库保证兼容性

### 进度风险
- **功能裁剪备案**: 如进度紧张，优先保证核心功能
- **并行开发**: 多个模块同时开发，提高效率
- **里程碑检查**: 每周末进行进度检查和调整

---

# 总结

## 与v1文档的关系

### 功能完全保持 ✅
1. **传感器系统**: FRD-8061、HP10MY、FTT518 - 完全保持
2. **执行器系统**: MRA-23D3、MPB025BBB、电磁阀控制 - 完全保持
3. **通信系统**: EtherCAT + TCP/IP双协议 - 完全保持
4. **显示系统**: CH12832B-12 LCD + 5路LED - 完全保持
5. **控制算法**: PID控制、安全保护 - 功能保持，实现简化
6. **配置管理**: 完整参数配置和存储 - 完全保持
7. **IO功能**: 第17页完整IO映射 - 完全保持

### 实现方式简化 🚀
1. **使用FreeRTOS**: 替代自己实现任务调度器
2. **使用lwip**: 替代自己实现TCP/IP协议栈
3. **使用EtherCAT库**: 替代自己开发EtherCAT协议
4. **使用HAL库**: 替代直接寄存器操作
5. **使用现成驱动**: LCD、传感器等使用现成库
6. **去除按键**: HMI改为自动循环显示，降低交互复杂度
7. **算法简化**: PID等算法使用简单可靠实现

### 开发优势 💪
- **时间可控**: 6周完成，现成库大幅减少代码量
- **功能完整**: 保持v1文档的所有功能需求
- **质量可靠**: 使用成熟库，提高系统稳定性
- **易于维护**: 标准化接口，降低维护复杂度
- **技术现代**: 使用现代开发工具和方法

## 适用场景
- 保持原有功能需求的快速开发
- 工业级供墨控制系统原型开发
- 基于成熟技术栈的可靠实现
- 6周时间约束下的完整系统开发

本简化版本在**功能需求完全不变**的前提下，通过使用成熟的开源库和工具，将开发复杂度降低到个人6周可完成的水平，是一个现实可行的实现方案。

---

**文档版本**: V2.0 (需求不变简化实现版)
**创建日期**: 2025-09-27
**基础文档**: 供墨系统控制板卡综合技术设计文档(分层版)v1
**功能保持**: 100% (所有v1功能需求完全保持)
**实现简化**: 使用FreeRTOS + lwip + EtherCAT库 + HAL库
**开发周期**: 6周 (个人开发可行)
**技术风险**: 低 (基于成熟库和工具)