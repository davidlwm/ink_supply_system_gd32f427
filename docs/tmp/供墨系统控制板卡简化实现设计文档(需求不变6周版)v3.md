# ä¾›å¢¨ç³»ç»Ÿæ§åˆ¶æ¿å¡ç®€åŒ–å®ç°è®¾è®¡æ–‡æ¡£ (éœ€æ±‚ä¸å˜6å‘¨ç‰ˆ) v2

## æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£åŸºäºã€Šä¾›å¢¨ç³»ç»Ÿæ§åˆ¶æ¿å¡ç»¼åˆæŠ€æœ¯è®¾è®¡æ–‡æ¡£(åˆ†å±‚ç‰ˆ)v1ã€‹ï¼Œ**ä¿æŒæ‰€æœ‰åŠŸèƒ½éœ€æ±‚ä¸å˜**ï¼Œé€šè¿‡ç®€åŒ–å®ç°æ–¹æ¡ˆæ¥é™ä½å¼€å‘å¤æ‚åº¦ï¼Œé€‚åˆä¸ªäººå¼€å‘è€…åœ¨6å‘¨å†…å®Œæˆã€‚æ‰€æœ‰v1æ–‡æ¡£ä¸­çš„ä¼ æ„Ÿå™¨ã€æ‰§è¡Œå™¨ã€é€šä¿¡åè®®ã€æ˜¾ç¤ºåŠŸèƒ½ç­‰éœ€æ±‚å®Œå…¨ä¿ç•™ï¼Œä»…ç®€åŒ–å®ç°æ–¹å¼ã€‚

## ğŸ“‹ éœ€æ±‚ä¿æŒä¸å˜å£°æ˜

### å¿…é¡»ä¿ç•™çš„åŠŸèƒ½éœ€æ±‚ (åŸºäºv1æ–‡æ¡£)
âœ… **ä¼ æ„Ÿå™¨ç³»ç»Ÿ**: FRD-8061æ¶²ä½ä¼ æ„Ÿå™¨ã€HP10MYå‹åŠ›ä¼ æ„Ÿå™¨ã€FTT518 PT100æ¸©åº¦ä¼ æ„Ÿå™¨
âœ… **æ‰§è¡Œå™¨ç³»ç»Ÿ**: MRA-23D3åŠ çƒ­å™¨æ§åˆ¶ã€MPB025BBBè°ƒé€Ÿæ³µæ§åˆ¶ã€ç”µç£é˜€æ§åˆ¶
âœ… **é€šä¿¡ç³»ç»Ÿ**: EtherCATå·¥ä¸šæ€»çº¿ + TCP/IPä»¥å¤ªç½‘åŒåè®®
âœ… **æ˜¾ç¤ºç³»ç»Ÿ**: CH12832B-12 LCDæ˜¾ç¤ºå±ã€5è·¯LEDçŠ¶æ€æŒ‡ç¤º
âœ… **æ§åˆ¶ç®—æ³•**: æ¸©åº¦PIDæ§åˆ¶ã€å‹åŠ›æ§åˆ¶ã€æ¶²ä½ç®¡ç†
âœ… **å®‰å…¨ä¿æŠ¤**: å¤šçº§ä¿æŠ¤ã€æ•…éšœè¯Šæ–­ã€ç´§æ€¥åœæœº
âœ… **é…ç½®ç®¡ç†**: å‚æ•°é…ç½®ã€Flashå­˜å‚¨ã€æ ¡å‡†ç®¡ç†
âœ… **IOåŠŸèƒ½**: åŸºäºç¬¬17é¡µå®Œæ•´IOåœ°å€æ˜ å°„è¡¨çš„æ‰€æœ‰æ•°å­—IO

### ç®€åŒ–ç­–ç•¥ (åŠŸèƒ½ä¸å˜ï¼Œå®ç°ç®€åŒ–)
ğŸ”¸ **ä½¿ç”¨ç°æˆåº“**: lwipæ›¿ä»£è‡ªå·±å®ç°TCP/IPï¼ŒFreeRTOSæ›¿ä»£è‡ªå·±å®ç°è°ƒåº¦å™¨
ğŸ”¸ **æˆç†Ÿæ–¹æ¡ˆ**: EtherCATä½¿ç”¨ç°æˆåè®®æ ˆï¼Œä¸è‡ªå·±å¼€å‘
ğŸ”¸ **å·¥å…·è¾…åŠ©**: ä½¿ç”¨STM32CubeMXç±»ä¼¼å·¥å…·ç”ŸæˆåŸºç¡€ä»£ç 
ğŸ”¸ **æ¨¡å—åŒ–å¼€å‘**: ä¼˜å…ˆä½¿ç”¨ç°æˆé©±åŠ¨æ¨¡å—
ğŸ”¸ **å»é™¤æŒ‰é”®**: äººæœºç•Œé¢ä»…æ˜¾ç¤ºï¼Œä¸éœ€è¦é”®ç›˜è¾“å…¥
ğŸ”¸ **ç®—æ³•ç®€åŒ–**: PIDæ§åˆ¶ç­‰ç®—æ³•ä½¿ç”¨ç®€å•å®ç°ï¼Œä¸è¿½æ±‚é«˜çº§ç‰¹æ€§

---

# ç¬¬ä¸€ç«  ç³»ç»Ÿæ¶æ„è®¾è®¡ (éœ€æ±‚ä¿æŒ)

## 1.1 ç¡¬ä»¶æ¶æ„å®Œå…¨ä¿æŒ

### 1.1.1 æ ¸å¿ƒç¡¬ä»¶è§„æ ¼ (ä¸v1å®Œå…¨ä¸€è‡´)

| å‚æ•°ç±»å‹ | æŠ€æœ¯è§„æ ¼ | æ€§èƒ½æŒ‡æ ‡ | å®ç°ç®€åŒ– |
|----------|----------|----------|----------|
| **ä¸»æ§èŠ¯ç‰‡** | GD32F427VGT6 | 200MHz, 1024K Flash, 100PIN | ä½¿ç”¨HALåº“ï¼Œå‡å°‘å¯„å­˜å™¨æ“ä½œ |
| **é€šä¿¡åè®®** | EtherCAT + ä»¥å¤ªç½‘ | 100MbpsåŒåè®®æ”¯æŒ | ä½¿ç”¨ç°æˆEtherCATåº“+lwip |
| **æ¨¡æ‹Ÿé‡‡é›†** | 15bit ADC | å¤šé€šé“é«˜ç²¾åº¦é‡‡é›† | ä½¿ç”¨DMA+å®šæ—¶è§¦å‘ï¼Œå‡å°‘CPUè´Ÿæ‹… |
| **æ•°å­—IO** | å…‰ç”µéš”ç¦» | 24è·¯æ•°å­—IOï¼Œ0.5Aè¾“å‡º | ä½¿ç”¨GPIOåº“ï¼Œæ ‡å‡†åŒ–æ¥å£ |
| **æ˜¾ç¤ºæ¥å£** | CH12832B-12 | 128Ã—32ç‚¹é˜µLCD | ä½¿ç”¨ç°æˆé©±åŠ¨åº“ |

### 1.1.2 ä¼ æ„Ÿå™¨ç³»ç»Ÿä¿æŒ (åŸºäºç¬¬8-15é¡µåŸå§‹è®¾è®¡)

```c
// ä¿æŒåŸæœ‰ä¼ æ„Ÿå™¨é…ç½®ï¼Œç®€åŒ–é©±åŠ¨å®ç°
typedef struct {
    // FRD-8061æ¶²ä½ä¼ æ„Ÿå™¨ (ç¬¬8é¡µè§„æ ¼)
    struct {
        char model[16];           // "FRD-8061"
        float range_max;          // 2000mm
        float output_min;         // 4.0mA
        float output_max;         // 20.0mA
        uint8_t adc_channel;      // ADCé€šé“å·
    } liquid_level;

    // HP10MYå‹åŠ›ä¼ æ„Ÿå™¨ (ç¬¬9é¡µè§„æ ¼)
    struct {
        char model[16];           // "HP10MY"
        float range_max;          // 100000kPa (100MPa)
        float output_min;         // 4.0mA
        float output_max;         // 20.0mA
        uint8_t adc_channel;      // ADCé€šé“å·
    } pressure;

    // FTT518 PT100æ¸©åº¦ä¼ æ„Ÿå™¨ (ç¬¬9é¡µè§„æ ¼)
    struct {
        char model[16];           // "FTT518"
        char sensor_type[16];     // "PT100 Açº§"
        float range_max;          // 600Â°C
        float accuracy_class;     // 0.15%
        uint8_t adc_channel_signal;  // ä¿¡å·é€šé“
        uint8_t adc_channel_ref;     // å‚è€ƒé€šé“
    } temperature;
} sensor_system_config_t;

// ç®€åŒ–ä¼ æ„Ÿå™¨è¯»å– - ä½¿ç”¨æ ‡å‡†ADCåº“
float read_liquid_level_frd8061(uint8_t sensor_id) {
    // ä½¿ç”¨HALåº“ç®€åŒ–ADCè¯»å–
    uint16_t adc_value = HAL_ADC_ReadChannel(ADC_LIQUID_LEVEL_1 + sensor_id);

    // æ ‡å‡†4-20mAè½¬æ¢å…¬å¼ (ä¸v1æ–‡æ¡£ç¬¬149è¡Œä¸€è‡´)
    float voltage = (float)adc_value * 3.3f / 32768.0f;  // 15bit ADC
    float current = voltage / 250.0f * 1000.0f;  // mA

    if (current < 4.0f || current > 20.0f) return -1.0f;  // æ•…éšœæ£€æµ‹

    float level = (current - 4.0f) * 2000.0f / 16.0f;  // mm
    return level;
}

float read_pressure_hp10my(uint8_t sensor_id) {
    // ä½¿ç”¨HALåº“ç®€åŒ–ADCè¯»å–
    uint16_t adc_value = HAL_ADC_ReadChannel(ADC_PRESSURE_1 + sensor_id);

    // æ ‡å‡†4-20mAè½¬æ¢å…¬å¼ (ä¸v1æ–‡æ¡£ç¬¬195è¡Œä¸€è‡´)
    float voltage = (float)adc_value * 3.3f / 32768.0f;
    float current = voltage / 250.0f * 1000.0f;

    if (current < 3.5f || current > 20.5f) return -999.0f;

    // å‹åŠ›èŒƒå›´æ˜ å°„ (4mA=-100kPa, 20mA=100MPa)
    float pressure = -100.0f + (current - 4.0f) * (100100.0f / 16.0f);
    return pressure;
}

float read_temperature_ftt518_pt100(uint8_t sensor_id) {
    // ä½¿ç”¨HALåº“è¯»å–PT100ä¸‰çº¿åˆ¶ä¿¡å· (ä¸v1æ–‡æ¡£ç¬¬231è¡Œä¸€è‡´)
    uint16_t adc_signal = HAL_ADC_ReadChannel(ADC_PT100_SIGNAL_1 + sensor_id);
    uint16_t adc_ref = HAL_ADC_ReadChannel(ADC_PT100_REF_1 + sensor_id);

    const float excitation_current = 0.001f;  // 1mA
    const float reference_resistor = 1000.0f; // 1kÎ©

    float voltage_signal = (float)adc_signal * 3.3f / 32768.0f;
    float voltage_ref = (float)adc_ref * 3.3f / 32768.0f;

    // ä¸‰çº¿åˆ¶è¡¥å¿ç®—æ³•
    float resistance_signal = voltage_signal / excitation_current;
    float wire_resistance = (reference_resistor - voltage_ref / excitation_current) / 2.0f;
    float pt100_resistance = resistance_signal - 2.0f * wire_resistance;

    // PT100ç”µé˜»-æ¸©åº¦è½¬æ¢
    float temperature;
    if (pt100_resistance >= 100.0f) {
        temperature = (pt100_resistance - 100.0f) / (100.0f * 0.003851f);
    } else {
        temperature = (pt100_resistance - 100.0f) / (100.0f * 0.003851f);
    }

    return temperature;
}
```

### 1.1.3 æ‰§è¡Œå™¨ç³»ç»Ÿä¿æŒ (åŸºäºç¬¬10-16é¡µåŸå§‹è®¾è®¡)

```c
// ä¿æŒåŸæœ‰æ‰§è¡Œå™¨é…ç½®ï¼Œç®€åŒ–æ§åˆ¶å®ç°
typedef struct {
    // MRA-23D3åŠ çƒ­å™¨æ§åˆ¶ (ç¬¬10é¡µè§„æ ¼)
    struct {
        char model[16];           // "MRA-23D3"
        uint16_t voltage_rating;  // 220V
        uint16_t power_rating;    // 150W/100W
        uint8_t gpio_pin;         // æ§åˆ¶GPIO
        bool current_state;       // å½“å‰çŠ¶æ€
    } heaters[3];  // 3è·¯åŠ çƒ­å™¨

    // MPB025BBBè°ƒé€Ÿæ³µ (ç¬¬11é¡µè§„æ ¼)
    struct {
        char model[16];           // "MPB025BBB"
        uint16_t voltage_rating;  // 24V
        uint16_t power_rating;    // 25W
        uint16_t speed_min;       // 200 RPM
        uint16_t speed_max;       // 5000 RPM
        uint8_t pwm_channel;      // PWMé€šé“
        uint16_t current_speed;   // å½“å‰è½¬é€Ÿ
    } variable_pumps[2];  // 2è·¯è°ƒé€Ÿæ³µ

    // ç”µç£é˜€æ§åˆ¶
    struct {
        uint8_t gpio_pin;         // æ§åˆ¶GPIO
        bool current_state;       // å½“å‰çŠ¶æ€
    } valves[8];  // 8è·¯ç”µç£é˜€ (åŸºäºç¬¬17é¡µIOå®šä¹‰)

} actuator_system_config_t;

// ç®€åŒ–æ‰§è¡Œå™¨æ§åˆ¶ - ä½¿ç”¨æ ‡å‡†GPIOå’ŒPWMåº“
void control_heater_mra23d3(uint8_t heater_id, bool enable) {
    // ä½¿ç”¨HALåº“ç®€åŒ–GPIOæ§åˆ¶
    HAL_GPIO_WritePin(heaters[heater_id].gpio_pin, enable ? GPIO_PIN_SET : GPIO_PIN_RESET);
    heaters[heater_id].current_state = enable;
}

void control_pump_speed_mpb025bbb(uint8_t pump_id, uint16_t target_rpm) {
    // è½¬é€Ÿé™åˆ¶æ£€æŸ¥ (ä¸v1æ–‡æ¡£ç¬¬336è¡Œä¸€è‡´)
    if (target_rpm < 200) target_rpm = 200;
    if (target_rpm > 5000) target_rpm = 5000;

    // è½¬é€Ÿåˆ°æ§åˆ¶ç”µå‹çš„çº¿æ€§è½¬æ¢ (ä¸v1æ–‡æ¡£ç¬¬341è¡Œä¸€è‡´)
    float control_voltage = 0.2f + (target_rpm - 200.0f) * (4.8f / 4800.0f);

    // ä½¿ç”¨HALåº“ç®€åŒ–PWMè¾“å‡º
    uint16_t pwm_duty = (uint16_t)(control_voltage * 1000.0f / 5.0f); // PWMå ç©ºæ¯”
    HAL_PWM_SetDutyCycle(variable_pumps[pump_id].pwm_channel, pwm_duty);

    variable_pumps[pump_id].current_speed = target_rpm;
}

void control_valve(uint8_t valve_id, bool open) {
    // ä½¿ç”¨HALåº“ç®€åŒ–GPIOæ§åˆ¶
    HAL_GPIO_WritePin(valves[valve_id].gpio_pin, open ? GPIO_PIN_SET : GPIO_PIN_RESET);
    valves[valve_id].current_state = open;
}
```

## 1.2 è½¯ä»¶æ¶æ„ç®€åŒ– (åŠŸèƒ½ä¿æŒ)

### 1.2.1 åŸºäºFreeRTOSçš„å››å±‚æ¶æ„ (ä½¿ç”¨æˆç†ŸRTOS)

```c
// ä½¿ç”¨FreeRTOSç®€åŒ–ä»»åŠ¡ç®¡ç† (ä¿æŒv1æ–‡æ¡£çš„å››å±‚æ¶æ„æ¦‚å¿µ)
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "semphr.h"

// åº”ç”¨å±‚ä»»åŠ¡å®šä¹‰ (ä¿æŒv1åŠŸèƒ½ï¼Œç®€åŒ–å®ç°)
void ApplicationLayer_MainTask(void *pvParameters);      // ä¸»åº”ç”¨ä»»åŠ¡
void ApplicationLayer_ControlTask(void *pvParameters);   // æ§åˆ¶åº”ç”¨ä»»åŠ¡
void ApplicationLayer_SensorTask(void *pvParameters);    // ä¼ æ„Ÿå™¨åº”ç”¨ä»»åŠ¡
void ApplicationLayer_NetworkTask(void *pvParameters);   // ç½‘ç»œåº”ç”¨ä»»åŠ¡
void ApplicationLayer_HMITask(void *pvParameters);       // äººæœºç•Œé¢ä»»åŠ¡

// ä¸­é—´ä»¶å±‚ä»»åŠ¡å®šä¹‰
void MiddlewareLayer_EtherCATTask(void *pvParameters);   // EtherCATä¸­é—´ä»¶ä»»åŠ¡
void MiddlewareLayer_SafetyTask(void *pvParameters);     // å®‰å…¨ä¿æŠ¤ä¸­é—´ä»¶ä»»åŠ¡

// åˆ›å»ºFreeRTOSä»»åŠ¡ (ç®€åŒ–ä»»åŠ¡åˆ›å»º)
void create_system_tasks(void) {
    // åº”ç”¨å±‚ä»»åŠ¡ (é«˜ä¼˜å…ˆçº§)
    xTaskCreate(ApplicationLayer_ControlTask, "Control", 512, NULL, 4, NULL);
    xTaskCreate(ApplicationLayer_SensorTask, "Sensor", 512, NULL, 3, NULL);
    xTaskCreate(ApplicationLayer_NetworkTask, "Network", 1024, NULL, 2, NULL);
    xTaskCreate(ApplicationLayer_HMITask, "HMI", 512, NULL, 1, NULL);

    // ä¸­é—´ä»¶å±‚ä»»åŠ¡ (æœ€é«˜ä¼˜å…ˆçº§)
    xTaskCreate(MiddlewareLayer_EtherCATTask, "EtherCAT", 512, NULL, 5, NULL);
    xTaskCreate(MiddlewareLayer_SafetyTask, "Safety", 256, NULL, 4, NULL);

    // å¯åŠ¨FreeRTOSè°ƒåº¦å™¨
    vTaskStartScheduler();
}
```

---

# ç¬¬äºŒç«  é€šä¿¡ç³»ç»Ÿä¿æŒ (ç®€åŒ–å®ç°)

## 2.1 EtherCATå·¥ä¸šæ€»çº¿ (ä½¿ç”¨ç°æˆåº“)

### 2.1.1 EtherCATåè®®æ ˆç®€åŒ– (åŠŸèƒ½ä¿æŒ)

```c
// ä½¿ç”¨ç°æˆEtherCATåº“ï¼Œä¿æŒv1æ–‡æ¡£ç¬¬548é¡µçš„ç¡¬ä»¶é…ç½®
#include "ethercat_stack.h"  // å‡è®¾ä½¿ç”¨å¼€æºEtherCATåº“

// ä¿æŒv1æ–‡æ¡£çš„EtherCATé…ç½® (ç¬¬554è¡Œ)
typedef struct {
    char controller_model[16]; // "GDSCN832R2U6"
    uint8_t port_count;        // 2 (åŒç«¯å£)
    uint32_t baudrate;         // 100Mbps
    bool hardware_realtime;    // true
    bool distributed_clock;    // true
    uint16_t sync_period;      // 1ms
    uint16_t process_data_size; // 64bytes
} ethercat_config_simple_t;

// ä¿æŒv1æ–‡æ¡£çš„è¿‡ç¨‹æ•°æ®å®šä¹‰ (ç¬¬569è¡Œ)
typedef struct {
    // å®Œå…¨ä¿æŒv1æ–‡æ¡£çš„æ•°æ®ç»“æ„
    union {
        uint8_t digital_input_bytes[8];
        struct {
            bool ink_tank_level_1 : 1;      // I0.0
            bool ink_tank_level_2 : 1;      // I0.1
            bool waste_tank_level : 1;      // I0.2
            bool cartridge_level_1 : 1;     // I0.3
            bool cartridge_level_2 : 1;     // I0.4
            bool reserved_input_5 : 1;      // I0.5
            bool reserved_input_6 : 1;      // I0.6
            bool reserved_input_7 : 1;      // I0.7
        } digital_inputs;
    };

    uint16_t analog_inputs[6];    // IW1-IW6: å‹åŠ›ã€æ¶²ä½æ¨¡æ‹Ÿé‡
    uint16_t temperature_inputs[2]; // T10-T11: PT100æ¸©åº¦

    union {
        uint8_t digital_output_bytes[8];
        struct {
            bool ink_pump_start : 1;        // Q0.0
            bool return_pump_start : 1;     // Q0.1
            bool recycle_valve_open : 1;    // Q0.2
            bool cartridge_heater : 1;      // Q0.3
            bool line_heater : 1;           // Q0.4
            bool water_supply_valve : 1;    // Q0.5
            bool waste_ink_valve : 1;       // Q0.6
            bool tank_ink_valve : 1;        // Q0.7
        } digital_outputs;
    };

    uint16_t analog_outputs[4];   // QW1-QW4: æ³µé€Ÿè°ƒèŠ‚è¾“å‡º
    uint16_t system_status;       // ç³»ç»ŸçŠ¶æ€å­—
    uint16_t fault_code;          // æ•…éšœä»£ç 
} ethercat_process_data_t;

// ç®€åŒ–EtherCATä»»åŠ¡å®ç° (ä½¿ç”¨ç°æˆåº“)
void MiddlewareLayer_EtherCATTask(void *pvParameters) {
    static ethercat_process_data_t process_data;
    TickType_t xLastWakeTime;

    // EtherCATåº“åˆå§‹åŒ–
    EtherCAT_Initialize();
    EtherCAT_SetSlaveAddress(1);  // ä»ç«™åœ°å€

    xLastWakeTime = xTaskGetTickCount();

    while(1) {
        // 1msä¸¥æ ¼å‘¨æœŸ (ä¿æŒv1æ–‡æ¡£ç¬¬914è¡Œçš„å®æ—¶æ€§è¦æ±‚)
        vTaskDelayUntil(&xLastWakeTime, pdMS_TO_TICKS(1));

        // ä½¿ç”¨åº“å‡½æ•°ç®€åŒ–æ•°æ®äº¤æ¢
        EtherCAT_ReadInputs(&process_data);

        // æ›´æ–°ä¼ æ„Ÿå™¨æ•°æ®åˆ°EtherCATè¾“å…¥
        process_data.analog_inputs[0] = (uint16_t)(current_pressure_1 * 10);
        process_data.analog_inputs[1] = (uint16_t)(current_pressure_2 * 10);
        process_data.analog_inputs[2] = (uint16_t)(current_liquid_level_1 * 10);
        process_data.analog_inputs[3] = (uint16_t)(current_liquid_level_2 * 10);
        process_data.temperature_inputs[0] = (uint16_t)(current_temperature_1 * 10);
        process_data.temperature_inputs[1] = (uint16_t)(current_temperature_2 * 10);

        // ä»EtherCATè¾“å‡ºæ›´æ–°æ‰§è¡Œå™¨
        control_heater_mra23d3(0, process_data.digital_outputs.cartridge_heater);
        control_heater_mra23d3(1, process_data.digital_outputs.line_heater);
        control_pump_speed_mpb025bbb(0, process_data.analog_outputs[0]);
        control_pump_speed_mpb025bbb(1, process_data.analog_outputs[1]);

        EtherCAT_WriteOutputs(&process_data);
    }
}
```

## 2.2 TCP/IPç½‘ç»œé€šä¿¡ (ä½¿ç”¨lwip)

### 2.2.1 åŸºäºlwipçš„ç½‘ç»œå®ç° (ä¿æŒv1åŠŸèƒ½)

```c
// ä½¿ç”¨lwipç®€åŒ–TCP/IPå®ç°ï¼Œä¿æŒv1æ–‡æ¡£ç¬¬616é¡µçš„ç»„ç½‘åŠŸèƒ½
#include "lwip/opt.h"
#include "lwip/arch.h"
#include "lwip/api.h"
#include "lwip/inet.h"
#include "lwip/sockets.h"

// ä¿æŒv1æ–‡æ¡£çš„ç½‘ç»œé…ç½®ç»“æ„ (ç¬¬621è¡Œ)
typedef struct {
    uint32_t controller_ip;       // æ§åˆ¶å™¨IPåœ°å€
    uint32_t host_ip;            // ä¸Šä½æœºIPåœ°å€
    uint16_t communication_port; // é€šä¿¡ç«¯å£ (é»˜è®¤502)
    uint16_t heartbeat_interval; // å¿ƒè·³é—´éš” (ms)
    uint8_t connection_timeout;  // è¿æ¥è¶…æ—¶ (s)
} network_config_t;

// ç®€åŒ–TCPæœåŠ¡å™¨å®ç° (ä½¿ç”¨lwip API)
void ApplicationLayer_NetworkTask(void *pvParameters) {
    struct netconn *conn, *newconn;
    err_t err;

    // åˆ›å»ºTCPè¿æ¥ç»“æ„
    conn = netconn_new(NETCONN_TCP);
    if (conn == NULL) {
        vTaskDelete(NULL);
        return;
    }

    // ç»‘å®šç«¯å£ (ä¿æŒv1æ–‡æ¡£çš„502ç«¯å£)
    err = netconn_bind(conn, IP_ADDR_ANY, 502);
    if (err != ERR_OK) {
        netconn_delete(conn);
        vTaskDelete(NULL);
        return;
    }

    // å¼€å§‹ç›‘å¬
    err = netconn_listen(conn);
    if (err != ERR_OK) {
        netconn_delete(conn);
        vTaskDelete(NULL);
        return;
    }

    while (1) {
        // ç­‰å¾…æ–°è¿æ¥
        err = netconn_accept(conn, &newconn);
        if (err == ERR_OK) {
            // å¤„ç†å®¢æˆ·ç«¯è¿æ¥
            handle_client_connection(newconn);
            netconn_close(newconn);
            netconn_delete(newconn);
        }

        vTaskDelay(pdMS_TO_TICKS(10));
    }
}

// å¤„ç†å®¢æˆ·ç«¯æ•°æ® (ä¿æŒv1æ–‡æ¡£çš„æ•°æ®æ ¼å¼)
void handle_client_connection(struct netconn *conn) {
    struct netbuf *buf;
    char *data;
    u16_t len;
    char response[512];

    // æ¥æ”¶æ•°æ®
    if (netconn_recv(conn, &buf) == ERR_OK) {
        netbuf_data(buf, (void**)&data, &len);

        // æ„é€ å“åº”æ•°æ® (JSONæ ¼å¼ï¼Œä¿æŒv1åŠŸèƒ½)
        snprintf(response, sizeof(response),
            "{"
            "\"temperature\":[%.2f,%.2f,%.2f],"
            "\"pressure\":[%.2f,%.2f],"
            "\"liquid_level\":[%.2f,%.2f],"
            "\"heater_status\":[%d,%d,%d],"
            "\"pump_speed\":[%d,%d],"
            "\"valve_status\":%d,"
            "\"system_status\":%d,"
            "\"fault_code\":%d,"
            "\"timestamp\":%u"
            "}",
            current_temperature[0], current_temperature[1], current_temperature[2],
            current_pressure[0], current_pressure[1],
            current_liquid_level[0], current_liquid_level[1],
            heater_status[0], heater_status[1], heater_status[2],
            pump_speed[0], pump_speed[1],
            valve_status_word,
            system_status,
            current_fault_code,
            (uint32_t)xTaskGetTickCount()
        );

        // å‘é€å“åº”
        netconn_write(conn, response, strlen(response), NETCONN_COPY);

        netbuf_delete(buf);
    }
}
```

---

# ç¬¬ä¸‰ç«  æ˜¾ç¤ºä¸LEDç³»ç»Ÿä¿æŒ

## 3.1 LCDæ˜¾ç¤ºç³»ç»Ÿä¿æŒ (CH12832B-12)

### 3.1.1 ä¿æŒv1æ–‡æ¡£çš„æ˜¾ç¤ºé…ç½® (ç¬¬476é¡µ)

```c
// å®Œå…¨ä¿æŒv1æ–‡æ¡£çš„æ˜¾ç¤ºé…ç½®
typedef struct {
    char model[16];           // "CH12832B-12"
    uint8_t resolution_x;     // 128 (åƒç´ å®½åº¦)
    uint8_t resolution_y;     // 32 (åƒç´ é«˜åº¦)
    uint8_t interface_type;   // SPIæ¥å£
    uint8_t supply_voltage;   // 3.3V
    uint16_t refresh_rate;    // 60Hz
    bool backlight_control;   // true
} lcd_display_spec_t;

// ä½¿ç”¨ç°æˆé©±åŠ¨åº“ç®€åŒ–æ˜¾ç¤ºå®ç°
#include "ch12832b_driver.h"  // å‡è®¾ä½¿ç”¨ç°æˆLCDé©±åŠ¨

// ä¿æŒv1æ–‡æ¡£çš„æ˜¾ç¤ºé¡µé¢å®šä¹‰ (ç¬¬497è¡Œ)
typedef enum {
    DISPLAY_PAGE_MAIN = 0,      // ä¸»é¡µé¢ - ç³»ç»ŸçŠ¶æ€æ€»è§ˆ
    DISPLAY_PAGE_SENSOR,        // ä¼ æ„Ÿå™¨æ•°æ®é¡µé¢
    DISPLAY_PAGE_ACTUATOR,      // æ‰§è¡Œå™¨çŠ¶æ€é¡µé¢
    DISPLAY_PAGE_NETWORK,       // ç½‘ç»œä¿¡æ¯é¡µé¢
    DISPLAY_PAGE_FAULT,         // æ•…éšœä¿¡æ¯é¡µé¢
    DISPLAY_PAGE_CONFIG,        // é…ç½®å‚æ•°é¡µé¢
    DISPLAY_PAGE_IO_STATUS,     // IOçŠ¶æ€é¡µé¢
    DISPLAY_PAGE_MAX
} display_page_t;

// ç®€åŒ–HMIä»»åŠ¡å®ç° (ä½¿ç”¨ç°æˆåº“ï¼Œå»é™¤æŒ‰é”®)
void ApplicationLayer_HMITask(void *pvParameters) {
    static uint8_t current_page = DISPLAY_PAGE_MAIN;
    static uint32_t auto_switch_counter = 0;

    // åˆå§‹åŒ–LCD (ä½¿ç”¨ç°æˆé©±åŠ¨)
    CH12832B_Initialize();
    CH12832B_SetBacklight(true);

    while(1) {
        // è‡ªåŠ¨åˆ‡æ¢é¡µé¢ (å»é™¤æŒ‰é”®ï¼Œæ”¹ä¸ºè‡ªåŠ¨å¾ªç¯æ˜¾ç¤º)
        auto_switch_counter++;
        if (auto_switch_counter >= 30) {  // 3ç§’åˆ‡æ¢ä¸€æ¬¡é¡µé¢
            auto_switch_counter = 0;
            current_page = (current_page + 1) % DISPLAY_PAGE_MAX;
        }

        // æ ¹æ®å½“å‰é¡µé¢æ˜¾ç¤ºå†…å®¹
        switch(current_page) {
            case DISPLAY_PAGE_MAIN:
                display_main_page();      // ä¿æŒv1æ–‡æ¡£ç¬¬509è¡Œçš„ä¸»é¡µé¢å†…å®¹
                break;
            case DISPLAY_PAGE_SENSOR:
                display_sensor_page();    // ä¿æŒv1æ–‡æ¡£ç¬¬527è¡Œçš„ä¼ æ„Ÿå™¨é¡µé¢
                break;
            case DISPLAY_PAGE_ACTUATOR:
                display_actuator_page();
                break;
            case DISPLAY_PAGE_NETWORK:
                display_network_page();
                break;
            case DISPLAY_PAGE_FAULT:
                display_fault_page();
                break;
            case DISPLAY_PAGE_CONFIG:
                display_config_page();
                break;
            case DISPLAY_PAGE_IO_STATUS:
                display_io_status_page();
                break;
        }

        vTaskDelay(pdMS_TO_TICKS(100));  // 100msåˆ·æ–°
    }
}

// ä¿æŒv1æ–‡æ¡£çš„ä¸»é¡µé¢æ˜¾ç¤º (ç¬¬509è¡Œ)
void display_main_page(void) {
    char title[32], line1[32], line2[32], line3[32];

    snprintf(title, sizeof(title), "UV Ink Service V1.0");
    snprintf(line1, sizeof(line1), "T:%.1fÂ°C P:%.1fkPa",
             current_temperature[0], current_pressure[0]);
    snprintf(line2, sizeof(line2), "Level:%.1f%% Flow:%.1f",
             current_liquid_level[0], current_flow_rate);
    snprintf(line3, sizeof(line3), "Sys:%s Net:%s",
             get_system_status_string(), get_network_status_string());

    // ä½¿ç”¨é©±åŠ¨åº“æ˜¾ç¤º
    CH12832B_Clear();
    CH12832B_ShowString(0, 0, title, 8);
    CH12832B_ShowString(0, 8, line1, 8);
    CH12832B_ShowString(0, 16, line2, 8);
    CH12832B_ShowString(0, 24, line3, 8);
    CH12832B_Refresh();
}

// ä¿æŒv1æ–‡æ¡£çš„ä¼ æ„Ÿå™¨é¡µé¢æ˜¾ç¤º (ç¬¬527è¡Œ)
void display_sensor_page(void) {
    char title[32], line1[32], line2[32], line3[32];

    snprintf(title, sizeof(title), "Sensor Data");
    snprintf(line1, sizeof(line1), "T1:%.1f T2:%.1f T3:%.1f",
             current_temperature[0], current_temperature[1], current_temperature[2]);
    snprintf(line2, sizeof(line2), "P1:%.2f P2:%.2f kPa",
             current_pressure[0], current_pressure[1]);
    snprintf(line3, sizeof(line3), "L1:%.1f%% L2:%.1f%%",
             current_liquid_level[0], current_liquid_level[1]);

    CH12832B_Clear();
    CH12832B_ShowString(0, 0, title, 8);
    CH12832B_ShowString(0, 8, line1, 8);
    CH12832B_ShowString(0, 16, line2, 8);
    CH12832B_ShowString(0, 24, line3, 8);
    CH12832B_Refresh();
}
```

## 3.2 LEDæŒ‡ç¤ºç³»ç»Ÿä¿æŒ (5è·¯LED)

### 3.2.1 å®Œå…¨ä¿æŒv1æ–‡æ¡£çš„LEDé…ç½® (ç¬¬359é¡µ)

```c
// å®Œå…¨ä¿æŒv1æ–‡æ¡£çš„LEDåŠŸèƒ½å®šä¹‰ (ç¬¬367è¡Œ)
typedef enum {
    LED_POWER_INDICATOR = 0,     // ç”µæºæŒ‡ç¤ºç¯ (çº¢è‰²)
    LED_NETWORK_STATUS,          // ç½‘ç»œçŠ¶æ€ç¯ (ç»¿è‰²)
    LED_SYSTEM_RUNNING,          // ç³»ç»Ÿè¿è¡Œç¯ (é»„è‰²)
    LED_COMMUNICATION,           // é€šä¿¡çŠ¶æ€ç¯ (è“è‰²)
    LED_FAULT_ALARM,            // æ•…éšœæŠ¥è­¦ç¯ (ç™½è‰²)
    LED_MAX_COUNT
} led_function_t;

// ä¿æŒv1æ–‡æ¡£çš„LEDçŠ¶æ€è§„åˆ™ (ç¬¬392è¡Œ)
void led_manager_task_simplified(void) {
    static uint32_t blink_counter = 0;
    blink_counter++;

    // ç”µæºæŒ‡ç¤ºç¯ - ç³»ç»Ÿæ­£å¸¸æ—¶å¸¸äº®
    HAL_GPIO_WritePin(LED_POWER_PIN, system_power_ok ? GPIO_PIN_SET : GPIO_PIN_RESET);

    // ç½‘ç»œçŠ¶æ€ç¯ - æ ¹æ®ç½‘ç»œè¿æ¥çŠ¶æ€
    if (network_connected) {
        HAL_GPIO_WritePin(LED_NETWORK_PIN, GPIO_PIN_SET);  // è¿æ¥æ—¶å¸¸äº®
    } else if (network_connecting) {
        // è¿æ¥ä¸­æ—¶1Hzé—ªçƒ
        HAL_GPIO_WritePin(LED_NETWORK_PIN, (blink_counter % 500) < 250 ? GPIO_PIN_SET : GPIO_PIN_RESET);
    } else {
        HAL_GPIO_WritePin(LED_NETWORK_PIN, GPIO_PIN_RESET);  // æ–­å¼€æ—¶ç†„ç­
    }

    // ç³»ç»Ÿè¿è¡Œç¯ - æ­£å¸¸æ—¶1Hzé—ªçƒ
    if (system_status == SYSTEM_NORMAL) {
        HAL_GPIO_WritePin(LED_SYSTEM_PIN, (blink_counter % 500) < 250 ? GPIO_PIN_SET : GPIO_PIN_RESET);
    } else {
        HAL_GPIO_WritePin(LED_SYSTEM_PIN, GPIO_PIN_RESET);
    }

    // é€šä¿¡çŠ¶æ€ç¯ - EtherCATæ´»åŠ¨æ—¶å¸¸äº®
    HAL_GPIO_WritePin(LED_COMMUNICATION_PIN, ethercat_active ? GPIO_PIN_SET : GPIO_PIN_RESET);

    // æ•…éšœæŠ¥è­¦ç¯ - æœ‰æ•…éšœæ—¶å¸¸äº®
    HAL_GPIO_WritePin(LED_FAULT_PIN, (current_fault_code != FAULT_NONE) ? GPIO_PIN_SET : GPIO_PIN_RESET);
}
```

---

# ç¬¬å››ç«  æ§åˆ¶ç®—æ³•ç®€åŒ– (åŠŸèƒ½ä¿æŒ)

## 4.1 æ¸©åº¦æ§åˆ¶ä¿æŒ (ç®€åŒ–PIDå®ç°)

### 4.1.1 ä¿æŒPIDæ§åˆ¶åŠŸèƒ½ï¼Œç®€åŒ–ç®—æ³•å®ç°

```c
// ä¿æŒv1æ–‡æ¡£çš„PIDæ§åˆ¶ç»“æ„ (ç¬¬278è¡Œ)ï¼Œç®€åŒ–å®ç°
typedef struct {
    float kp, ki, kd;         // PIDå‚æ•° (ä¿æŒ)
    float setpoint;           // ç›®æ ‡æ¸©åº¦ (ä¿æŒ)
    float last_error;         // ä¸Šæ¬¡è¯¯å·®
    float integral;           // ç§¯åˆ†ç´¯ç§¯
    uint32_t last_time;       // ä¸Šæ¬¡è®¡ç®—æ—¶é—´
} pid_controller_simple_t;

// ç®€åŒ–PIDæ§åˆ¶ç®—æ³• (ä¿æŒv1åŠŸèƒ½ï¼Œç®€åŒ–å®ç°)
float simple_pid_control(pid_controller_simple_t *pid, float current_temp) {
    uint32_t current_time = xTaskGetTickCount() * portTICK_PERIOD_MS;
    float dt = (current_time - pid->last_time) / 1000.0f;

    if (dt <= 0.0f) return 0.0f;

    // ç®€åŒ–PIDè®¡ç®— (ä¿æŒv1æ–‡æ¡£ç¬¬294è¡Œçš„åŸºæœ¬ç®—æ³•)
    float error = pid->setpoint - current_temp;
    pid->integral += error * dt;

    // ç§¯åˆ†é™å¹… (ä¿æŒv1æ–‡æ¡£ç¬¬298è¡Œçš„é˜²é¥±å’Œ)
    if (pid->integral > 100.0f) pid->integral = 100.0f;
    if (pid->integral < -100.0f) pid->integral = -100.0f;

    float derivative = (error - pid->last_error) / dt;
    float output = pid->kp * error + pid->ki * pid->integral + pid->kd * derivative;

    // è¾“å‡ºé™åˆ¶ (ä¿æŒv1æ–‡æ¡£ç¬¬306è¡Œçš„é™åˆ¶)
    if (output > 100.0f) output = 100.0f;
    if (output < 0.0f) output = 0.0f;

    pid->last_error = error;
    pid->last_time = current_time;

    return output;
}

// æ§åˆ¶ä»»åŠ¡å®ç° (ä¿æŒv1åŠŸèƒ½)
void ApplicationLayer_ControlTask(void *pvParameters) {
    static pid_controller_simple_t temp_pid[3] = {
        {2.0f, 0.1f, 0.5f, 50.0f, 0, 0, 0},  // æ¸©åº¦æ§åˆ¶å™¨1
        {2.0f, 0.1f, 0.5f, 60.0f, 0, 0, 0},  // æ¸©åº¦æ§åˆ¶å™¨2
        {2.0f, 0.1f, 0.5f, 55.0f, 0, 0, 0},  // æ¸©åº¦æ§åˆ¶å™¨3
    };

    while(1) {
        // æ¸©åº¦æ§åˆ¶å¾ªç¯ (ä¿æŒv1æ–‡æ¡£çš„3è·¯æ¸©åº¦æ§åˆ¶)
        for(int i = 0; i < 3; i++) {
            float pid_output = simple_pid_control(&temp_pid[i], current_temperature[i]);

            // è½¬æ¢ä¸ºåŠ çƒ­å™¨æ§åˆ¶ä¿¡å· (ç®€åŒ–å®ç°)
            bool heater_on = (pid_output > 50.0f);  // ç®€å•å¼€å…³æ§åˆ¶
            control_heater_mra23d3(i, heater_on);
        }

        // å‹åŠ›æ§åˆ¶ (ç®€åŒ–å®ç°ï¼Œä¿æŒåŠŸèƒ½)
        for(int i = 0; i < 2; i++) {
            float pressure_error = target_pressure[i] - current_pressure[i];
            if (pressure_error > 50.0f) {
                // å‹åŠ›ä½ï¼Œå¢åŠ æ³µé€Ÿ
                uint16_t new_speed = pump_speed[i] + 100;
                if (new_speed > 5000) new_speed = 5000;
                control_pump_speed_mpb025bbb(i, new_speed);
            } else if (pressure_error < -50.0f) {
                // å‹åŠ›é«˜ï¼Œé™ä½æ³µé€Ÿ
                uint16_t new_speed = pump_speed[i] - 100;
                if (new_speed < 200) new_speed = 200;
                control_pump_speed_mpb025bbb(i, new_speed);
            }
        }

        // æ¶²ä½ç®¡ç† (ä¿æŒv1åŠŸèƒ½)
        for(int i = 0; i < 2; i++) {
            if (current_liquid_level[i] < 20.0f) {
                // æ¶²ä½ä½ï¼Œå¼€å¯ä¾›å¢¨é˜€
                control_valve(VALVE_INK_SUPPLY_1 + i, true);
            } else if (current_liquid_level[i] > 80.0f) {
                // æ¶²ä½é«˜ï¼Œå…³é—­ä¾›å¢¨é˜€
                control_valve(VALVE_INK_SUPPLY_1 + i, false);
            }
        }

        vTaskDelay(pdMS_TO_TICKS(100));  // 100msæ§åˆ¶å‘¨æœŸ
    }
}
```

---

# ç¬¬äº”ç«  é…ç½®ç®¡ç†ä¿æŒ (ç®€åŒ–å­˜å‚¨)

## 5.1 å®Œå…¨ä¿æŒv1æ–‡æ¡£çš„é…ç½®ç»“æ„

### 5.1.1 ä¿æŒv1æ–‡æ¡£çš„å®Œæ•´é…ç½®å‚æ•° (ç¬¬747é¡µ)

```c
// å®Œå…¨ä¿æŒv1æ–‡æ¡£çš„é…ç½®ç»“æ„ï¼Œç®€åŒ–å­˜å‚¨å®ç°
typedef struct {
    // ä¿æŒv1æ–‡æ¡£çš„é…ç½®æ–‡ä»¶å¤´éƒ¨ä¿¡æ¯ (ç¬¬750è¡Œ)
    uint32_t config_version;        // é…ç½®ç‰ˆæœ¬å·
    uint32_t config_size;           // é…ç½®æ•°æ®å¤§å°
    uint32_t config_crc32;          // CRC32æ ¡éªŒå€¼
    char device_serial[32];         // è®¾å¤‡åºåˆ—å·

    // ä¿æŒv1æ–‡æ¡£çš„ç½‘ç»œé…ç½® (ç¬¬756è¡Œ)
    struct {
        uint32_t ip_address;        // IPåœ°å€
        uint32_t subnet_mask;       // å­ç½‘æ©ç 
        uint32_t gateway_address;   // ç½‘å…³åœ°å€
        uint16_t tcp_port;          // TCPé€šä¿¡ç«¯å£
        uint8_t ethercat_slave_id;  // EtherCATä»ç«™ID
        uint16_t heartbeat_interval; // å¿ƒè·³é—´éš” (ms)
    } network_config;

    // ä¿æŒv1æ–‡æ¡£çš„æ§åˆ¶å‚æ•°é…ç½® (ç¬¬767è¡Œ)
    struct {
        float temp_pid_kp[3];       // æ¸©åº¦PIDæ¯”ä¾‹ç³»æ•° (3è·¯)
        float temp_pid_ki[3];       // æ¸©åº¦PIDç§¯åˆ†ç³»æ•°
        float temp_pid_kd[3];       // æ¸©åº¦PIDå¾®åˆ†ç³»æ•°
        float temp_target[3];       // ç›®æ ‡æ¸©åº¦ (Â°C)
        float temp_alarm_high[3];   // æ¸©åº¦ä¸Šé™æŠ¥è­¦ (Â°C)
        float temp_alarm_low[3];    // æ¸©åº¦ä¸‹é™æŠ¥è­¦ (Â°C)

        float pressure_pid_kp[2];   // å‹åŠ›PIDæ¯”ä¾‹ç³»æ•° (2è·¯)
        float pressure_pid_ki[2];   // å‹åŠ›PIDç§¯åˆ†ç³»æ•°
        float pressure_pid_kd[2];   // å‹åŠ›PIDå¾®åˆ†ç³»æ•°
        float pressure_target[2];   // ç›®æ ‡å‹åŠ› (kPa)
        float pressure_alarm_high[2]; // å‹åŠ›ä¸Šé™æŠ¥è­¦
        float pressure_alarm_low[2];  // å‹åŠ›ä¸‹é™æŠ¥è­¦

        float level_target[2];      // ç›®æ ‡æ¶²ä½ (%)
        float level_alarm_high[2];  // æ¶²ä½ä¸Šé™æŠ¥è­¦ (%)
        float level_alarm_low[2];   // æ¶²ä½ä¸‹é™æŠ¥è­¦ (%)
    } control_config;

    // ä¿æŒv1æ–‡æ¡£çš„ä¼ æ„Ÿå™¨æ ¡å‡†å‚æ•° (ç¬¬790è¡Œ)
    struct {
        float temp_sensor_offset[3];    // æ¸©åº¦ä¼ æ„Ÿå™¨åç§»é‡ (Â°C)
        float temp_sensor_scale[3];     // æ¸©åº¦ä¼ æ„Ÿå™¨ç¼©æ”¾ç³»æ•°
        float temp_wire_resistance[3];  // å¯¼çº¿ç”µé˜»è¡¥å¿ (Î©)

        float pressure_sensor_offset[2]; // å‹åŠ›ä¼ æ„Ÿå™¨åç§»é‡ (kPa)
        float pressure_sensor_scale[2];  // å‹åŠ›ä¼ æ„Ÿå™¨ç¼©æ”¾ç³»æ•°
        float pressure_zero_point[2];    // å‹åŠ›é›¶ç‚¹æ ¡å‡† (mA)

        float level_sensor_offset[2];   // æ¶²ä½ä¼ æ„Ÿå™¨åç§»é‡ (%)
        float level_sensor_scale[2];    // æ¶²ä½ä¼ æ„Ÿå™¨ç¼©æ”¾ç³»æ•°
        float level_zero_point[2];      // æ¶²ä½é›¶ç‚¹æ ¡å‡† (mA)
    } calibration_config;

    // ä¿æŒv1æ–‡æ¡£çš„ç³»ç»Ÿè¿è¡Œå‚æ•° (ç¬¬808è¡Œ)
    struct {
        uint16_t adc_sample_period;     // ADCé‡‡æ ·å‘¨æœŸ (ms)
        uint16_t control_loop_period;   // æ§åˆ¶å›è·¯å‘¨æœŸ (ms)
        uint16_t communication_period;  // é€šä¿¡å‘¨æœŸ (ms)
        uint8_t led_brightness;         // LEDäº®åº¦ (0-100%)
        bool enable_display;            // ä½¿èƒ½LCDæ˜¾ç¤º
        bool enable_logging;            // ä½¿èƒ½æ—¥å¿—è®°å½•
        bool enable_auto_tuning;        // ä½¿èƒ½PIDè‡ªæ•´å®š
        uint8_t system_language;        // ç³»ç»Ÿè¯­è¨€ (0=ä¸­æ–‡, 1=è‹±æ–‡)
    } system_config;

    // ä¿æŒv1æ–‡æ¡£çš„å®‰å…¨ä¿æŠ¤å‚æ•° (ç¬¬820è¡Œ)
    struct {
        uint16_t watchdog_timeout;      // çœ‹é—¨ç‹—è¶…æ—¶æ—¶é—´ (ms)
        float over_temp_threshold;      // è¿‡æ¸©ä¿æŠ¤é˜ˆå€¼ (Â°C)
        float over_pressure_threshold;  // è¿‡å‹ä¿æŠ¤é˜ˆå€¼ (kPa)
        float under_voltage_threshold;  // æ¬ å‹ä¿æŠ¤é˜ˆå€¼ (V)
        bool enable_emergency_stop;     // ä½¿èƒ½ç´§æ€¥åœæ­¢
        uint16_t fault_recovery_delay;  // æ•…éšœæ¢å¤å»¶æ—¶ (s)
    } safety_config;

} system_config_complete_t;

// ç®€åŒ–é…ç½®å­˜å‚¨å®ç° (ä½¿ç”¨HALåº“)
bool config_save_simplified(const system_config_complete_t *config) {
    // ä½¿ç”¨HALåº“ç®€åŒ–Flashæ“ä½œ
    HAL_FLASH_Unlock();

    // æ“¦é™¤é…ç½®æ‰‡åŒº
    FLASH_EraseInitTypeDef EraseInitStruct;
    EraseInitStruct.TypeErase = FLASH_TYPEERASE_SECTORS;
    EraseInitStruct.Sector = CONFIG_FLASH_SECTOR;
    EraseInitStruct.NbSectors = 1;
    EraseInitStruct.VoltageRange = FLASH_VOLTAGE_RANGE_3;

    uint32_t SectorError;
    HAL_FLASHEx_Erase(&EraseInitStruct, &SectorError);

    // å†™å…¥é…ç½®æ•°æ®
    uint32_t *data = (uint32_t*)config;
    uint32_t addr = CONFIG_FLASH_ADDRESS;

    for(int i = 0; i < sizeof(system_config_complete_t)/4; i++) {
        HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, addr, data[i]);
        addr += 4;
    }

    HAL_FLASH_Lock();
    return true;
}

bool config_load_simplified(system_config_complete_t *config) {
    // ä½¿ç”¨HALåº“ç®€åŒ–Flashè¯»å–
    uint32_t *flash_data = (uint32_t*)CONFIG_FLASH_ADDRESS;
    uint32_t *config_data = (uint32_t*)config;

    for(int i = 0; i < sizeof(system_config_complete_t)/4; i++) {
        config_data[i] = flash_data[i];
    }

    // ç®€åŒ–éªŒè¯ (æ£€æŸ¥ç‰ˆæœ¬å·)
    if(config->config_version != EXPECTED_CONFIG_VERSION) {
        // åŠ è½½é»˜è®¤é…ç½®
        load_default_config(config);
        config_save_simplified(config);
    }

    return true;
}
```

---

# ç¬¬å…­ç«  å®‰å…¨ä¿æŠ¤ä¿æŒ (ç®€åŒ–å®ç°)

## 6.1 å®Œå…¨ä¿æŒv1æ–‡æ¡£çš„å®‰å…¨åŠŸèƒ½

### 6.1.1 ä¿æŒv1æ–‡æ¡£çš„æ•…éšœä»£ç  (ç¬¬703é¡µ)

```c
// å®Œå…¨ä¿æŒv1æ–‡æ¡£çš„æ•…éšœä»£ç å®šä¹‰ (ç¬¬703è¡Œ)
typedef enum {
    FAULT_NONE = 0x0000,

    // ä¼ æ„Ÿå™¨æ•…éšœ (0x1000ç³»åˆ—) - ä¿æŒ
    FAULT_TEMP_SENSOR_1_OPEN    = 0x1001,  // æ¸©åº¦ä¼ æ„Ÿå™¨1å¼€è·¯
    FAULT_TEMP_SENSOR_1_SHORT   = 0x1002,  // æ¸©åº¦ä¼ æ„Ÿå™¨1çŸ­è·¯
    FAULT_PRESSURE_SENSOR_1_FAULT = 0x1011, // å‹åŠ›ä¼ æ„Ÿå™¨1æ•…éšœ
    FAULT_PRESSURE_SENSOR_2_FAULT = 0x1012, // å‹åŠ›ä¼ æ„Ÿå™¨2æ•…éšœ
    FAULT_LIQUID_LEVEL_1_FAULT  = 0x1021,  // æ¶²ä½ä¼ æ„Ÿå™¨1æ•…éšœ
    FAULT_LIQUID_LEVEL_2_FAULT  = 0x1022,  // æ¶²ä½ä¼ æ„Ÿå™¨2æ•…éšœ

    // æ‰§è¡Œå™¨æ•…éšœ (0x2000ç³»åˆ—) - ä¿æŒ
    FAULT_HEATER_1_OPEN         = 0x2001,  // åŠ çƒ­å™¨1å¼€è·¯
    FAULT_HEATER_2_OPEN         = 0x2002,  // åŠ çƒ­å™¨2å¼€è·¯
    FAULT_PUMP_1_OVERCURRENT    = 0x2011,  // æ³µ1è¿‡æµ
    FAULT_PUMP_2_OVERCURRENT    = 0x2012,  // æ³µ2è¿‡æµ
    FAULT_VALVE_1_FAULT         = 0x2021,  // ç”µç£é˜€1æ•…éšœ
    FAULT_VALVE_2_FAULT         = 0x2022,  // ç”µç£é˜€2æ•…éšœ

    // ç³»ç»Ÿæ•…éšœ (0x3000ç³»åˆ—) - ä¿æŒ
    FAULT_POWER_VOLTAGE_LOW     = 0x3001,  // ç”µæºç”µå‹ä½
    FAULT_POWER_VOLTAGE_HIGH    = 0x3002,  // ç”µæºç”µå‹é«˜
    FAULT_MCU_OVERTEMPERATURE   = 0x3003,  // MCUè¿‡æ¸©
    FAULT_MEMORY_ERROR          = 0x3004,  // å†…å­˜é”™è¯¯
    FAULT_WATCHDOG_RESET        = 0x3005,  // çœ‹é—¨ç‹—å¤ä½

    // é€šä¿¡æ•…éšœ (0x4000ç³»åˆ—) - ä¿æŒ
    FAULT_ETHERCAT_DISCONNECTED = 0x4001,  // EtherCATæ–­å¼€
    FAULT_ETHERNET_LINK_DOWN    = 0x4002,  // ä»¥å¤ªç½‘é“¾è·¯æ–­å¼€
    FAULT_COMMUNICATION_TIMEOUT = 0x4003,  // é€šä¿¡è¶…æ—¶
    FAULT_PROTOCOL_ERROR        = 0x4004,  // åè®®é”™è¯¯

    FAULT_MAX_CODE              = 0xFFFF
} fault_code_t;

// ç®€åŒ–å®‰å…¨ç›‘æ§ä»»åŠ¡ (ä¿æŒv1åŠŸèƒ½)
void MiddlewareLayer_SafetyTask(void *pvParameters) {
    uint32_t fault_status = FAULT_NONE;

    while(1) {
        // æ¸©åº¦ä¿æŠ¤æ£€æŸ¥ (ä¿æŒv1æ–‡æ¡£ç¬¬1073è¡Œçš„æ£€æŸ¥é€»è¾‘)
        for (int i = 0; i < 3; i++) {
            float temp = current_temperature[i];
            if (temp > 650.0f) {
                fault_status |= (FAULT_TEMP_SENSOR_1_OPEN + i);
                // ç«‹å³å…³é—­åŠ çƒ­å™¨ (ä¿æŒv1æ–‡æ¡£ç¬¬1077è¡Œçš„ä¿æŠ¤åŠ¨ä½œ)
                control_heater_mra23d3(i, false);
            } else if (temp < -50.0f) {
                fault_status |= (FAULT_TEMP_SENSOR_1_SHORT + i);
            }
        }

        // å‹åŠ›ä¿æŠ¤æ£€æŸ¥ (ä¿æŒv1æ–‡æ¡£ç¬¬1084è¡Œçš„æ£€æŸ¥é€»è¾‘)
        for (int i = 0; i < 2; i++) {
            float pressure = current_pressure[i];
            if (pressure > 110000.0f || pressure < -110.0f) {
                fault_status |= (FAULT_PRESSURE_SENSOR_1_FAULT + i);
                // åœæ­¢æ³µè¿è¡Œ (ä¿æŒv1æ–‡æ¡£ç¬¬1089è¡Œçš„ä¿æŠ¤åŠ¨ä½œ)
                control_pump_speed_mpb025bbb(i, 0);
            }
        }

        // ç”µæºç›‘æ§ (ä¿æŒv1æ–‡æ¡£ç¬¬1096è¡Œçš„ç›‘æ§)
        float voltage_24v = read_supply_voltage_24v();  // ä½¿ç”¨ADCè¯»å–
        if (voltage_24v < 21.6f || voltage_24v > 26.4f) {
            fault_status |= FAULT_POWER_VOLTAGE_LOW;
        }

        // é€šä¿¡ç›‘æ§ (ä¿æŒv1æ–‡æ¡£ç¬¬1103è¡Œçš„ç›‘æ§)
        if (ethercat_connection_lost() || tcp_connection_timeout()) {
            fault_status |= FAULT_COMMUNICATION_TIMEOUT;
        }

        // æ›´æ–°å…¨å±€æ•…éšœçŠ¶æ€
        current_fault_code = fault_status;

        // ä¸¥é‡æ•…éšœæ—¶æ‰§è¡Œç´§æ€¥åœæœº (ä¿æŒv1æ–‡æ¡£ç¬¬1152è¡Œçš„å¤„ç†)
        if (fault_status & 0x3000) {  // ç³»ç»Ÿæ•…éšœç±»
            execute_emergency_shutdown_simplified();
        }

        vTaskDelay(pdMS_TO_TICKS(100));  // 100mså®‰å…¨æ£€æŸ¥å‘¨æœŸ
    }
}

// ç®€åŒ–ç´§æ€¥åœæœº (ä¿æŒv1æ–‡æ¡£ç¬¬1152è¡Œçš„åŠŸèƒ½)
void execute_emergency_shutdown_simplified(void) {
    // ç«‹å³å…³é—­æ‰€æœ‰åŠ çƒ­å™¨ (ä¿æŒv1æ–‡æ¡£ç¬¬1154è¡Œ)
    for(int i = 0; i < 3; i++) {
        control_heater_mra23d3(i, false);
    }

    // åœæ­¢æ‰€æœ‰æ³µè¿è¡Œ (ä¿æŒv1æ–‡æ¡£ç¬¬1159è¡Œ)
    for(int i = 0; i < 2; i++) {
        control_pump_speed_mpb025bbb(i, 0);
    }

    // å…³é—­æ‰€æœ‰ç”µç£é˜€ (ä¿æŒv1æ–‡æ¡£ç¬¬1166è¡Œ)
    for(int i = 0; i < 8; i++) {
        control_valve(i, false);
    }

    // æ¿€æ´»æ•…éšœæŒ‡ç¤ºLED (ä¿æŒv1æ–‡æ¡£ç¬¬1171è¡Œ)
    HAL_GPIO_WritePin(LED_FAULT_PIN, GPIO_PIN_SET);

    // å‘é€æ•…éšœé€šæŠ¥ (ä¿æŒv1æ–‡æ¡£ç¬¬1178è¡Œ)
    send_fault_notification_to_host();
}
```

---

# ç¬¬ä¸ƒç«  ç®€åŒ–ç›®å½•ç»“æ„ (åŠŸèƒ½ä¿æŒ)

## 7.1 åŸºäºæˆç†Ÿå·¥å…·çš„ç›®å½•ç»“æ„

```
ink_supply_system_6weeks/
â”œâ”€â”€ src/                                    # æºä»£ç ç›®å½•
â”‚   â”œâ”€â”€ main.c                             # ä¸»ç¨‹åºå…¥å£
â”‚   â”‚
â”‚   â”œâ”€â”€ application/                       # åº”ç”¨å±‚ (ä¿æŒv1å…¨åŠŸèƒ½)
â”‚   â”‚   â”œâ”€â”€ control_app.c/h                # æ§åˆ¶åº”ç”¨ (PIDæ§åˆ¶ç­‰)
â”‚   â”‚   â”œâ”€â”€ sensor_app.c/h                 # ä¼ æ„Ÿå™¨åº”ç”¨ (3ç§ä¼ æ„Ÿå™¨)
â”‚   â”‚   â”œâ”€â”€ actuator_app.c/h               # æ‰§è¡Œå™¨åº”ç”¨ (åŠ çƒ­å™¨+æ³µ+é˜€)
â”‚   â”‚   â”œâ”€â”€ network_app.c/h                # ç½‘ç»œåº”ç”¨ (EtherCAT+TCP)
â”‚   â”‚   â”œâ”€â”€ hmi_app.c/h                    # äººæœºç•Œé¢ (LCD+LED)
â”‚   â”‚   â”œâ”€â”€ safety_app.c/h                 # å®‰å…¨åº”ç”¨ (ä¿æŠ¤é€»è¾‘)
â”‚   â”‚   â””â”€â”€ config_app.c/h                 # é…ç½®åº”ç”¨ (å‚æ•°ç®¡ç†)
â”‚   â”‚
â”‚   â”œâ”€â”€ middleware/                        # ä¸­é—´ä»¶å±‚ (ä½¿ç”¨ç°æˆåº“)
â”‚   â”‚   â”œâ”€â”€ ethercat_stack/                # EtherCATåè®®æ ˆ (ç¬¬ä¸‰æ–¹åº“)
â”‚   â”‚   â”œâ”€â”€ lwip_port/                     # lwipç§»æ¤å±‚
â”‚   â”‚   â”œâ”€â”€ freertos_config/               # FreeRTOSé…ç½®
â”‚   â”‚   â”œâ”€â”€ digital_filter.c/h             # æ•°å­—æ»¤æ³¢ç®—æ³•
â”‚   â”‚   â””â”€â”€ pid_controller.c/h             # PIDæ§åˆ¶å™¨
â”‚   â”‚
â”‚   â”œâ”€â”€ hal/                               # ç¡¬ä»¶æŠ½è±¡å±‚ (ä½¿ç”¨HALåº“)
â”‚   â”‚   â”œâ”€â”€ adc_hal.c/h                    # ADC HAL (ä¼ æ„Ÿå™¨é‡‡é›†)
â”‚   â”‚   â”œâ”€â”€ gpio_hal.c/h                   # GPIO HAL (æ•°å­—IO)
â”‚   â”‚   â”œâ”€â”€ pwm_hal.c/h                    # PWM HAL (æ³µè°ƒé€Ÿ)
â”‚   â”‚   â”œâ”€â”€ spi_hal.c/h                    # SPI HAL (LCDé€šä¿¡)
â”‚   â”‚   â”œâ”€â”€ eth_hal.c/h                    # ä»¥å¤ªç½‘HAL
â”‚   â”‚   â””â”€â”€ flash_hal.c/h                  # Flash HAL (é…ç½®å­˜å‚¨)
â”‚   â”‚
â”‚   â””â”€â”€ drivers/                           # è®¾å¤‡é©±åŠ¨ (ä½¿ç”¨ç°æˆé©±åŠ¨)
â”‚       â”œâ”€â”€ ch12832b_lcd.c/h               # LCDé©±åŠ¨ (ç°æˆåº“)
â”‚       â”œâ”€â”€ w5500_eth.c/h                  # ä»¥å¤ªç½‘èŠ¯ç‰‡é©±åŠ¨
â”‚       â””â”€â”€ sensor_drivers.c/h             # ä¼ æ„Ÿå™¨é©±åŠ¨åˆé›†
â”‚
â”œâ”€â”€ lib/                                   # ç¬¬ä¸‰æ–¹åº“ (ç°æˆåº“)
â”‚   â”œâ”€â”€ GD32F4xx_HAL_Driver/               # GD32 HALåº“ (å®˜æ–¹)
â”‚   â”œâ”€â”€ CMSIS/                             # ARM CMSISåº“ (å®˜æ–¹)
â”‚   â”œâ”€â”€ FreeRTOS/                          # FreeRTOS (å®˜æ–¹)
â”‚   â”œâ”€â”€ lwip/                              # lwip TCP/IPåº“ (å®˜æ–¹)
â”‚   â”œâ”€â”€ EtherCAT_Slave_Stack/              # EtherCATä»ç«™åº“ (å¼€æº)
â”‚   â””â”€â”€ LCD_Drivers/                       # LCDé©±åŠ¨åº“åˆé›†
â”‚
â”œâ”€â”€ config/                                # é…ç½®æ–‡ä»¶
â”‚   â”œâ”€â”€ FreeRTOSConfig.h                   # FreeRTOSé…ç½®
â”‚   â”œâ”€â”€ lwipopts.h                         # lwipé…ç½®
â”‚   â”œâ”€â”€ ethercat_config.h                  # EtherCATé…ç½®
â”‚   â””â”€â”€ system_config.h                    # ç³»ç»Ÿé…ç½®
â”‚
â”œâ”€â”€ docs/                                  # è®¾è®¡æ–‡æ¡£
â”‚   â”œâ”€â”€ v1_original_design.md              # åŸå§‹v1è®¾è®¡æ–‡æ¡£
â”‚   â”œâ”€â”€ simplification_guide.md            # ç®€åŒ–å®ç°æŒ‡å—
â”‚   â””â”€â”€ 6week_development_plan.md          # 6å‘¨å¼€å‘è®¡åˆ’
â”‚
â”œâ”€â”€ tools/                                 # å¼€å‘å·¥å…·
â”‚   â”œâ”€â”€ cubemx_project/                    # STM32CubeMXé¡¹ç›® (ä»£ç ç”Ÿæˆ)
â”‚   â”œâ”€â”€ config_tool/                       # é…ç½®å·¥å…·
â”‚   â””â”€â”€ test_scripts/                      # æµ‹è¯•è„šæœ¬
â”‚
â”œâ”€â”€ build/                                 # æ„å»ºè¾“å‡º
â”œâ”€â”€ CMakeLists.txt                         # CMakeé…ç½® (ç°ä»£æ„å»º)
â”œâ”€â”€ Makefile                               # ä¼ ç»ŸMakefile
â”œâ”€â”€ README.md                              # é¡¹ç›®è¯´æ˜
â””â”€â”€ .gitignore                             # Gitå¿½ç•¥æ–‡ä»¶
```

---

# ç¬¬å…«ç«  6å‘¨å¼€å‘è®¡åˆ’ (åŠŸèƒ½ä¸å˜)

## 8.1 åŸºäºç°æˆåº“çš„å¿«é€Ÿå¼€å‘è®¡åˆ’

### ç¬¬1å‘¨: å¹³å°æ­å»º + åŸºç¡€åº“é›†æˆ
- **Day 1-2**: GD32F427å¼€å‘æ¿é‡‡è´­ï¼Œå¼€å‘ç¯å¢ƒæ­å»º
- **Day 3-4**: FreeRTOS + HALåº“é›†æˆï¼ŒåŸºç¡€ä»»åŠ¡è¿è¡Œ
- **Day 5-7**: lwipç½‘ç»œåº“é›†æˆï¼ŒåŸºç¡€ç½‘ç»œåŠŸèƒ½æµ‹è¯•

### ç¬¬2å‘¨: ä¼ æ„Ÿå™¨ç³»ç»Ÿé›†æˆ (ä¿æŒv1å…¨åŠŸèƒ½)
- **Day 1-2**: 4-20mAä¼ æ„Ÿå™¨ADCé‡‡é›† (FRD-8061æ¶²ä½ + HP10MYå‹åŠ›)
- **Day 3-4**: PT100æ¸©åº¦ä¼ æ„Ÿå™¨ä¸‰çº¿åˆ¶é©±åŠ¨ (FTT518)
- **Day 5-7**: ä¼ æ„Ÿå™¨æ•°æ®å¤„ç†å’Œæ ¡å‡† (ä¿æŒv1ç²¾åº¦è¦æ±‚)

### ç¬¬3å‘¨: æ‰§è¡Œå™¨æ§åˆ¶ç³»ç»Ÿ (ä¿æŒv1å…¨åŠŸèƒ½)
- **Day 1-2**: MRA-23D3åŠ çƒ­å™¨ç»§ç”µå™¨æ§åˆ¶ (3è·¯)
- **Day 3-4**: MPB025BBBè°ƒé€Ÿæ³µPWMæ§åˆ¶ (2è·¯)
- **Day 5-7**: ç”µç£é˜€æ§åˆ¶ + PIDæ§åˆ¶ç®—æ³•å®ç°

### ç¬¬4å‘¨: é€šä¿¡ç³»ç»Ÿé›†æˆ (ä¿æŒv1åŒåè®®)
- **Day 1-3**: EtherCATä»ç«™åº“é›†æˆï¼Œç¡¬ä»¶é€šä¿¡æµ‹è¯•
- **Day 4-5**: TCP/IPæœåŠ¡å™¨å®ç° (åŸºäºlwip)
- **Day 6-7**: åŒåè®®æ•°æ®åŒæ­¥ï¼Œç½‘ç»œç»„ç½‘æµ‹è¯•

### ç¬¬5å‘¨: HMI + å®‰å…¨ç³»ç»Ÿ (ä¿æŒv1å…¨åŠŸèƒ½)
- **Day 1-2**: CH12832B-12 LCDæ˜¾ç¤ºç³»ç»Ÿ (7ä¸ªé¡µé¢)
- **Day 3-4**: 5è·¯LEDçŠ¶æ€æŒ‡ç¤ºç³»ç»Ÿ
- **Day 5-7**: å®‰å…¨ä¿æŠ¤å’Œæ•…éšœè¯Šæ–­ç³»ç»Ÿ

### ç¬¬6å‘¨: é…ç½®ç®¡ç† + ç³»ç»Ÿé›†æˆæµ‹è¯•
- **Day 1-2**: å®Œæ•´é…ç½®ç®¡ç†å’ŒFlashå­˜å‚¨
- **Day 3-4**: ç³»ç»Ÿé›†æˆæµ‹è¯•ï¼Œæ€§èƒ½è°ƒä¼˜
- **Day 5-7**: å®Œæ•´åŠŸèƒ½æµ‹è¯•ï¼Œæ–‡æ¡£æ•´ç†

## 8.2 å…³é”®æˆåŠŸå› ç´ 

### ä½¿ç”¨ç°æˆåº“é™ä½å¼€å‘é‡
ğŸ”¸ **FreeRTOS**: ä»»åŠ¡è°ƒåº¦ç°æˆè§£å†³æ–¹æ¡ˆï¼Œæ— éœ€è‡ªå·±å®ç°
ğŸ”¸ **lwip**: TCP/IPåè®®æ ˆç°æˆåº“ï¼Œå¤§å¹…å‡å°‘ç½‘ç»œä»£ç 
ğŸ”¸ **EtherCATåº“**: ä½¿ç”¨å¼€æºEtherCATä»ç«™åº“ï¼Œé¿å…åè®®å¼€å‘
ğŸ”¸ **HALåº“**: GD32å®˜æ–¹HALåº“ï¼Œç®€åŒ–åº•å±‚ç¡¬ä»¶æ“ä½œ
ğŸ”¸ **é©±åŠ¨åº“**: LCDã€ä¼ æ„Ÿå™¨ç­‰ä½¿ç”¨ç°æˆé©±åŠ¨åº“

### åŠŸèƒ½åˆ†è§£å¹¶è¡Œå¼€å‘
ğŸ”¸ **æ¨¡å—åŒ–**: å„åŠŸèƒ½æ¨¡å—ç‹¬ç«‹å¼€å‘ï¼Œæœ€åé›†æˆ
ğŸ”¸ **æ¥å£æ ‡å‡†åŒ–**: ä½¿ç”¨æ ‡å‡†æ¥å£ï¼Œé™ä½æ¨¡å—é—´è€¦åˆ
ğŸ”¸ **æ¸è¿›é›†æˆ**: é€æ­¥é›†æˆåŠŸèƒ½ï¼ŒåŠæ—¶å‘ç°é—®é¢˜

### æµ‹è¯•é©±åŠ¨å¼€å‘
ğŸ”¸ **å•å…ƒæµ‹è¯•**: æ¯ä¸ªæ¨¡å—ç‹¬ç«‹æµ‹è¯•éªŒè¯
ğŸ”¸ **é›†æˆæµ‹è¯•**: æ¨¡å—ç»„åˆåŠŸèƒ½æµ‹è¯•
ğŸ”¸ **ç³»ç»Ÿæµ‹è¯•**: å®Œæ•´ç³»ç»ŸåŠŸèƒ½éªŒè¯

## 8.3 é£é™©æ§åˆ¶

### æŠ€æœ¯é£é™©
- **EtherCATå¤æ‚åº¦**: ä½¿ç”¨æˆç†Ÿå¼€æºåº“é™ä½é£é™©
- **å®æ—¶æ€§è¦æ±‚**: FreeRTOSä¿è¯ä»»åŠ¡è°ƒåº¦å®æ—¶æ€§
- **ç¡¬ä»¶å…¼å®¹æ€§**: ä½¿ç”¨å®˜æ–¹HALåº“ä¿è¯å…¼å®¹æ€§

### è¿›åº¦é£é™©
- **åŠŸèƒ½è£å‰ªå¤‡æ¡ˆ**: å¦‚è¿›åº¦ç´§å¼ ï¼Œä¼˜å…ˆä¿è¯æ ¸å¿ƒåŠŸèƒ½
- **å¹¶è¡Œå¼€å‘**: å¤šä¸ªæ¨¡å—åŒæ—¶å¼€å‘ï¼Œæé«˜æ•ˆç‡
- **é‡Œç¨‹ç¢‘æ£€æŸ¥**: æ¯å‘¨æœ«è¿›è¡Œè¿›åº¦æ£€æŸ¥å’Œè°ƒæ•´

---

# æ€»ç»“

## ä¸v1æ–‡æ¡£çš„å…³ç³»

### åŠŸèƒ½å®Œå…¨ä¿æŒ âœ…
1. **ä¼ æ„Ÿå™¨ç³»ç»Ÿ**: FRD-8061ã€HP10MYã€FTT518 - å®Œå…¨ä¿æŒ
2. **æ‰§è¡Œå™¨ç³»ç»Ÿ**: MRA-23D3ã€MPB025BBBã€ç”µç£é˜€æ§åˆ¶ - å®Œå…¨ä¿æŒ
3. **é€šä¿¡ç³»ç»Ÿ**: EtherCAT + TCP/IPåŒåè®® - å®Œå…¨ä¿æŒ
4. **æ˜¾ç¤ºç³»ç»Ÿ**: CH12832B-12 LCD + 5è·¯LED - å®Œå…¨ä¿æŒ
5. **æ§åˆ¶ç®—æ³•**: PIDæ§åˆ¶ã€å®‰å…¨ä¿æŠ¤ - åŠŸèƒ½ä¿æŒï¼Œå®ç°ç®€åŒ–
6. **é…ç½®ç®¡ç†**: å®Œæ•´å‚æ•°é…ç½®å’Œå­˜å‚¨ - å®Œå…¨ä¿æŒ
7. **IOåŠŸèƒ½**: ç¬¬17é¡µå®Œæ•´IOæ˜ å°„ - å®Œå…¨ä¿æŒ

### å®ç°æ–¹å¼ç®€åŒ– ğŸš€
1. **ä½¿ç”¨FreeRTOS**: æ›¿ä»£è‡ªå·±å®ç°ä»»åŠ¡è°ƒåº¦å™¨
2. **ä½¿ç”¨lwip**: æ›¿ä»£è‡ªå·±å®ç°TCP/IPåè®®æ ˆ
3. **ä½¿ç”¨EtherCATåº“**: æ›¿ä»£è‡ªå·±å¼€å‘EtherCATåè®®
4. **ä½¿ç”¨HALåº“**: æ›¿ä»£ç›´æ¥å¯„å­˜å™¨æ“ä½œ
5. **ä½¿ç”¨ç°æˆé©±åŠ¨**: LCDã€ä¼ æ„Ÿå™¨ç­‰ä½¿ç”¨ç°æˆåº“
6. **å»é™¤æŒ‰é”®**: HMIæ”¹ä¸ºè‡ªåŠ¨å¾ªç¯æ˜¾ç¤ºï¼Œé™ä½äº¤äº’å¤æ‚åº¦
7. **ç®—æ³•ç®€åŒ–**: PIDç­‰ç®—æ³•ä½¿ç”¨ç®€å•å¯é å®ç°

### å¼€å‘ä¼˜åŠ¿ ğŸ’ª
- **æ—¶é—´å¯æ§**: 6å‘¨å®Œæˆï¼Œç°æˆåº“å¤§å¹…å‡å°‘ä»£ç é‡
- **åŠŸèƒ½å®Œæ•´**: ä¿æŒv1æ–‡æ¡£çš„æ‰€æœ‰åŠŸèƒ½éœ€æ±‚
- **è´¨é‡å¯é **: ä½¿ç”¨æˆç†Ÿåº“ï¼Œæé«˜ç³»ç»Ÿç¨³å®šæ€§
- **æ˜“äºç»´æŠ¤**: æ ‡å‡†åŒ–æ¥å£ï¼Œé™ä½ç»´æŠ¤å¤æ‚åº¦
- **æŠ€æœ¯ç°ä»£**: ä½¿ç”¨ç°ä»£å¼€å‘å·¥å…·å’Œæ–¹æ³•

## é€‚ç”¨åœºæ™¯
- ä¿æŒåŸæœ‰åŠŸèƒ½éœ€æ±‚çš„å¿«é€Ÿå¼€å‘
- å·¥ä¸šçº§ä¾›å¢¨æ§åˆ¶ç³»ç»ŸåŸå‹å¼€å‘
- åŸºäºæˆç†ŸæŠ€æœ¯æ ˆçš„å¯é å®ç°
- 6å‘¨æ—¶é—´çº¦æŸä¸‹çš„å®Œæ•´ç³»ç»Ÿå¼€å‘

æœ¬ç®€åŒ–ç‰ˆæœ¬åœ¨**åŠŸèƒ½éœ€æ±‚å®Œå…¨ä¸å˜**çš„å‰æä¸‹ï¼Œé€šè¿‡ä½¿ç”¨æˆç†Ÿçš„å¼€æºåº“å’Œå·¥å…·ï¼Œå°†å¼€å‘å¤æ‚åº¦é™ä½åˆ°ä¸ªäºº6å‘¨å¯å®Œæˆçš„æ°´å¹³ï¼Œæ˜¯ä¸€ä¸ªç°å®å¯è¡Œçš„å®ç°æ–¹æ¡ˆã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬**: V2.0 (éœ€æ±‚ä¸å˜ç®€åŒ–å®ç°ç‰ˆ)
**åˆ›å»ºæ—¥æœŸ**: 2025-09-27
**åŸºç¡€æ–‡æ¡£**: ä¾›å¢¨ç³»ç»Ÿæ§åˆ¶æ¿å¡ç»¼åˆæŠ€æœ¯è®¾è®¡æ–‡æ¡£(åˆ†å±‚ç‰ˆ)v1
**åŠŸèƒ½ä¿æŒ**: 100% (æ‰€æœ‰v1åŠŸèƒ½éœ€æ±‚å®Œå…¨ä¿æŒ)
**å®ç°ç®€åŒ–**: ä½¿ç”¨FreeRTOS + lwip + EtherCATåº“ + HALåº“
**å¼€å‘å‘¨æœŸ**: 6å‘¨ (ä¸ªäººå¼€å‘å¯è¡Œ)
**æŠ€æœ¯é£é™©**: ä½ (åŸºäºæˆç†Ÿåº“å’Œå·¥å…·)