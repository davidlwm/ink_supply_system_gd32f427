# 供墨系统上位机通信协议规范

## 文档信息
- **文档名称**: 供墨系统上位机通信协议规范
- **版本**: V4.0
- **创建日期**: 2024-12-27
- **适用系统**: 基于GD32F427的工业供墨系统
- **协议标准**: EtherCAT、Modbus TCP、自定义TCP协议

## 1. 协议概述

### 1.1 支持的通信协议
供墨系统支持多种通信协议，以满足不同上位机的接入需求：

| 协议类型 | 接口方式 | 主要用途 | 实时性 | 复杂度 |
|----------|----------|----------|---------|--------|
| **EtherCAT** | 以太网 | 工业实时控制 | 极高 (1ms) | 高 |
| **Modbus TCP** | 以太网 | 标准工业通信 | 中 (50ms) | 中 |
| **自定义TCP** | 以太网 | 灵活数据交换 | 低 (100ms) | 低 |
| **Modbus RTU** | 串口 | 调试和维护 | 低 (100ms) | 低 |

### 1.2 协议选择建议
- **高实时性控制**: 推荐使用EtherCAT协议
- **标准SCADA系统**: 推荐使用Modbus TCP协议
- **自定义上位机**: 推荐使用自定义TCP协议
- **现场调试**: 推荐使用Modbus RTU协议

## 2. EtherCAT通信协议

### 2.1 EtherCAT基本配置

#### 2.1.1 设备标识信息
```c
// EtherCAT设备标识
#define VENDOR_ID           0x12345678      // 厂商ID
#define PRODUCT_CODE        0x00000001      // 产品代码
#define REVISION_NUMBER     0x00040000      // 版本号V4.0
#define SERIAL_NUMBER       0x00000001      // 设备序列号

// 通信周期配置
#define PD_CYCLE_TIME_US    1000           // 过程数据循环周期1ms
#define DC_SUPPORTED        1              // 支持分布式时钟
#define DC_RANGE           125000          // 分布式时钟范围125μs
```

#### 2.1.2 同步管理器配置
```c
// SM0 - 邮箱写入 (主站→从站)
#define SM0_START_ADDR      0x1000         // 起始地址
#define SM0_LENGTH          128            // 长度128字节
#define SM0_CONTROL         0x26           // 控制字

// SM1 - 邮箱读出 (从站→主站)
#define SM1_START_ADDR      0x1080         // 起始地址
#define SM1_LENGTH          128            // 长度128字节
#define SM1_CONTROL         0x22           // 控制字

// SM2 - 过程数据输出 (主站→从站)
#define SM2_START_ADDR      0x1100         // 起始地址
#define SM2_LENGTH          64             // 长度64字节
#define SM2_CONTROL         0x64           // 控制字

// SM3 - 过程数据输入 (从站→主站)
#define SM3_START_ADDR      0x1180         // 起始地址
#define SM3_LENGTH          64             // 长度64字节
#define SM3_CONTROL         0x20           // 控制字
```

### 2.2 EtherCAT过程数据映射

#### 2.2.1 输入过程数据 (从站→主站)
从站向主站发送的实时数据，总长度64字节：

```c
typedef struct {
    // 传感器数据 (28字节)
    float liquid_level_1;        // 0x00: 液位传感器1 (%)
    float liquid_level_2;        // 0x04: 液位传感器2 (%)
    float pressure_1;            // 0x08: 压力传感器1 (kPa)
    float pressure_2;            // 0x0C: 压力传感器2 (kPa)
    float temperature_1;         // 0x10: 温度传感器1 (°C)
    float temperature_2;         // 0x14: 温度传感器2 (°C)
    float temperature_3;         // 0x18: 温度传感器3 (°C)

    // 状态数据 (8字节)
    uint16_t system_status;      // 0x1C: 系统状态字
    uint16_t fault_code;         // 0x1E: 故障代码
    uint16_t safety_status;      // 0x20: 安全状态字
    uint16_t reserved_1;         // 0x22: 保留

    // 扩展数据 (28字节)
    float actual_heater_power[3]; // 0x24: 实际加热器功率
    uint16_t actual_pump_speed[2]; // 0x30: 实际泵转速
    uint16_t actual_valve_states; // 0x34: 实际阀门状态
    uint32_t cycle_counter;      // 0x36: 循环计数器
    uint32_t error_counter;      // 0x3A: 错误计数器
    uint8_t reserved_2[6];       // 0x3E: 保留对齐
} __attribute__((packed)) ethercat_input_pdo_t;
```

#### 2.2.2 输出过程数据 (主站→从站)
主站向从站发送的控制数据，总长度64字节：

```c
typedef struct {
    // 执行器控制 (26字节)
    float heater_1_power;        // 0x00: 加热器1功率 (%)
    float heater_2_power;        // 0x04: 加热器2功率 (%)
    float heater_3_power;        // 0x08: 加热器3功率 (%)
    uint16_t pump_1_speed;       // 0x0C: 泵1转速 (RPM)
    uint16_t pump_2_speed;       // 0x0E: 泵2转速 (RPM)
    uint16_t valve_states;       // 0x10: 阀门状态 (位掩码)
    uint16_t control_word;       // 0x12: 控制字
    uint32_t command_code;       // 0x14: 命令代码
    uint16_t reserved_1;         // 0x18: 保留

    // 设定值参数 (20字节)
    float temperature_setpoint_1; // 0x1A: 温度设定点1 (°C)
    float temperature_setpoint_2; // 0x1E: 温度设定点2 (°C)
    float temperature_setpoint_3; // 0x22: 温度设定点3 (°C)
    float pressure_setpoint_1;   // 0x26: 压力设定点1 (kPa)
    float pressure_setpoint_2;   // 0x2A: 压力设定点2 (kPa)

    // 控制参数 (18字节)
    uint16_t control_mode;       // 0x2E: 控制模式
    uint16_t safety_enable;      // 0x30: 安全使能
    uint32_t watchdog_counter;   // 0x32: 看门狗计数器
    uint32_t reserved_2;         // 0x36: 保留
    uint8_t reserved_3[6];       // 0x3A: 保留对齐
} __attribute__((packed)) ethercat_output_pdo_t;
```

### 2.3 EtherCAT状态字定义

#### 2.3.1 系统状态字 (system_status)
```c
// 系统状态位定义
#define SYS_STATUS_INITIALIZED     0x0001  // 系统已初始化
#define SYS_STATUS_RUNNING         0x0002  // 系统运行中
#define SYS_STATUS_CONTROL_ENABLED 0x0004  // 控制使能
#define SYS_STATUS_SAFETY_OK       0x0008  // 安全状态正常
#define SYS_STATUS_SENSORS_OK      0x0010  // 传感器状态正常
#define SYS_STATUS_ACTUATORS_OK    0x0020  // 执行器状态正常
#define SYS_STATUS_COMMUNICATION_OK 0x0040 // 通信状态正常
#define SYS_STATUS_EMERGENCY_STOP  0x0080  // 急停状态
#define SYS_STATUS_WARNING         0x0100  // 警告状态
#define SYS_STATUS_ERROR           0x0200  // 错误状态
#define SYS_STATUS_FAULT           0x0400  // 故障状态
#define SYS_STATUS_MAINTENANCE     0x0800  // 维护模式
```

#### 2.3.2 控制字 (control_word)
```c
// 控制字位定义
#define CTRL_WORD_SYSTEM_ENABLE    0x0001  // 系统使能
#define CTRL_WORD_CONTROL_ENABLE   0x0002  // 控制使能
#define CTRL_WORD_SAFETY_ENABLE    0x0004  // 安全使能
#define CTRL_WORD_EMERGENCY_STOP   0x0008  // 急停命令
#define CTRL_WORD_RESET_FAULTS     0x0010  // 复位故障
#define CTRL_WORD_CALIBRATE        0x0020  // 校准命令
#define CTRL_WORD_SAVE_CONFIG      0x0040  // 保存配置
#define CTRL_WORD_LOAD_CONFIG      0x0080  // 加载配置
#define CTRL_WORD_AUTO_MODE        0x0100  // 自动模式
#define CTRL_WORD_MANUAL_MODE      0x0200  // 手动模式
```

### 2.4 EtherCAT命令代码

#### 2.4.1 系统命令 (command_code)
```c
typedef enum {
    ECAT_CMD_NONE              = 0x0000,  // 无命令
    ECAT_CMD_SYSTEM_RESET      = 0x0001,  // 系统复位
    ECAT_CMD_EMERGENCY_STOP    = 0x0002,  // 紧急停止
    ECAT_CMD_CLEAR_FAULTS      = 0x0003,  // 清除故障
    ECAT_CMD_CALIBRATE_SENSORS = 0x0004,  // 校准传感器
    ECAT_CMD_SAVE_CONFIG       = 0x0005,  // 保存配置
    ECAT_CMD_LOAD_CONFIG       = 0x0006,  // 加载配置
    ECAT_CMD_START_OPERATION   = 0x0007,  // 开始运行
    ECAT_CMD_STOP_OPERATION    = 0x0008,  // 停止运行
    ECAT_CMD_TEST_MODE         = 0x0009,  // 测试模式
    ECAT_CMD_MAINTENANCE_MODE  = 0x000A   // 维护模式
} ethercat_command_code_t;
```

## 3. Modbus TCP通信协议

### 3.1 Modbus TCP基本配置

#### 3.1.1 网络配置
```c
// Modbus TCP网络配置
#define MODBUS_TCP_PORT         502        // 标准Modbus TCP端口
#define MODBUS_MAX_CLIENTS      4          // 最大客户端连接数
#define MODBUS_TIMEOUT_MS       5000       // 连接超时时间
#define MODBUS_UNIT_ID          1          // 设备单元ID
```

#### 3.1.2 功能码支持
```c
// 支持的Modbus功能码
#define FC_READ_COILS           0x01       // 读线圈状态
#define FC_READ_DISCRETE_INPUTS 0x02       // 读离散输入
#define FC_READ_HOLDING_REGS    0x03       // 读保持寄存器
#define FC_READ_INPUT_REGS      0x04       // 读输入寄存器
#define FC_WRITE_SINGLE_COIL    0x05       // 写单个线圈
#define FC_WRITE_SINGLE_REG     0x06       // 写单个寄存器
#define FC_WRITE_MULTIPLE_COILS 0x0F       // 写多个线圈
#define FC_WRITE_MULTIPLE_REGS  0x10       // 写多个寄存器
```

### 3.2 Modbus寄存器映射

#### 3.2.1 输入寄存器映射 (功能码0x04)
只读寄存器，用于读取系统状态和传感器数据：

```c
// 输入寄存器地址映射 (起始地址30001)
typedef enum {
    // 系统状态寄存器 (30001-30010)
    REG_SYSTEM_STATUS_HIGH     = 30001,   // 系统状态高字
    REG_SYSTEM_STATUS_LOW      = 30002,   // 系统状态低字
    REG_FAULT_CODE             = 30003,   // 故障代码
    REG_SAFETY_STATUS          = 30004,   // 安全状态
    REG_CYCLE_COUNTER_HIGH     = 30005,   // 循环计数器高字
    REG_CYCLE_COUNTER_LOW      = 30006,   // 循环计数器低字
    REG_ERROR_COUNTER          = 30007,   // 错误计数器
    REG_UPTIME_HOURS           = 30008,   // 运行时间(小时)
    REG_UPTIME_MINUTES         = 30009,   // 运行时间(分钟)
    REG_FIRMWARE_VERSION       = 30010,   // 固件版本

    // 传感器数据寄存器 (30011-30024)
    REG_LIQUID_LEVEL_1_HIGH    = 30011,   // 液位1高字(IEEE754)
    REG_LIQUID_LEVEL_1_LOW     = 30012,   // 液位1低字
    REG_LIQUID_LEVEL_2_HIGH    = 30013,   // 液位2高字
    REG_LIQUID_LEVEL_2_LOW     = 30014,   // 液位2低字
    REG_PRESSURE_1_HIGH        = 30015,   // 压力1高字
    REG_PRESSURE_1_LOW         = 30016,   // 压力1低字
    REG_PRESSURE_2_HIGH        = 30017,   // 压力2高字
    REG_PRESSURE_2_LOW         = 30018,   // 压力2低字
    REG_TEMPERATURE_1_HIGH     = 30019,   // 温度1高字
    REG_TEMPERATURE_1_LOW      = 30020,   // 温度1低字
    REG_TEMPERATURE_2_HIGH     = 30021,   // 温度2高字
    REG_TEMPERATURE_2_LOW      = 30022,   // 温度2低字
    REG_TEMPERATURE_3_HIGH     = 30023,   // 温度3高字
    REG_TEMPERATURE_3_LOW      = 30024,   // 温度3低字

    // 执行器状态寄存器 (30025-30040)
    REG_HEATER_1_POWER_HIGH    = 30025,   // 加热器1功率高字
    REG_HEATER_1_POWER_LOW     = 30026,   // 加热器1功率低字
    REG_HEATER_2_POWER_HIGH    = 30027,   // 加热器2功率高字
    REG_HEATER_2_POWER_LOW     = 30028,   // 加热器2功率低字
    REG_HEATER_3_POWER_HIGH    = 30029,   // 加热器3功率高字
    REG_HEATER_3_POWER_LOW     = 30030,   // 加热器3功率低字
    REG_PUMP_1_SPEED           = 30031,   // 泵1转速
    REG_PUMP_2_SPEED           = 30032,   // 泵2转速
    REG_VALVE_STATES           = 30033,   // 阀门状态
    REG_ACTUATOR_FAULTS        = 30034,   // 执行器故障状态
} modbus_input_register_t;
```

#### 3.2.2 保持寄存器映射 (功能码0x03/0x06/0x10)
可读写寄存器，用于设定参数和控制命令：

```c
// 保持寄存器地址映射 (起始地址40001)
typedef enum {
    // 控制寄存器 (40001-40010)
    REG_CONTROL_WORD           = 40001,   // 控制字
    REG_COMMAND_CODE           = 40002,   // 命令代码
    REG_CONTROL_MODE           = 40003,   // 控制模式
    REG_SAFETY_ENABLE          = 40004,   // 安全使能
    REG_WATCHDOG_COUNTER       = 40005,   // 看门狗计数器

    // 设定值寄存器 (40011-40024)
    REG_TEMP_SETPOINT_1_HIGH   = 40011,   // 温度设定点1高字
    REG_TEMP_SETPOINT_1_LOW    = 40012,   // 温度设定点1低字
    REG_TEMP_SETPOINT_2_HIGH   = 40013,   // 温度设定点2高字
    REG_TEMP_SETPOINT_2_LOW    = 40014,   // 温度设定点2低字
    REG_TEMP_SETPOINT_3_HIGH   = 40015,   // 温度设定点3高字
    REG_TEMP_SETPOINT_3_LOW    = 40016,   // 温度设定点3低字
    REG_PRESSURE_SETPOINT_1_HIGH = 40017, // 压力设定点1高字
    REG_PRESSURE_SETPOINT_1_LOW  = 40018, // 压力设定点1低字
    REG_PRESSURE_SETPOINT_2_HIGH = 40019, // 压力设定点2高字
    REG_PRESSURE_SETPOINT_2_LOW  = 40020, // 压力设定点2低字

    // 执行器控制寄存器 (40025-40040)
    REG_HEATER_1_SETPOINT_HIGH = 40025,   // 加热器1设定功率高字
    REG_HEATER_1_SETPOINT_LOW  = 40026,   // 加热器1设定功率低字
    REG_HEATER_2_SETPOINT_HIGH = 40027,   // 加热器2设定功率高字
    REG_HEATER_2_SETPOINT_LOW  = 40028,   // 加热器2设定功率低字
    REG_HEATER_3_SETPOINT_HIGH = 40029,   // 加热器3设定功率高字
    REG_HEATER_3_SETPOINT_LOW  = 40030,   // 加热器3设定功率低字
    REG_PUMP_1_SETPOINT        = 40031,   // 泵1设定转速
    REG_PUMP_2_SETPOINT        = 40032,   // 泵2设定转速
    REG_VALVE_SETPOINTS        = 40033,   // 阀门控制设定
} modbus_holding_register_t;
```

#### 3.2.3 线圈映射 (功能码0x01/0x05/0x0F)
数字输入输出控制：

```c
// 线圈地址映射 (起始地址00001)
typedef enum {
    // 系统控制线圈 (00001-00010)
    COIL_SYSTEM_ENABLE         = 00001,   // 系统使能
    COIL_CONTROL_ENABLE        = 00002,   // 控制使能
    COIL_SAFETY_ENABLE         = 00003,   // 安全使能
    COIL_EMERGENCY_STOP        = 00004,   // 急停
    COIL_RESET_FAULTS          = 00005,   // 复位故障
    COIL_AUTO_MODE             = 00006,   // 自动模式
    COIL_MANUAL_MODE           = 00007,   // 手动模式

    // 阀门控制线圈 (00011-00018)
    COIL_VALVE_1               = 00011,   // 阀门1
    COIL_VALVE_2               = 00012,   // 阀门2
    COIL_VALVE_3               = 00013,   // 阀门3
    COIL_VALVE_4               = 00014,   // 阀门4
    COIL_VALVE_5               = 00015,   // 阀门5
    COIL_VALVE_6               = 00016,   // 阀门6
    COIL_VALVE_7               = 00017,   // 阀门7
    COIL_VALVE_8               = 00018,   // 阀门8
} modbus_coil_t;
```

### 3.3 Modbus数据格式

#### 3.3.1 浮点数据格式
Modbus协议中浮点数使用IEEE 754标准，占用2个16位寄存器：

```c
// 浮点数据转换
typedef union {
    float value;
    struct {
        uint16_t low_word;   // 低16位
        uint16_t high_word;  // 高16位
    } words;
} float_to_modbus_t;

// 转换示例
float temperature = 25.5;
float_to_modbus_t converter;
converter.value = temperature;
uint16_t temp_high = converter.words.high_word;  // 高字
uint16_t temp_low = converter.words.low_word;    // 低字
```

#### 3.3.2 错误响应格式
```c
// Modbus异常代码
#define MODBUS_EXCEPTION_ILLEGAL_FUNCTION      0x01
#define MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS  0x02
#define MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE    0x03
#define MODBUS_EXCEPTION_SLAVE_DEVICE_FAILURE  0x04
#define MODBUS_EXCEPTION_ACKNOWLEDGE           0x05
#define MODBUS_EXCEPTION_SLAVE_DEVICE_BUSY     0x06
```

## 4. 自定义TCP通信协议

### 4.1 自定义TCP协议基本格式

#### 4.1.1 协议帧结构
```c
// 自定义TCP协议帧头
typedef struct {
    uint16_t sync_word;      // 同步字 0xAA55
    uint16_t frame_length;   // 帧长度(包含帧头)
    uint8_t  frame_type;     // 帧类型
    uint8_t  sequence;       // 序列号
    uint16_t checksum;       // 校验和(CRC16)
} __attribute__((packed)) tcp_frame_header_t;

// 完整TCP协议帧
typedef struct {
    tcp_frame_header_t header;  // 帧头(8字节)
    uint8_t data[1024];        // 数据域(最大1024字节)
} __attribute__((packed)) tcp_protocol_frame_t;
```

#### 4.1.2 帧类型定义
```c
typedef enum {
    FRAME_TYPE_HEARTBEAT       = 0x01,  // 心跳帧
    FRAME_TYPE_DATA_REQUEST    = 0x02,  // 数据请求
    FRAME_TYPE_DATA_RESPONSE   = 0x03,  // 数据响应
    FRAME_TYPE_CONTROL_REQUEST = 0x04,  // 控制请求
    FRAME_TYPE_CONTROL_RESPONSE= 0x05,  // 控制响应
    FRAME_TYPE_CONFIG_REQUEST  = 0x06,  // 配置请求
    FRAME_TYPE_CONFIG_RESPONSE = 0x07,  // 配置响应
    FRAME_TYPE_STATUS_REQUEST  = 0x08,  // 状态请求
    FRAME_TYPE_STATUS_RESPONSE = 0x09,  // 状态响应
    FRAME_TYPE_ALARM_NOTIFY    = 0x0A,  // 报警通知
    FRAME_TYPE_EVENT_NOTIFY    = 0x0B,  // 事件通知
    FRAME_TYPE_FILE_TRANSFER   = 0x0C,  // 文件传输
    FRAME_TYPE_FIRMWARE_UPDATE = 0x0D,  // 固件升级
    FRAME_TYPE_ERROR_RESPONSE  = 0xFF   // 错误响应
} tcp_frame_type_t;
```

### 4.2 数据请求响应协议

#### 4.2.1 传感器数据请求
```c
// 数据请求帧数据域
typedef struct {
    uint8_t data_type;       // 数据类型
    uint8_t sensor_mask;     // 传感器掩码
    uint16_t reserved;       // 保留
} __attribute__((packed)) data_request_t;

// 数据类型定义
#define DATA_TYPE_ALL_SENSORS      0x00  // 所有传感器数据
#define DATA_TYPE_LIQUID_LEVEL     0x01  // 液位数据
#define DATA_TYPE_PRESSURE         0x02  // 压力数据
#define DATA_TYPE_TEMPERATURE      0x03  // 温度数据
#define DATA_TYPE_SYSTEM_STATUS    0x04  // 系统状态
#define DATA_TYPE_ACTUATOR_STATUS  0x05  // 执行器状态
```

#### 4.2.2 传感器数据响应
```c
// 数据响应帧数据域
typedef struct {
    uint32_t timestamp;      // 时间戳
    uint8_t data_valid;      // 数据有效标志
    uint8_t reserved[3];     // 保留

    // 传感器数据
    struct {
        float liquid_level[2];   // 液位数据
        float pressure[2];       // 压力数据
        float temperature[3];    // 温度数据
    } sensor_data;

    // 状态数据
    struct {
        uint16_t system_status;  // 系统状态
        uint16_t fault_code;     // 故障代码
        uint16_t safety_status;  // 安全状态
        uint16_t reserved;       // 保留
    } status_data;

} __attribute__((packed)) data_response_t;
```

### 4.3 控制请求响应协议

#### 4.3.1 控制命令请求
```c
// 控制请求帧数据域
typedef struct {
    uint8_t control_type;    // 控制类型
    uint8_t target_id;       // 目标ID
    uint16_t reserved;       // 保留

    union {
        // 加热器控制
        struct {
            float power_percent; // 功率百分比
        } heater_control;

        // 泵控制
        struct {
            uint16_t speed_rpm;  // 转速
        } pump_control;

        // 阀门控制
        struct {
            uint8_t valve_state; // 阀门状态
        } valve_control;

        // 系统控制
        struct {
            uint16_t command;    // 系统命令
            uint16_t parameter;  // 命令参数
        } system_control;

    } control_data;

} __attribute__((packed)) control_request_t;

// 控制类型定义
#define CONTROL_TYPE_HEATER    0x01  // 加热器控制
#define CONTROL_TYPE_PUMP      0x02  // 泵控制
#define CONTROL_TYPE_VALVE     0x03  // 阀门控制
#define CONTROL_TYPE_SYSTEM    0x04  // 系统控制
```

#### 4.3.2 控制命令响应
```c
// 控制响应帧数据域
typedef struct {
    uint8_t result_code;     // 结果代码
    uint8_t control_type;    // 控制类型
    uint8_t target_id;       // 目标ID
    uint8_t reserved;        // 保留
    uint32_t timestamp;      // 执行时间戳
    char message[32];        // 结果消息
} __attribute__((packed)) control_response_t;

// 结果代码定义
#define RESULT_SUCCESS         0x00  // 执行成功
#define RESULT_INVALID_PARAM   0x01  // 参数无效
#define RESULT_ACCESS_DENIED   0x02  // 访问被拒绝
#define RESULT_DEVICE_BUSY     0x03  // 设备忙
#define RESULT_HARDWARE_ERROR  0x04  // 硬件错误
#define RESULT_TIMEOUT         0x05  // 执行超时
```

### 4.4 配置管理协议

#### 4.4.1 配置读取请求
```c
// 配置请求帧数据域
typedef struct {
    uint8_t config_type;     // 配置类型
    uint16_t config_id;      // 配置ID
    uint8_t reserved;        // 保留
} __attribute__((packed)) config_request_t;

// 配置类型定义
#define CONFIG_TYPE_SYSTEM     0x01  // 系统配置
#define CONFIG_TYPE_CONTROL    0x02  // 控制配置
#define CONFIG_TYPE_SAFETY     0x03  // 安全配置
#define CONFIG_TYPE_NETWORK    0x04  // 网络配置
#define CONFIG_TYPE_CALIBRATION 0x05 // 校准配置
```

#### 4.4.2 配置数据响应
```c
// 配置响应帧数据域
typedef struct {
    uint8_t config_type;     // 配置类型
    uint16_t config_id;      // 配置ID
    uint16_t data_length;    // 数据长度
    uint8_t reserved;        // 保留
    uint8_t config_data[256]; // 配置数据
} __attribute__((packed)) config_response_t;
```

## 5. 通信安全和认证

### 5.1 访问控制
```c
// 客户端认证信息
typedef struct {
    uint32_t client_id;      // 客户端ID
    uint32_t access_level;   // 访问级别
    uint32_t session_key;    // 会话密钥
    uint32_t timestamp;      // 时间戳
} client_auth_t;

// 访问级别定义
#define ACCESS_LEVEL_GUEST     0x01  // 访客(只读)
#define ACCESS_LEVEL_OPERATOR  0x02  // 操作员(控制)
#define ACCESS_LEVEL_ENGINEER  0x03  // 工程师(配置)
#define ACCESS_LEVEL_ADMIN     0x04  // 管理员(全部)
```

### 5.2 数据完整性校验
```c
// CRC16校验算法
uint16_t crc16_calculate(const uint8_t* data, uint16_t length) {
    uint16_t crc = 0xFFFF;
    for (uint16_t i = 0; i < length; i++) {
        crc ^= data[i];
        for (uint8_t j = 0; j < 8; j++) {
            if (crc & 0x0001) {
                crc = (crc >> 1) ^ 0xA001;
            } else {
                crc >>= 1;
            }
        }
    }
    return crc;
}
```

## 6. 通信性能规格

### 6.1 性能指标
| 协议类型 | 最大吞吐量 | 延迟 | 并发连接 | 数据更新率 |
|----------|------------|------|----------|------------|
| EtherCAT | 100Mbps | <1ms | 1主站 | 1000Hz |
| Modbus TCP | 10Mbps | <50ms | 4客户端 | 20Hz |
| 自定义TCP | 100Mbps | <100ms | 8客户端 | 10Hz |
| Modbus RTU | 115.2kbps | <200ms | 1客户端 | 5Hz |

### 6.2 数据实时性要求
```c
// 实时性分级
typedef enum {
    REALTIME_CRITICAL,   // 关键实时 (<1ms) - EtherCAT
    REALTIME_HIGH,       // 高实时 (<10ms) - 快速控制
    REALTIME_NORMAL,     // 普通实时 (<100ms) - 一般控制
    REALTIME_LOW         // 低实时 (<1s) - 监控数据
} realtime_level_t;
```

---
**文档版本**: V4.0
**创建日期**: 2024-12-27
**维护者**: 供墨系统通信协议开发团队