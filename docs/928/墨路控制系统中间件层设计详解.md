# 墨路控制系统中间件层设计详解

## 1. 中间件层在系统中的位置

### 1.1 四层架构中的作用
```
应用层 (app/)           ← 业务逻辑：传感器任务、控制任务、安全任务等
    ↓ 调用中间件服务
中间件层 (middleware/)   ← 算法和系统服务：滤波、PID、任务管理等  [我们讨论的重点]
    ↓ 调用HAL接口
HAL层 (hal/)           ← 硬件抽象：ADC、GPIO、UART等统一接口
    ↓ 调用底层驱动
驱动层 (drivers/)      ← 设备驱动：传感器驱动、执行器驱动等
```

### 1.2 中间件层的职责
中间件层是**算法和系统服务的提供者**，它：
- **不直接操作硬件** - 这是HAL层和驱动层的事
- **不包含业务逻辑** - 这是应用层的事
- **提供通用算法和服务** - 供应用层调用

## 2. 滤波器详解

### 2.1 滤波器的必要性

#### 2.1.1 为什么需要滤波器？
在墨路控制系统中，传感器读取的原始数据通常包含：

```
实际传感器读取值：
时间    温度读数     问题
0ms     25.2°C      正常
100ms   25.1°C      正常
200ms   27.8°C      ← 干扰！实际温度不可能瞬间跳这么多
300ms   25.3°C      正常
400ms   25.0°C      正常
500ms   24.9°C      正常
```

**干扰来源：**
- **电磁干扰** - 电机、继电器开关产生的电磁波
- **电源纹波** - 开关电源的纹波干扰ADC
- **机械振动** - 设备运行时的振动影响传感器
- **温度漂移** - 器件温度变化导致的误差

#### 2.1.2 不使用滤波器的后果
```c
// 应用层的控制逻辑
void temperature_control_task(void)
{
    float temp = sensor_read_temperature(1);  // 读取原始值

    if (temp > 30.0) {
        // 温度过高，开启冷却
        actuator_set_fan(1, 100);  // 风扇全速
    } else {
        actuator_set_fan(1, 0);     // 关闭风扇
    }
}
```

**问题**：如果温度在29.8°C和30.2°C之间波动（由于干扰），风扇会疯狂开关！

### 2.2 滤波器在系统中的位置

#### 2.2.1 数据流向
```
传感器硬件 → 驱动层读取原始值 → HAL层ADC转换 → 中间件滤波处理 → 应用层使用干净数据
     ↓              ↓                ↓              ↓                ↓
   物理信号        数字原始值        标准接口值      滤波后稳定值      业务处理
```

#### 2.2.2 具体实现位置
**方案1：在传感器任务中调用滤波器（推荐）**
```c
// app/sensor_task.c
void sensor_task(void *pvParameters)
{
    float raw_temp, filtered_temp;
    moving_average_filter_t temp_filter;

    // 初始化滤波器
    filter_init(&temp_filter);

    while(1)
    {
        // 读取原始数据
        raw_temp = sensor_read_temperature_raw(1);  // 驱动层提供

        // 调用中间件滤波器处理
        filtered_temp = moving_average_filter(&temp_filter, raw_temp);

        // 存储滤波后的数据供其他任务使用
        g_system_data.temp_values[0] = filtered_temp;

        vTaskDelay(pdMS_TO_TICKS(50));  // 50ms采样一次
    }
}
```

**方案2：在HAL层集成滤波**
```c
// hal/adc_hal.c
hal_status_t adc_hal_read_sensor(sensor_type_t sensor, float* value)
{
    float raw_value;
    static moving_average_filter_t filters[SENSOR_COUNT];

    // 读取ADC原始值
    raw_value = adc_read_channel(sensor_channel_map[sensor]);

    // 应用滤波器
    *value = moving_average_filter(&filters[sensor], raw_value);

    return HAL_OK;
}
```

### 2.3 滤波器类型选择

#### 2.3.1 滑动平均滤波器 - 最常用
```c
typedef struct {
    float buffer[16];    // 保存最近16个值
    uint8_t index;       // 当前位置
    uint8_t count;       // 已存储数量
    float sum;          // 累加和
} moving_average_filter_t;

float moving_average_filter(moving_average_filter_t* filter, float input)
{
    // 替换最旧的值
    filter->sum -= filter->buffer[filter->index];
    filter->buffer[filter->index] = input;
    filter->sum += input;

    filter->index = (filter->index + 1) % 16;
    if (filter->count < 16) filter->count++;

    // 返回平均值
    return filter->sum / filter->count;
}
```

**适用场景：**
- 温度传感器（变化较慢）
- 压力传感器（需要稳定读数）
- 液位传感器（避免波动）

#### 2.3.2 卡尔曼滤波器 - 高精度场合
```c
typedef struct {
    float Q;     // 过程噪声 (系统不确定性)
    float R;     // 测量噪声 (传感器不确定性)
    float P;     // 估计误差协方差
    float K;     // 卡尔曼增益
    float X;     // 状态估计 (滤波后的值)
} kalman_filter_t;
```

**适用场景：**
- 关键安全传感器
- 精度要求很高的测量
- 需要预测趋势的场合

#### 2.3.3 低通滤波器 - 简单快速
```c
float low_pass_filter(float input, float prev_output, float alpha)
{
    // alpha = 滤波系数 (0-1)，越小滤波效果越强
    return alpha * input + (1 - alpha) * prev_output;
}
```

**适用场景：**
- 实时性要求高
- 内存资源紧张
- 简单去除高频噪声

### 2.4 滤波器使用示例

#### 2.4.1 温度控制中的应用
```c
// app/control_task.c
void temperature_control_task(void)
{
    float filtered_temp;

    // 获取经过滤波的温度值（传感器任务已经处理过）
    filtered_temp = g_system_data.temp_values[0];

    // 现在可以安全地进行控制判断
    if (filtered_temp > TEMP_THRESHOLD + 0.5) {      // 30.5°C开启
        actuator_set_fan(1, 80);
    } else if (filtered_temp < TEMP_THRESHOLD - 0.5) { // 29.5°C关闭
        actuator_set_fan(1, 0);
    }
    // 29.5°C到30.5°C之间保持当前状态，避免频繁开关
}
```

#### 2.4.2 液位监控中的应用
```c
// app/safety_task.c
void level_safety_check(void)
{
    float filtered_level = g_system_data.level_values[0];  // 已滤波

    // 液位保护逻辑
    if (filtered_level > LEVEL_HIGH_ALARM) {
        // 液位过高，停止进料泵
        actuator_set_pump(PUMP_INLET, 0);
        safety_alarm(ALARM_LEVEL_HIGH);
    }

    if (filtered_level < LEVEL_LOW_ALARM) {
        // 液位过低，停止出料泵
        actuator_set_pump(PUMP_OUTLET, 0);
        safety_alarm(ALARM_LEVEL_LOW);
    }
}
```

## 3. 任务管理器详解

### 3.1 任务管理器是否必需？

**简短回答：不是必需的，但非常有用！**

### 3.2 为什么需要任务管理器？

#### 3.2.1 没有任务管理器的问题
```c
// 传统方式：在main.c中直接创建任务
int main(void)
{
    // 系统初始化
    system_init();

    // 手动创建每个任务 - 繁琐且难管理
    xTaskCreate(sensor_task, "sensor", 1024, NULL, 8, NULL);
    xTaskCreate(control_task, "control", 1536, NULL, 12, NULL);
    xTaskCreate(safety_task, "safety", 1024, NULL, 15, NULL);
    xTaskCreate(actuator_task, "actuator", 1024, NULL, 8, NULL);
    xTaskCreate(hmi_task, "hmi", 1024, NULL, 5, NULL);
    xTaskCreate(comm_task, "comm", 2048, NULL, 5, NULL);
    xTaskCreate(config_task, "config", 1024, NULL, 2, NULL);

    vTaskStartScheduler();
}
```

**问题：**
- 任务信息分散，难以管理
- 无法动态监控任务状态
- 调试时不知道任务执行情况
- 性能分析困难

#### 3.2.2 使用任务管理器的优势
```c
// middleware/tasks.c - 统一管理
typedef struct {
    TaskHandle_t handle;          // 任务句柄
    char name[16];               // 任务名称
    uint32_t stack_size;         // 栈大小
    UBaseType_t priority;        // 优先级
    uint32_t run_count;          // 运行次数统计
    uint32_t max_execution_time; // 最大执行时间
    uint32_t avg_execution_time; // 平均执行时间
    bool enabled;                // 是否使能
    TaskStatus_t status;         // 任务状态
} task_info_t;

typedef struct {
    task_info_t tasks[MAX_TASKS]; // 任务信息表
    uint8_t task_count;          // 任务数量
    uint32_t system_tick;        // 系统滴答
    uint32_t cpu_usage;          // CPU使用率
    uint32_t free_heap;          // 剩余堆内存
} task_manager_t;
```

### 3.3 任务管理器的功能

#### 3.3.1 任务创建和管理
```c
// middleware/tasks.c
hal_status_t task_manager_create_task(
    TaskFunction_t task_func,
    const char* name,
    uint32_t stack_size,
    void* parameters,
    UBaseType_t priority,
    TaskHandle_t* handle
)
{
    task_info_t* task_info = &task_manager.tasks[task_manager.task_count];

    // 创建FreeRTOS任务
    BaseType_t result = xTaskCreate(
        task_func,
        name,
        stack_size,
        parameters,
        priority,
        &task_info->handle
    );

    if (result == pdPASS) {
        // 记录任务信息
        strcpy(task_info->name, name);
        task_info->stack_size = stack_size;
        task_info->priority = priority;
        task_info->run_count = 0;
        task_info->enabled = true;

        *handle = task_info->handle;
        task_manager.task_count++;

        return HAL_OK;
    }

    return HAL_ERROR;
}
```

#### 3.3.2 任务状态监控
```c
void task_manager_update_statistics(void)
{
    for (int i = 0; i < task_manager.task_count; i++) {
        task_info_t* task = &task_manager.tasks[i];

        // 获取任务运行状态
        vTaskGetInfo(
            task->handle,
            &task->status,
            pdTRUE,  // 包括栈高水位
            eInvalid
        );

        // 更新统计信息
        task->run_count++;
    }

    // 更新系统信息
    task_manager.free_heap = xPortGetFreeHeapSize();
    task_manager.system_tick = xTaskGetTickCount();
}
```

#### 3.3.3 性能分析和调试
```c
void task_manager_print_status(void)
{
    printf("=== Task Manager Status ===\n");
    printf("Task Name      | Priority | Stack Used | CPU%% | Status\n");
    printf("---------------|----------|------------|------|-------\n");

    for (int i = 0; i < task_manager.task_count; i++) {
        task_info_t* task = &task_manager.tasks[i];

        printf("%-14s | %8d | %10d | %4d | %s\n",
            task->name,
            task->priority,
            task->stack_size - task->status.usStackHighWaterMark,
            task->cpu_usage,
            task_state_to_string(task->status.eCurrentState)
        );
    }

    printf("Free Heap: %d bytes\n", task_manager.free_heap);
    printf("========================\n");
}
```

### 3.4 任务管理器的实际价值

#### 3.4.1 开发阶段
- **栈溢出检测**：监控各任务栈使用情况
- **性能分析**：找出CPU占用高的任务
- **调试支持**：快速定位任务异常

#### 3.4.2 运行阶段
- **系统监控**：实时了解系统运行状态
- **故障诊断**：任务死锁、异常退出检测
- **资源管理**：内存泄漏监控

#### 3.4.3 通过USMART调试
```c
// 在usmart_config.c中注册任务管理器函数
(void*)task_manager_print_status, "void task_manager_print_status(void)",
(void*)task_manager_get_cpu_usage, "u32 task_manager_get_cpu_usage(void)",
```

**在串口工具中调用：**
```bash
# 查看任务状态
task_manager_print_status()

# 查看CPU使用率
task_manager_get_cpu_usage()
```

## 4. 中间件层的其他组件

### 4.1 PID控制器 (middleware/pid.c)
```c
// 为什么需要PID控制器？
// 控制系统的核心算法，用于精确控制温度、压力、流量等

// 温度控制示例
void temperature_control_loop(void)
{
    float current_temp = get_filtered_temperature(1);  // 使用滤波后的值
    float output = pid_compute(&temp_pid, current_temp);
    actuator_set_heater_power(1, output);  // 设置加热功率
}
```

### 4.2 协议解析器 (middleware/protocol.c)
```c
// TCP/EtherCAT通信协议的解析和封装
// 避免在应用层重复写协议处理代码

typedef struct {
    uint16_t cmd;
    uint16_t len;
    uint8_t data[];
} protocol_frame_t;

hal_status_t protocol_parse_frame(uint8_t* buffer, protocol_frame_t* frame);
hal_status_t protocol_build_response(protocol_frame_t* request, protocol_frame_t* response);
```

### 4.3 保持现有中间件
```
middleware/
├── delay/          ← 保持现有延时功能
├── sys/            ← 保持现有系统配置
├── usart/          ← 保持现有串口功能
├── pid.c/h         ← 新增PID算法
├── filter.c/h      ← 新增滤波算法
├── tasks.c/h       ← 新增任务管理器（可选）
└── protocol.c/h    ← 新增协议处理
```

## 5. 实施建议

### 5.1 必需组件（建议优先实现）
1. **滤波器** - 传感器数据质量的保证
2. **PID控制器** - 控制精度的保证

### 5.2 可选组件（后期优化）
1. **任务管理器** - 开发和调试的便利工具
2. **协议解析器** - 通信功能的封装

### 5.3 分阶段实施
```
第一阶段：基础功能
- 实现滑动平均滤波器
- 实现简单PID控制器
- 保持现有delay/sys/usart功能

第二阶段：完善功能
- 添加卡尔曼滤波器
- 完善PID控制器功能
- 添加协议解析器

第三阶段：调试优化
- 实现任务管理器
- 性能监控和分析
- 系统调试优化
```

## 6. 总结

### 6.1 滤波器
- **必需性**：高 - 保证传感器数据质量
- **位置**：传感器任务或HAL层
- **类型**：优先滑动平均，关键部位用卡尔曼

### 6.2 任务管理器
- **必需性**：中 - 开发和维护的便利工具
- **价值**：提高开发效率，便于系统监控
- **实施**：可以后期添加，不影响核心功能

### 6.3 中间件层设计原则
- **服务导向**：为应用层提供算法和服务
- **通用性**：避免业务逻辑，保持通用性
- **可选性**：核心功能必需，辅助功能可选
- **渐进性**：可以分阶段实施，逐步完善

中间件层是系统稳定性和可维护性的关键，滤波器解决数据质量问题，任务管理器解决开发效率问题，都有其价值！

---

*文档版本: v1.0*
*创建时间: 2025-09-29*
*详细解释中间件层设计思路和组件作用*