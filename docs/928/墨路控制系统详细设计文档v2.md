# å¢¨è·¯æ§åˆ¶ç³»ç»Ÿè¯¦ç»†è®¾è®¡æ–‡æ¡£ v2

## 1. ç³»ç»Ÿæ¦‚è¿°

### 1.1 æŠ€æœ¯é€‰å‹
- **MCU**: GD32F427
- **æ“ä½œç³»ç»Ÿ**: FreeRTOS
- **ç½‘ç»œåè®®æ ˆ**: lwIP
- **é€šä¿¡åè®®**: EtherCATå¼€æºåº“
- **HALåº“**: GD32 HALåº“

### 1.2 ç³»ç»Ÿæ¶æ„
é‡‡ç”¨å››å±‚åˆ†å±‚æ¶æ„è®¾è®¡ï¼š
```
åº”ç”¨å±‚ (Application Layer)
    â†“
ä¸­é—´ä»¶å±‚ (Middleware Layer)
    â†“
HALå±‚ (Hardware Abstraction Layer)
    â†“
é©±åŠ¨å±‚ (Driver Layer)
```

### 1.3 ä»£ç ç›®å½•ç»“æ„
```
ink_supply_gd32f427/
â”œâ”€â”€ ğŸ“ src/                                # æºä»£ç ç›®å½• (æç®€)
â”‚   â”œâ”€â”€ ğŸ“„ main.c                          # ä¸»ç¨‹åºå…¥å£
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“ app/                            # åº”ç”¨å±‚ (åŠŸèƒ½åˆå¹¶)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ actuator_task.c/h           # 3ç§æ‰§è¡Œå™¨é›†æˆ (MRA23D3+MPB025BBB+é˜€é—¨)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ app_main.c/h                # åº”ç”¨ä¸»ç¨‹åº
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ comm_task.c/h               # åŒåè®®é€šä¿¡ (EtherCAT+TCP/IP)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ config_task.c/h             # é…ç½®ç®¡ç† (Flashå­˜å‚¨+å‚æ•°)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ control_task.c/h            # PIDæ§åˆ¶ç®—æ³• (æ¸©åº¦+å‹åŠ›+æ¶²ä½)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ ethercat_app.c/h            # EtherCATåº”ç”¨
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ hmi_task.c/h                # æ˜¾ç¤ºç³»ç»Ÿ (LCD+5è·¯LED)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ safety_task.c/h             # å®‰å…¨ä¿æŠ¤ (æ•…éšœæ£€æµ‹+ç´§æ€¥åœæœº)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ sensor_task.c/h             # 3ç§ä¼ æ„Ÿå™¨é›†æˆ (FRD8061+HP10MY+FTT518)
â”‚   â”‚   â””â”€â”€ ğŸ“„ tcp_server.c/h              # TCPæœåŠ¡å™¨
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“ middleware/                     # ä¸­é—´ä»¶å±‚ (æœ€å°åŒ–)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ filter.c/h                  # æ•°å­—æ»¤æ³¢ (æ»‘åŠ¨å¹³å‡+å¡å°”æ›¼)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ middleware_common.c/h       # ä¸­é—´ä»¶å…¬å…±åŠŸèƒ½
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ pid.c/h                     # PIDç®—æ³• (ç®€åŒ–ç‰ˆ)
â”‚   â”‚   â””â”€â”€ ğŸ“„ tasks.c/h                   # FreeRTOSä»»åŠ¡ç®¡ç†
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“ hal/                            # ç¡¬ä»¶æŠ½è±¡å±‚ (åŸºäºGD32 HAL)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ adc_hal.c/h                 # ADCå¤„ç† (ä¼ æ„Ÿå™¨é‡‡é›†)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ eth_hal.c/h                 # ä»¥å¤ªç½‘å¤„ç† (ç½‘ç»œé€šä¿¡)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ flash_hal.c/h               # Flashå¤„ç† (é…ç½®å­˜å‚¨)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ gpio_hal.c/h                # GPIOå¤„ç† (æ•°å­—IO)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ hal_common.c/h              # HALå…¬å…±åŠŸèƒ½
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ hal_manager.c/h             # HALç®¡ç†å™¨
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ i2c_hal.c/h                 # I2Cå¤„ç† (ä¼ æ„Ÿå™¨é€šä¿¡)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ pwm_hal.c/h                 # PWMå¤„ç† (æ‰§è¡Œå™¨æ§åˆ¶)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ spi_hal.c/h                 # SPIå¤„ç† (LCDæ˜¾ç¤º)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ timer_hal.c/h               # å®šæ—¶å™¨å¤„ç†
â”‚   â”‚   â””â”€â”€ ğŸ“„ uart_hal.c/h                # UARTå¤„ç† (è°ƒè¯•+é€šä¿¡)
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“ drivers/                        # è®¾å¤‡é©±åŠ¨å±‚
â”‚   â”‚   â”œâ”€â”€ ğŸ“ actuators/                  # æ‰§è¡Œå™¨é©±åŠ¨
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ led_control.c/h         # LEDæ§åˆ¶é©±åŠ¨
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ mpb025bbb_driver.c/h    # MPB025BBBæ³µé©±åŠ¨
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ mra23d3_driver.c/h      # MRA23D3ç”µæœºé©±åŠ¨
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ valve_control.c/h       # é˜€é—¨æ§åˆ¶é©±åŠ¨
â”‚   â”‚   â””â”€â”€ ğŸ“ sensors/                    # ä¼ æ„Ÿå™¨é©±åŠ¨
â”‚   â”‚       â”œâ”€â”€ ğŸ“„ frd8061_driver.c/h      # FRD8061æ¶²ä½ä¼ æ„Ÿå™¨é©±åŠ¨
â”‚   â”‚       â”œâ”€â”€ ğŸ“„ ftt518_driver.c/h       # FTT518æ¸©åº¦ä¼ æ„Ÿå™¨é©±åŠ¨
â”‚   â”‚       â””â”€â”€ ğŸ“„ hp10my_driver.c/h       # HP10MYå‹åŠ›ä¼ æ„Ÿå™¨é©±åŠ¨
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“ board/                          # æ¿çº§æ”¯æŒåŒ…
â”‚   â”‚   â””â”€â”€ ğŸ“„ board_init.c/h              # æ¿çº§åˆå§‹åŒ–
â”‚   â”‚
â”‚   â””â”€â”€ ğŸ“ system/                         # ç³»ç»Ÿç®¡ç†
â”‚       â”œâ”€â”€ ğŸ“„ error_handler.c/h           # é”™è¯¯å¤„ç†
â”‚       â”œâ”€â”€ ğŸ“„ system_manager.c/h          # ç³»ç»Ÿç®¡ç†å™¨
â”‚       â””â”€â”€ ğŸ“„ task_scheduler.c/h          # ä»»åŠ¡è°ƒåº¦å™¨
â”‚
â”œâ”€â”€ ğŸ“ include/                            # å¤´æ–‡ä»¶ç›®å½•
â”‚   â”œâ”€â”€ ğŸ“ app/                            # åº”ç”¨å±‚å¤´æ–‡ä»¶
â”‚   â”œâ”€â”€ ğŸ“ common/                         # å…¬å…±å¤´æ–‡ä»¶
â”‚   â”œâ”€â”€ ğŸ“ config/                         # é…ç½®å¤´æ–‡ä»¶
â”‚   â”œâ”€â”€ ğŸ“ drivers/                        # é©±åŠ¨å¤´æ–‡ä»¶
â”‚   â”œâ”€â”€ ğŸ“ hal/                            # HALå¤´æ–‡ä»¶
â”‚   â”œâ”€â”€ ğŸ“ middleware/                     # ä¸­é—´ä»¶å¤´æ–‡ä»¶
â”‚   â””â”€â”€ ğŸ“ system/                         # ç³»ç»Ÿå¤´æ–‡ä»¶
â”‚
â”œâ”€â”€ ğŸ“ lib/                                # ç¬¬ä¸‰æ–¹åº“ (ç°æˆåº“ç›´æ¥ä½¿ç”¨)
â”‚   â”œâ”€â”€ ğŸ“ GD32F4xx_HAL/                   # GD32å®˜æ–¹HALåº“
â”‚   â”œâ”€â”€ ğŸ“ FreeRTOS/                       # FreeRTOS v10.4.6
â”‚   â”œâ”€â”€ ğŸ“ lwip/                           # lwIP v2.1.3
â”‚   â””â”€â”€ ğŸ“ ethercat/                       # EtherCATå¼€æºåº“
â”‚
â”œâ”€â”€ ğŸ“ config/                             # é…ç½®æ–‡ä»¶
â”‚   â”œâ”€â”€ ğŸ“„ FreeRTOSConfig.h                # FreeRTOSé…ç½®
â”‚   â”œâ”€â”€ ğŸ“„ lwipopts.h                      # lwIPé…ç½®
â”‚   â”œâ”€â”€ ğŸ“„ gd32f4xx_hal_conf.h            # HALåº“é…ç½®
â”‚   â””â”€â”€ ğŸ“„ system_config.h                 # ç³»ç»Ÿå‚æ•°é…ç½®
â”‚
â”œâ”€â”€ ğŸ“„ CMakeLists.txt                      # CMakeæ„å»ºè„šæœ¬
â”œâ”€â”€ ğŸ“„ README.md                           # é¡¹ç›®è¯´æ˜
â””â”€â”€ ğŸ“„ .gitignore                          # Gité…ç½®
```

### 1.4 æ¨¡å—åŒ–è®¾è®¡ç†å¿µ
åŸºäºå®é™…ä»£ç ç›®å½•ç»“æ„ï¼Œç³»ç»Ÿé‡‡ç”¨é«˜åº¦æ¨¡å—åŒ–è®¾è®¡ï¼š

- **åˆ†å±‚æ¸…æ™°**: ä¸¥æ ¼æŒ‰ç…§åº”ç”¨å±‚ã€ä¸­é—´ä»¶å±‚ã€HALå±‚ã€é©±åŠ¨å±‚å››å±‚æ¶æ„
- **èŒè´£åˆ†ç¦»**: æ¯ä¸ªæ¨¡å—ä¸“æ³¨äºç‰¹å®šåŠŸèƒ½ï¼Œé™ä½è€¦åˆåº¦
- **æ¥å£æ ‡å‡†åŒ–**: ç»Ÿä¸€çš„æ¥å£è®¾è®¡ï¼Œä¾¿äºæ¨¡å—é—´åä½œ
- **å¯æ‰©å±•æ€§**: æ˜“äºæ·»åŠ æ–°çš„ä¼ æ„Ÿå™¨ã€æ‰§è¡Œå™¨æˆ–åŠŸèƒ½æ¨¡å—

## 2. åº”ç”¨å±‚è¯¦ç»†è®¾è®¡

### 2.1 ä»»åŠ¡æ¶æ„

#### 2.1.1 ä»»åŠ¡ä¼˜å…ˆçº§åˆ†é…
| ä»»åŠ¡åç§° | ä¼˜å…ˆçº§ | å‘¨æœŸ | æ ˆå¤§å° | åŠŸèƒ½æè¿° | å¯¹åº”æºæ–‡ä»¶ |
|---------|-------|------|--------|----------|-----------|
| Emergency Task | 20 | äº‹ä»¶è§¦å‘ | 1024 | ç´§æ€¥å®‰å…¨å¤„ç† | safety_task.c |
| EtherCAT Task | 18 | 1ms | 2048 | EtherCATé€šä¿¡å¤„ç† | ethercat_app.c |
| Safety Task | 15 | 10ms | 1024 | å®‰å…¨ç›‘æ§ | safety_task.c |
| Control Task | 12 | 20ms | 1536 | æ§åˆ¶é€»è¾‘ | control_task.c |
| Sensor Task | 8 | 50ms | 1024 | æ•°æ®é‡‡é›† | sensor_task.c |
| Actuator Task | 8 | 10ms | 1024 | æ‰§è¡Œå™¨ç®¡ç† | actuator_task.c |
| TCP Task | 5 | 50ms | 2048 | TCPé€šä¿¡å¤„ç† | tcp_server.c |
| LED Task | 5 | 100ms | 512 | LEDçŠ¶æ€æŒ‡ç¤º | hmi_task.c |
| HMI Task | 5 | 100ms | 1024 | äººæœºäº¤äº’ | hmi_task.c |
| Config Task | 2 | 1000ms | 1024 | é…ç½®ç®¡ç† | config_task.c |

#### 2.1.2 ä»»åŠ¡é—´é€šä¿¡æœºåˆ¶
```c
// æ¶ˆæ¯é˜Ÿåˆ—å®šä¹‰ (åœ¨ app_main.h ä¸­)
#define MSG_QUEUE_SIZE 16

typedef enum {
    MSG_SENSOR_DATA,
    MSG_CONTROL_CMD,
    MSG_SAFETY_ALARM,
    MSG_CONFIG_UPDATE,
    MSG_COMM_DATA
} msg_type_t;

typedef struct {
    msg_type_t type;
    uint32_t timestamp;
    uint16_t data_len;
    uint8_t data[64];
} system_msg_t;

// å…¨å±€æ¶ˆæ¯é˜Ÿåˆ— (åœ¨ app_main.c ä¸­å®ç°)
extern QueueHandle_t g_sensor_queue;
extern QueueHandle_t g_control_queue;
extern QueueHandle_t g_safety_queue;
extern QueueHandle_t g_comm_queue;
```

### 2.2 ä¼ æ„Ÿå™¨ä»»åŠ¡è®¾è®¡ (sensor_task.c/h)

#### 2.2.1 ä¼ æ„Ÿå™¨é…ç½®
```c
// åœ¨ sensor_task.h ä¸­å®šä¹‰
typedef struct {
    uint8_t channel;              // ADCé€šé“
    float scale_factor;           // æ ‡å®šç³»æ•°
    float offset;                 // é›¶ç‚¹åç§»
    float filter_coefficient;     // æ»¤æ³¢ç³»æ•°
    uint16_t sample_count;        // é‡‡æ ·æ¬¡æ•°
} sensor_config_t;

// ä¼ æ„Ÿå™¨ç±»å‹å®šä¹‰
typedef enum {
    SENSOR_TEMP_1,    // æ¸©åº¦ä¼ æ„Ÿå™¨1 (FTT518 Pt100)
    SENSOR_TEMP_2,    // æ¸©åº¦ä¼ æ„Ÿå™¨2
    SENSOR_TEMP_3,    // æ¸©åº¦ä¼ æ„Ÿå™¨3
    SENSOR_PRESSURE_1, // å‹åŠ›ä¼ æ„Ÿå™¨1 (HP10MY)
    SENSOR_PRESSURE_2, // å‹åŠ›ä¼ æ„Ÿå™¨2
    SENSOR_PRESSURE_3, // å‹åŠ›ä¼ æ„Ÿå™¨3
    SENSOR_PRESSURE_4, // å‹åŠ›ä¼ æ„Ÿå™¨4
    SENSOR_LEVEL_1,   // æ¶²ä½ä¼ æ„Ÿå™¨1 (FRD-8061)
    SENSOR_LEVEL_2,   // æ¶²ä½ä¼ æ„Ÿå™¨2
    SENSOR_LEVEL_3,   // æ¶²ä½ä¼ æ„Ÿå™¨3
    SENSOR_LEVEL_ANALOG, // æ¨¡æ‹Ÿé‡æ¶²ä½
    SENSOR_FLOW,      // æµé‡ä¼ æ„Ÿå™¨(I2C)
    SENSOR_COUNT
} sensor_type_t;
```

#### 2.2.2 æ•°æ®é‡‡é›†ä¸å¤„ç†
```c
// åœ¨ sensor_task.h ä¸­å®šä¹‰
typedef struct {
    float raw_value;              // åŸå§‹å€¼
    float filtered_value;         // æ»¤æ³¢åå€¼
    float calibrated_value;       // æ ‡å®šåå€¼
    uint32_t timestamp;           // æ—¶é—´æˆ³
    bool valid;                   // æ•°æ®æœ‰æ•ˆæ€§
    uint16_t error_count;         // é”™è¯¯è®¡æ•°
} sensor_data_t;

typedef struct {
    sensor_data_t sensors[SENSOR_COUNT];
    float temp_values[3];         // Â°C
    float pressure_values[4];     // kPa
    float level_values[4];        // mm
    float flow_value;             // L/min
} sensor_context_t;
```

#### 2.2.3 ä¼ æ„Ÿå™¨é©±åŠ¨é›†æˆ
- **FRD8061æ¶²ä½ä¼ æ„Ÿå™¨**: é©±åŠ¨ä½äº `drivers/sensors/frd8061_driver.c/h`
- **FTT518æ¸©åº¦ä¼ æ„Ÿå™¨**: é©±åŠ¨ä½äº `drivers/sensors/ftt518_driver.c/h`
- **HP10MYå‹åŠ›ä¼ æ„Ÿå™¨**: é©±åŠ¨ä½äº `drivers/sensors/hp10my_driver.c/h`

### 2.3 æ‰§è¡Œå™¨ä»»åŠ¡è®¾è®¡ (actuator_task.c/h)

#### 2.3.1 æ‰§è¡Œå™¨é…ç½®
```c
// åœ¨ actuator_task.h ä¸­å®šä¹‰
typedef struct {
    uint8_t channel;              // è¾“å‡ºé€šé“
    float current_output;         // å½“å‰è¾“å‡ºå€¼
    float target_output;          // ç›®æ ‡è¾“å‡ºå€¼
    bool enabled;                 // ä½¿èƒ½çŠ¶æ€
    uint32_t last_update;         // æœ€åæ›´æ–°æ—¶é—´
} actuator_config_t;

// æ‰§è¡Œå™¨ç±»å‹
typedef enum {
    ACTUATOR_VALVE_1,     // ç”µç£é˜€1 (24V)
    ACTUATOR_VALVE_2,     // ç”µç£é˜€2 (24V)
    ACTUATOR_HEATER_1,    // åŠ çƒ­å™¨1 (ç»§ç”µå™¨)
    ACTUATOR_HEATER_2,    // åŠ çƒ­å™¨2 (ç»§ç”µå™¨)
    ACTUATOR_HEATER_3,    // åŠ çƒ­å™¨3 (ç»§ç”µå™¨)
    ACTUATOR_PUMP_SPEED_1, // è°ƒé€Ÿæ³µ1 (PWM)
    ACTUATOR_PUMP_SPEED_2, // è°ƒé€Ÿæ³µ2 (PWM)
    ACTUATOR_PUMP_DC_1,   // ç›´æµæ³µ1 (IO)
    ACTUATOR_PUMP_DC_2,   // ç›´æµæ³µ2 (IO)
    ACTUATOR_COUNT
} actuator_type_t;
```

#### 2.3.2 æ‰§è¡Œå™¨é©±åŠ¨é›†æˆ
- **MRA23D3ç”µæœºé©±åŠ¨**: é©±åŠ¨ä½äº `drivers/actuators/mra23d3_driver.c/h`
- **MPB025BBBæ³µé©±åŠ¨**: é©±åŠ¨ä½äº `drivers/actuators/mpb025bbb_driver.c/h`
- **é˜€é—¨æ§åˆ¶**: é©±åŠ¨ä½äº `drivers/actuators/valve_control.c/h`
- **LEDæ§åˆ¶**: é©±åŠ¨ä½äº `drivers/actuators/led_control.c/h`

### 2.4 æ§åˆ¶ä»»åŠ¡è®¾è®¡ (control_task.c/h)

#### 2.4.1 æ§åˆ¶å™¨é…ç½®
```c
// åœ¨ control_task.h ä¸­å®šä¹‰
typedef struct {
    // PIDå‚æ•°
    float kp, ki, kd;             // PIDç³»æ•°
    float setpoint;               // è®¾å®šå€¼
    float output_min, output_max; // è¾“å‡ºé™å¹…
    float integral_min, integral_max; // ç§¯åˆ†é™å¹…

    // çŠ¶æ€å˜é‡
    float previous_error;
    float integral;
    float derivative;
    float previous_input;

    // æ§åˆ¶æ¨¡å¼
    bool auto_mode;
    bool reverse_action;
} pid_controller_t;

// æ§åˆ¶å›è·¯å®šä¹‰
typedef enum {
    CTRL_TEMP_1,      // æ¸©åº¦æ§åˆ¶å›è·¯1
    CTRL_TEMP_2,      // æ¸©åº¦æ§åˆ¶å›è·¯2
    CTRL_TEMP_3,      // æ¸©åº¦æ§åˆ¶å›è·¯3
    CTRL_PRESSURE_1,  // å‹åŠ›æ§åˆ¶å›è·¯1
    CTRL_PRESSURE_2,  // å‹åŠ›æ§åˆ¶å›è·¯2
    CTRL_LEVEL_1,     // æ¶²ä½æ§åˆ¶å›è·¯1
    CTRL_LEVEL_2,     // æ¶²ä½æ§åˆ¶å›è·¯2
    CTRL_FLOW,        // æµé‡æ§åˆ¶å›è·¯
    CTRL_COUNT
} control_loop_t;
```

### 2.5 å®‰å…¨ç›‘æ§ä»»åŠ¡è®¾è®¡ (safety_task.c/h)

#### 2.5.1 ä»»åŠ¡ç»“æ„
```c
// åœ¨ safety_task.h ä¸­å®šä¹‰
typedef struct {
    uint32_t check_interval;      // æ£€æŸ¥é—´éš”
    uint32_t timeout_threshold;   // è¶…æ—¶é˜ˆå€¼
    bool (*check_function)(void); // æ£€æŸ¥å‡½æ•°
    void (*alarm_handler)(void);  // å‘Šè­¦å¤„ç†
} safety_check_item_t;

typedef struct {
    // ä¼ æ„Ÿå™¨çŠ¶æ€
    bool temp_sensor_ok[3];       // 3è·¯æ¸©åº¦ä¼ æ„Ÿå™¨çŠ¶æ€
    bool pressure_sensor_ok[4];   // 4è·¯å‹åŠ›ä¼ æ„Ÿå™¨çŠ¶æ€
    bool level_sensor_ok[3];      // 3è·¯æ¶²ä½ä¼ æ„Ÿå™¨çŠ¶æ€
    bool flow_sensor_ok;          // æµé‡ä¼ æ„Ÿå™¨çŠ¶æ€

    // æ‰§è¡Œå™¨çŠ¶æ€
    bool valve_status[2];         // ç”µç£é˜€çŠ¶æ€
    bool heater_status[3];        // åŠ çƒ­å™¨çŠ¶æ€
    bool pump_status[4];          // æ³µçŠ¶æ€

    // é€šä¿¡çŠ¶æ€
    uint32_t ethercat_last_comm;  // EtherCATæœ€åé€šä¿¡æ—¶é—´
    uint32_t tcp_last_comm;       // TCPæœ€åé€šä¿¡æ—¶é—´

    // å®‰å…¨å‚æ•°
    float temp_max[3];            // æ¸©åº¦ä¸Šé™
    float temp_min[3];            // æ¸©åº¦ä¸‹é™
    float pressure_max[4];        // å‹åŠ›ä¸Šé™
    float pressure_min[4];        // å‹åŠ›ä¸‹é™
    float level_max[3];           // æ¶²ä½ä¸Šé™
    float level_min[3];           // æ¶²ä½ä¸‹é™
} safety_context_t;
```

#### 2.5.2 å®‰å…¨æ£€æŸ¥é¡¹ç›®
| æ£€æŸ¥é¡¹ç›® | æ£€æŸ¥é¢‘ç‡ | é˜ˆå€¼è®¾ç½® | å¤„ç†åŠ¨ä½œ |
|---------|---------|----------|----------|
| ä¼ æ„Ÿå™¨å¥åº·æ£€æŸ¥ | 10ms | è¿ç»­3æ¬¡è¯»å–å¤±è´¥ | åˆ‡æ¢åˆ°å®‰å…¨æ¨¡å¼ |
| æ‰§è¡Œå™¨çŠ¶æ€æ£€æŸ¥ | 10ms | åé¦ˆä¿¡å·å¼‚å¸¸ | åœæ­¢ç›¸å…³æ§åˆ¶ |
| æ¸©åº¦è¿‡é™æ£€æŸ¥ | 10ms | Â±5Â°Cè¶…å‡ºè®¾å®šå€¼ | å…³é—­åŠ çƒ­/å¯åŠ¨å†·å´ |
| å‹åŠ›è¿‡é™æ£€æŸ¥ | 10ms | Â±10kPaè¶…å‡ºè®¾å®šå€¼ | å…³é—­ç›¸å…³é˜€é—¨ |
| æ¶²ä½å¼‚å¸¸æ£€æŸ¥ | 10ms | è¶…å‡ºå®‰å…¨èŒƒå›´ | åœæ­¢ç›¸å…³æ³µ |
| é€šä¿¡è¶…æ—¶æ£€æŸ¥ | 50ms | 500msæ— é€šä¿¡ | è¿›å…¥ç¦»çº¿æ¨¡å¼ |

#### 2.5.3 å®‰å…¨çŠ¶æ€æœº
```c
// åœ¨ safety_task.h ä¸­å®šä¹‰
typedef enum {
    SAFETY_STATE_NORMAL,      // æ­£å¸¸è¿è¡Œ
    SAFETY_STATE_WARNING,     // è­¦å‘ŠçŠ¶æ€
    SAFETY_STATE_ALARM,       // å‘Šè­¦çŠ¶æ€
    SAFETY_STATE_EMERGENCY,   // ç´§æ€¥åœæœº
    SAFETY_STATE_MAINTENANCE  // ç»´æŠ¤æ¨¡å¼
} safety_state_t;

typedef struct {
    safety_state_t current_state;
    safety_state_t prev_state;
    uint32_t state_enter_time;
    uint32_t alarm_count;
} safety_state_machine_t;
```

### 2.6 HMIä»»åŠ¡è®¾è®¡ (hmi_task.c/h)

#### 2.6.1 æ˜¾ç¤ºå™¨æ¥å£
```c
// åœ¨ hmi_task.h ä¸­å®šä¹‰
typedef struct {
    uint8_t width;                // 128åƒç´ 
    uint8_t height;               // 32åƒç´ 
    uint8_t framebuffer[512];     // æ˜¾å­˜ (128*32/8)
    bool dirty;                   // åˆ·æ–°æ ‡å¿—
} lcd_context_t;

typedef enum {
    DISPLAY_PAGE_MAIN,        // ä¸»é¡µé¢
    DISPLAY_PAGE_TEMP,        // æ¸©åº¦é¡µé¢
    DISPLAY_PAGE_PRESSURE,    // å‹åŠ›é¡µé¢
    DISPLAY_PAGE_LEVEL,       // æ¶²ä½é¡µé¢
    DISPLAY_PAGE_FLOW,        // æµé‡é¡µé¢
    DISPLAY_PAGE_CONTROL,     // æ§åˆ¶é¡µé¢
    DISPLAY_PAGE_ALARM,       // å‘Šè­¦é¡µé¢
    DISPLAY_PAGE_CONFIG,      // é…ç½®é¡µé¢
    DISPLAY_PAGE_COUNT
} display_page_t;
```

#### 2.6.2 LEDæŒ‡ç¤ºé…ç½®
```c
// åœ¨ hmi_task.h ä¸­å®šä¹‰
typedef enum {
    LED_LEVEL_LOW_1,      // æ¶²ä½ä½ä½æŒ‡ç¤º1 (çº¢)
    LED_LEVEL_HIGH_1,     // æ¶²ä½é«˜ä½æŒ‡ç¤º1 (ç»¿)
    LED_LEVEL_LOW_2,      // æ¶²ä½ä½ä½æŒ‡ç¤º2 (çº¢)
    LED_LEVEL_HIGH_2,     // æ¶²ä½é«˜ä½æŒ‡ç¤º2 (ç»¿)
    LED_LEVEL_LOW_3,      // æ¶²ä½ä½ä½æŒ‡ç¤º3 (çº¢)
    LED_LEVEL_HIGH_3,     // æ¶²ä½é«˜ä½æŒ‡ç¤º3 (ç»¿)
    LED_LEVEL_ANALOG,     // æ¨¡æ‹Ÿæ¶²ä½æŒ‡ç¤º (è“)
    LED_TEMP_1,           // æ¸©åº¦ä¼ æ„Ÿå™¨1 (ç»¿/çº¢)
    LED_TEMP_2,           // æ¸©åº¦ä¼ æ„Ÿå™¨2 (ç»¿/çº¢)
    LED_TEMP_3,           // æ¸©åº¦ä¼ æ„Ÿå™¨3 (ç»¿/çº¢)
    LED_PRESSURE_1,       // å‹åŠ›ä¼ æ„Ÿå™¨1 (ç»¿/çº¢)
    LED_PRESSURE_2,       // å‹åŠ›ä¼ æ„Ÿå™¨2 (ç»¿/çº¢)
    LED_PRESSURE_3,       // å‹åŠ›ä¼ æ„Ÿå™¨3 (ç»¿/çº¢)
    LED_PRESSURE_4,       // å‹åŠ›ä¼ æ„Ÿå™¨4 (ç»¿/çº¢)
    LED_FLOW,             // æµé‡æŒ‡ç¤º (ç»¿/çº¢)
    LED_OUTPUT_1,         // è¾“å‡ºæŒ‡ç¤º1 (é»„)
    LED_OUTPUT_2,         // è¾“å‡ºæŒ‡ç¤º2 (é»„)
    LED_OUTPUT_3,         // è¾“å‡ºæŒ‡ç¤º3 (é»„)
    LED_OUTPUT_4,         // è¾“å‡ºæŒ‡ç¤º4 (é»„)
    LED_OUTPUT_5,         // è¾“å‡ºæŒ‡ç¤º5 (é»„)
    LED_OUTPUT_6,         // è¾“å‡ºæŒ‡ç¤º6 (é»„)
    LED_OUTPUT_7,         // è¾“å‡ºæŒ‡ç¤º7 (é»„)
    LED_OUTPUT_8,         // è¾“å‡ºæŒ‡ç¤º8 (é»„)
    LED_OUTPUT_9,         // è¾“å‡ºæŒ‡ç¤º9 (é»„)
    LED_POWER,            // ç”µæºæŒ‡ç¤º (ç»¿)
    LED_COMM,             // é€šä¿¡æŒ‡ç¤º (çº¢)
    LED_COUNT
} led_type_t;

typedef struct {
    uint8_t gpio_port;
    uint8_t gpio_pin;
    bool state;
    bool blink_enable;
    uint16_t blink_period;
    uint16_t blink_duty;
    uint32_t last_toggle;
} led_config_t;
```

### 2.7 é€šä¿¡ä»»åŠ¡è®¾è®¡

#### 2.7.1 EtherCATé€šä¿¡ä»»åŠ¡ (ethercat_app.c/h)
```c
// åœ¨ ethercat_app.h ä¸­å®šä¹‰
typedef struct {
    uint16_t vendor_id;           // å‚å•†ID
    uint16_t product_code;        // äº§å“ä»£ç 
    uint32_t revision;            // ç‰ˆæœ¬å·
    uint16_t pdo_input_size;      // è¾“å…¥PDOå¤§å°
    uint16_t pdo_output_size;     // è¾“å‡ºPDOå¤§å°
} ethercat_config_t;

// PDOæ˜ å°„
typedef struct {
    // è¾“å…¥PDO (ä¸»ç«™->ä»ç«™)
    float temp_setpoint[3];       // æ¸©åº¦è®¾å®šå€¼
    float pressure_setpoint[4];   // å‹åŠ›è®¾å®šå€¼
    float level_setpoint[3];      // æ¶²ä½è®¾å®šå€¼
    float flow_setpoint;          // æµé‡è®¾å®šå€¼
    uint16_t control_word;        // æ§åˆ¶å­—

    // è¾“å‡ºPDO (ä»ç«™->ä¸»ç«™)
    float temp_actual[3];         // æ¸©åº¦å®é™…å€¼
    float pressure_actual[4];     // å‹åŠ›å®é™…å€¼
    float level_actual[3];        // æ¶²ä½å®é™…å€¼
    float flow_actual;            // æµé‡å®é™…å€¼
    uint16_t status_word;         // çŠ¶æ€å­—
    uint16_t alarm_word;          // å‘Šè­¦å­—
} ethercat_pdo_t;
```

#### 2.7.2 TCPé€šä¿¡ä»»åŠ¡ (tcp_server.c/h)
```c
// åœ¨ tcp_server.h ä¸­å®šä¹‰
// åŸºç¡€åè®®å¸§ç»“æ„
typedef struct {
    uint16_t sync_word;       // åŒæ­¥å­— 0xAA55
    uint16_t length;          // å¸§é•¿åº¦(åŒ…å«å¸§å¤´)
    uint8_t  cmd;             // å‘½ä»¤å­—
    uint8_t  index;           // ç´¢å¼•
    uint16_t checksum;        // æ ¡éªŒå’Œ
} __attribute__((packed)) tcp_frame_header_t;

typedef struct {
    tcp_frame_header_t header;
    uint8_t data[];
} __attribute__((packed)) tcp_protocol_frame_t;

// å‘½ä»¤å®šä¹‰
typedef enum {
    CMD_READ_SENSOR = 0x01,       // è¯»å–ä¼ æ„Ÿå™¨æ•°æ®
    CMD_WRITE_SETPOINT = 0x02,    // å†™å…¥è®¾å®šå€¼
    CMD_READ_STATUS = 0x03,       // è¯»å–çŠ¶æ€
    CMD_WRITE_CONTROL = 0x04,     // å†™å…¥æ§åˆ¶å‘½ä»¤
    CMD_READ_CONFIG = 0x05,       // è¯»å–é…ç½®
    CMD_WRITE_CONFIG = 0x06,      // å†™å…¥é…ç½®
    CMD_ALARM_ACK = 0x07,         // å‘Šè­¦ç¡®è®¤
    CMD_RESET = 0x08,             // ç³»ç»Ÿå¤ä½
} tcp_command_t;

// é”™è¯¯ç å®šä¹‰
typedef enum {
    ERR_OK = 0x00,                // æˆåŠŸ
    ERR_INVALID_CMD = 0x01,       // æ— æ•ˆå‘½ä»¤
    ERR_INVALID_PARAM = 0x02,     // æ— æ•ˆå‚æ•°
    ERR_DEVICE_BUSY = 0x03,       // è®¾å¤‡å¿™
    ERR_TIMEOUT = 0x04,           // è¶…æ—¶
    ERR_CHECKSUM = 0x05,          // æ ¡éªŒé”™è¯¯
    ERR_PERMISSION = 0x06,        // æƒé™ä¸è¶³
} tcp_error_code_t;
```

### 2.8 é…ç½®ä»»åŠ¡è®¾è®¡ (config_task.c/h)

#### 2.8.1 é…ç½®å‚æ•°ç»“æ„
```c
// åœ¨ config_task.h ä¸­å®šä¹‰
typedef struct {
    // ä¼ æ„Ÿå™¨é…ç½®
    sensor_config_t sensor_configs[SENSOR_COUNT];

    // æ§åˆ¶å™¨é…ç½®
    pid_controller_t controllers[CTRL_COUNT];

    // å®‰å…¨å‚æ•°
    safety_context_t safety_params;

    // é€šä¿¡é…ç½®
    struct {
        uint32_t ip_address;
        uint16_t tcp_port;
        uint16_t ethercat_address;
        uint32_t baudrate;
    } comm_config;

    // ç³»ç»Ÿé…ç½®
    struct {
        uint16_t system_id;
        char device_name[32];
        char version[16];
        uint32_t config_crc;
        uint32_t config_version;
    } system_config;
} system_configuration_t;
```

#### 2.8.2 å‚æ•°å­˜å‚¨
```c
// åœ¨ config_task.h ä¸­å®šä¹‰
// EEPROM/Flashå­˜å‚¨ç®¡ç†
typedef struct {
    uint32_t base_address;        // åŸºåœ°å€
    uint32_t sector_size;         // æ‰‡åŒºå¤§å°
    uint32_t backup_address;      // å¤‡ä»½åœ°å€
    bool write_protection;        // å†™ä¿æŠ¤
} config_storage_t;

// é…ç½®ç®¡ç†æ¥å£
typedef enum {
    CONFIG_LOAD_DEFAULT,          // åŠ è½½é»˜è®¤é…ç½®
    CONFIG_LOAD_FROM_STORAGE,     // ä»å­˜å‚¨åŠ è½½
    CONFIG_SAVE_TO_STORAGE,       // ä¿å­˜åˆ°å­˜å‚¨
    CONFIG_BACKUP,                // å¤‡ä»½é…ç½®
    CONFIG_RESTORE,               // æ¢å¤é…ç½®
    CONFIG_VALIDATE,              // éªŒè¯é…ç½®
} config_operation_t;
```

## 3. ä¸­é—´ä»¶å±‚è®¾è®¡

### 3.1 PIDæ§åˆ¶å™¨ (pid.c/h)
```c
// åœ¨ middleware/pid.h ä¸­å®šä¹‰
typedef struct {
    float (*compute)(pid_controller_t* pid, float input);
    void (*set_tunings)(pid_controller_t* pid, float kp, float ki, float kd);
    void (*set_output_limits)(pid_controller_t* pid, float min, float max);
    void (*set_mode)(pid_controller_t* pid, bool automatic);
    void (*initialize)(pid_controller_t* pid);
} pid_interface_t;
```

### 3.2 æ•°å­—æ»¤æ³¢å™¨ (filter.c/h)
```c
// åœ¨ middleware/filter.h ä¸­å®šä¹‰
// æ»‘åŠ¨å¹³å‡æ»¤æ³¢
typedef struct {
    float buffer[16];
    uint8_t index;
    uint8_t count;
    float sum;
} moving_average_filter_t;

// å¡å°”æ›¼æ»¤æ³¢å™¨
typedef struct {
    float Q;     // è¿‡ç¨‹å™ªå£°
    float R;     // æµ‹é‡å™ªå£°
    float P;     // ä¼°è®¡è¯¯å·®åæ–¹å·®
    float K;     // å¡å°”æ›¼å¢ç›Š
    float X;     // çŠ¶æ€ä¼°è®¡
} kalman_filter_t;

typedef struct {
    float (*moving_average)(moving_average_filter_t* filter, float input);
    float (*kalman_filter)(kalman_filter_t* filter, float measurement);
    float (*low_pass_filter)(float input, float prev_output, float alpha);
    float (*median_filter)(float* buffer, uint8_t size);
} filter_interface_t;
```

### 3.3 ä»»åŠ¡ç®¡ç†å™¨ (tasks.c/h)
```c
// åœ¨ middleware/tasks.h ä¸­å®šä¹‰
typedef struct {
    TaskHandle_t handle;
    char name[16];
    uint32_t stack_size;
    UBaseType_t priority;
    uint32_t run_count;
    uint32_t max_execution_time;
    uint32_t avg_execution_time;
    bool enabled;
} task_info_t;

typedef struct {
    task_info_t tasks[10];
    uint8_t task_count;
    uint32_t system_tick;
    uint32_t cpu_usage;
    uint32_t free_heap;
} task_manager_t;
```

## 4. HALå±‚è®¾è®¡

### 4.1 HALå±‚æ¶æ„ (hal/)
åŸºäºGD32F427 HALåº“å°è£…ï¼Œæä¾›ç»Ÿä¸€çš„ç¡¬ä»¶è®¿é—®æ¥å£ï¼š

- **hal_manager.c/h**: HALå±‚ç®¡ç†å™¨ï¼Œç»Ÿä¸€åˆå§‹åŒ–å’Œç®¡ç†å„HALæ¨¡å—
- **hal_common.c/h**: HALå±‚å…¬å…±åŠŸèƒ½å’Œé€šç”¨å®šä¹‰
- **adc_hal.c/h**: ADCç¡¬ä»¶æŠ½è±¡ï¼Œæ”¯æŒå¤šé€šé“ä¼ æ„Ÿå™¨é‡‡é›†
- **pwm_hal.c/h**: PWMç¡¬ä»¶æŠ½è±¡ï¼Œæ”¯æŒæ‰§è¡Œå™¨æ§åˆ¶
- **gpio_hal.c/h**: GPIOç¡¬ä»¶æŠ½è±¡ï¼Œæ•°å­—IOæ§åˆ¶
- **uart_hal.c/h**: UARTç¡¬ä»¶æŠ½è±¡ï¼Œè°ƒè¯•å’Œé€šä¿¡æ¥å£
- **spi_hal.c/h**: SPIç¡¬ä»¶æŠ½è±¡ï¼ŒLCDæ˜¾ç¤ºæ¥å£
- **i2c_hal.c/h**: I2Cç¡¬ä»¶æŠ½è±¡ï¼Œä¼ æ„Ÿå™¨é€šä¿¡æ¥å£
- **eth_hal.c/h**: ä»¥å¤ªç½‘ç¡¬ä»¶æŠ½è±¡ï¼Œç½‘ç»œé€šä¿¡æ”¯æŒ
- **flash_hal.c/h**: Flashç¡¬ä»¶æŠ½è±¡ï¼Œé…ç½®å­˜å‚¨ç®¡ç†
- **timer_hal.c/h**: å®šæ—¶å™¨ç¡¬ä»¶æŠ½è±¡ï¼Œç²¾ç¡®æ—¶åºæ§åˆ¶

### 4.2 HALæ¥å£æ ‡å‡†åŒ–
```c
// åœ¨ hal/hal_common.h ä¸­å®šä¹‰
typedef enum {
    HAL_OK = 0,
    HAL_ERROR,
    HAL_BUSY,
    HAL_TIMEOUT
} hal_status_t;

typedef struct {
    hal_status_t (*init)(void* config);
    hal_status_t (*deinit)(void);
    hal_status_t (*read)(void* data, uint32_t size);
    hal_status_t (*write)(const void* data, uint32_t size);
    hal_status_t (*control)(uint32_t cmd, void* arg);
} hal_interface_t;
```

## 5. é©±åŠ¨å±‚è®¾è®¡

### 5.1 ä¼ æ„Ÿå™¨é©±åŠ¨ (drivers/sensors/)
- **frd8061_driver.c/h**: FRD8061æ¶²ä½ä¼ æ„Ÿå™¨ä¸“ç”¨é©±åŠ¨
- **ftt518_driver.c/h**: FTT518æ¸©åº¦ä¼ æ„Ÿå™¨(Pt100)ä¸“ç”¨é©±åŠ¨
- **hp10my_driver.c/h**: HP10MYå‹åŠ›ä¼ æ„Ÿå™¨ä¸“ç”¨é©±åŠ¨

### 5.2 æ‰§è¡Œå™¨é©±åŠ¨ (drivers/actuators/)
- **mra23d3_driver.c/h**: MRA23D3ç”µæœºä¸“ç”¨é©±åŠ¨
- **mpb025bbb_driver.c/h**: MPB025BBBæ³µä¸“ç”¨é©±åŠ¨
- **valve_control.c/h**: ç”µç£é˜€æ§åˆ¶é©±åŠ¨
- **led_control.c/h**: LEDæŒ‡ç¤ºç¯æ§åˆ¶é©±åŠ¨

### 5.3 é©±åŠ¨æ¥å£ç»Ÿä¸€åŒ–
```c
// åœ¨ drivers/driver_common.h ä¸­å®šä¹‰
typedef struct {
    hal_status_t (*init)(void* config);
    hal_status_t (*read)(float* value);
    hal_status_t (*write)(float value);
    hal_status_t (*calibrate)(void* params);
    hal_status_t (*self_test)(void);
} sensor_driver_interface_t;

typedef struct {
    hal_status_t (*init)(void* config);
    hal_status_t (*set_output)(float value);
    hal_status_t (*get_status)(uint32_t* status);
    hal_status_t (*enable)(bool enable);
    hal_status_t (*self_test)(void);
} actuator_driver_interface_t;
```

## 6. ç³»ç»Ÿé›†æˆ

### 6.1 å¯åŠ¨åºåˆ—
```c
// åœ¨ system/system_manager.h ä¸­å®šä¹‰
typedef enum {
    BOOT_STAGE_HARDWARE_INIT,     // ç¡¬ä»¶åˆå§‹åŒ–
    BOOT_STAGE_RTOS_INIT,         // RTOSåˆå§‹åŒ–
    BOOT_STAGE_MIDDLEWARE_INIT,   // ä¸­é—´ä»¶åˆå§‹åŒ–
    BOOT_STAGE_APP_INIT,          // åº”ç”¨åˆå§‹åŒ–
    BOOT_STAGE_SELF_TEST,         // è‡ªæ£€
    BOOT_STAGE_READY,             // å‡†å¤‡å°±ç»ª
} boot_stage_t;
```

### 6.2 é”™è¯¯å¤„ç† (system/error_handler.c/h)
```c
typedef enum {
    ERROR_NONE = 0,
    ERROR_SENSOR_FAULT,
    ERROR_ACTUATOR_FAULT,
    ERROR_COMMUNICATION_FAULT,
    ERROR_SAFETY_VIOLATION,
    ERROR_SYSTEM_OVERLOAD,
    ERROR_CONFIG_INVALID,
    ERROR_HARDWARE_FAULT,
} system_error_t;

typedef struct {
    system_error_t error_code;
    uint32_t timestamp;
    char description[64];
    uint8_t severity;             // 0-3: ä¿¡æ¯,è­¦å‘Š,é”™è¯¯,ä¸¥é‡
    bool acknowledged;
} error_record_t;
```

### 6.3 æ€§èƒ½ç›‘æ§
```c
// åœ¨ system/system_manager.h ä¸­å®šä¹‰
typedef struct {
    uint32_t cpu_usage_percent;
    uint32_t memory_usage_bytes;
    uint32_t free_stack_min[10];  // å„ä»»åŠ¡æœ€å°å‰©ä½™æ ˆ
    uint32_t task_switch_count;
    uint32_t interrupt_count;
    uint32_t max_interrupt_time;
} performance_metrics_t;
```

## 7. æ„å»ºç³»ç»Ÿ

### 7.1 CMakeæ„å»ºé…ç½®
é¡¹ç›®é‡‡ç”¨CMakeä½œä¸ºæ„å»ºç³»ç»Ÿï¼Œ`CMakeLists.txt`ä½äºé¡¹ç›®æ ¹ç›®å½•ï¼š

```cmake
# ä¸»è¦æ„å»ºç›®æ ‡
project(ink_supply_system_gd32f427)

# æºæ–‡ä»¶ç»„ç»‡
add_subdirectory(src/app)
add_subdirectory(src/middleware)
add_subdirectory(src/hal)
add_subdirectory(src/drivers)
add_subdirectory(src/board)
add_subdirectory(src/system)

# ç¬¬ä¸‰æ–¹åº“é›†æˆ
add_subdirectory(lib/GD32F4xx_HAL)
add_subdirectory(lib/FreeRTOS)
add_subdirectory(lib/lwip)
add_subdirectory(lib/ethercat)
```

### 7.2 é…ç½®æ–‡ä»¶ç®¡ç†
ç³»ç»Ÿé…ç½®æ–‡ä»¶ä½äº `config/` ç›®å½•ï¼š

- **FreeRTOSConfig.h**: FreeRTOSç³»ç»Ÿé…ç½®
- **lwipopts.h**: lwIPç½‘ç»œæ ˆé…ç½®
- **gd32f4xx_hal_conf.h**: GD32 HALåº“é…ç½®
- **system_config.h**: ç³»ç»Ÿå‚æ•°é…ç½®
- **app_config.h**: åº”ç”¨å±‚é…ç½®
- **project_config.h**: é¡¹ç›®ç‰¹å®šé…ç½®

## 8. æµ‹è¯•ä¸éªŒè¯

### 8.1 å•å…ƒæµ‹è¯•
- å„ä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†ç²¾åº¦æµ‹è¯•
- PIDæ§åˆ¶å™¨å“åº”ç‰¹æ€§æµ‹è¯•
- å®‰å…¨ç›‘æ§åŠŸèƒ½æµ‹è¯•
- é€šä¿¡åè®®æ­£ç¡®æ€§æµ‹è¯•

### 8.2 é›†æˆæµ‹è¯•
- å¤šä»»åŠ¡ååŒå·¥ä½œæµ‹è¯•
- å®æ—¶æ€§èƒ½æµ‹è¯•
- æ•…éšœæ¢å¤æµ‹è¯•
- é•¿æœŸç¨³å®šæ€§æµ‹è¯•

### 8.3 ç³»ç»Ÿæµ‹è¯•
- å®Œæ•´å·¥è‰ºæµç¨‹æµ‹è¯•
- æé™å·¥å†µæµ‹è¯•
- ç”µç£å…¼å®¹æ€§æµ‹è¯•
- å®‰å…¨è®¤è¯æµ‹è¯•

## 9. å¼€å‘æŒ‡å—

### 9.1 ä»£ç è§„èŒƒ
- éµå¾ªMISRA Cç¼–ç æ ‡å‡†
- ç»Ÿä¸€çš„å‘½åçº¦å®šå’Œæ–‡ä»¶ç»„ç»‡
- å®Œæ•´çš„æ¥å£æ–‡æ¡£å’Œæ³¨é‡Š
- æ¨¡å—åŒ–è®¾è®¡å’Œæ¥å£æŠ½è±¡

### 9.2 è°ƒè¯•æ”¯æŒ
- ç»Ÿä¸€çš„é”™è¯¯å¤„ç†å’Œæ—¥å¿—ç³»ç»Ÿ
- æ€§èƒ½ç›‘æ§å’Œèµ„æºä½¿ç”¨ç»Ÿè®¡
- åœ¨çº¿è°ƒè¯•å’Œå‚æ•°è°ƒæ•´æ¥å£
- æ•…éšœè¯Šæ–­å’Œæ¢å¤æœºåˆ¶

### 9.3 æ‰©å±•æ€§è®¾è®¡
- æ ‡å‡†åŒ–çš„é©±åŠ¨æ¥å£ï¼Œæ˜“äºæ·»åŠ æ–°è®¾å¤‡
- æ¨¡å—åŒ–çš„ä»»åŠ¡æ¶æ„ï¼Œæ”¯æŒåŠŸèƒ½æ‰©å±•
- çµæ´»çš„é…ç½®ç³»ç»Ÿï¼Œæ”¯æŒä¸åŒåº”ç”¨åœºæ™¯
- å¼€æ”¾çš„é€šä¿¡åè®®ï¼Œæ”¯æŒç³»ç»Ÿé›†æˆ

---

*æœ¬æ–‡æ¡£ç‰ˆæœ¬: v2.0*
*æœ€åæ›´æ–°: 2025-09-29*
*åŸºäºå®é™…ä»£ç ç›®å½•ç»“æ„å’Œv1è®¾è®¡æ–‡æ¡£ç¼–å†™*