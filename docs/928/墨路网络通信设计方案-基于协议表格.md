# 墨路控制系统网络通信设计方案

> **设计依据**: 墨路通信协议_工作表1.png + 墨路控制系统详细设计文档v3.md
> **核心目标**: 兼容EtherCAT和TCP/IP两种通信协议
> **版本**: v1.0
> **日期**: 2025-09-30

---

## 1. 协议表格数据项完整定义

### 1.1 传感器数据 (基于协议表行0-22)

| 序号 | 数据项 | 类型 | 字节数 | 单位 | 范围 | 说明 |
|------|--------|------|--------|------|------|------|
| 0 | 温度传感器1 | INT16 | 2 | 0.1°C | -500~3000 | FTT518 Pt100 温度1 |
| 1 | 温度传感器2 | INT16 | 2 | 0.1°C | -500~3000 | FTT518 Pt100 温度2 |
| 2 | 温度传感器3 | INT16 | 2 | 0.1°C | -500~3000 | FTT518 Pt100 温度3 |
| 3 | 压力传感器1 | UINT16 | 2 | 0.1kPa | 0~65535 | HP10MY 压力1 |
| 4 | 压力传感器2 | UINT16 | 2 | 0.1kPa | 0~65535 | HP10MY 压力2 |
| 5 | 压力传感器3 | UINT16 | 2 | 0.1kPa | 0~65535 | HP10MY 压力3 |
| 6 | 压力传感器4 | UINT16 | 2 | 0.1kPa | 0~65535 | HP10MY 压力4 |
| 7 | 液位传感器1 | UINT16 | 2 | 0.1mm | 0~5000 | FRD8061 液位1 |
| 8 | 液位传感器2 | UINT16 | 2 | 0.1mm | 0~5000 | FRD8061 液位2 |
| 9 | 液位传感器3 | UINT16 | 2 | 0.1mm | 0~5000 | FRD8061 液位3 |
| 10 | 模拟液位传感器 | UINT16 | 2 | 0.1mm | 0~5000 | 模拟量液位 |
| 11 | 流量传感器 | UINT16 | 2 | 0.01L/min | 0~65535 | I2C流量传感器 |
| 12 | 液位开关1-低位 | BIT | 1bit | - | 0/1 | 数字开关 |
| 13 | 液位开关1-高位 | BIT | 1bit | - | 0/1 | 数字开关 |
| 14 | 液位开关2-低位 | BIT | 1bit | - | 0/1 | 数字开关 |
| 15 | 液位开关2-高位 | BIT | 1bit | - | 0/1 | 数字开关 |
| 16 | 液位开关3-低位 | BIT | 1bit | - | 0/1 | 数字开关 |
| 17 | 液位开关3-高位 | BIT | 1bit | - | 0/1 | 数字开关 |

**液位开关状态字** (UINT16, 合并bit12-17):
```
Bit 0: 液位开关1-低位
Bit 1: 液位开关1-高位
Bit 2: 液位开关2-低位
Bit 3: 液位开关2-高位
Bit 4: 液位开关3-低位
Bit 5: 液位开关3-高位
Bit 6-15: 预留
```

### 1.2 执行器数据 (基于协议表行23-40)

| 序号 | 数据项 | 类型 | 字节数 | 单位 | 范围 | 说明 |
|------|--------|------|--------|------|------|------|
| 18 | 电磁阀1状态 | BIT | 1bit | - | 0/1 | 阀门开关状态 |
| 19 | 电磁阀2状态 | BIT | 1bit | - | 0/1 | 阀门开关状态 |
| 20 | 加热器1状态 | BIT | 1bit | - | 0/1 | 继电器状态 |
| 21 | 加热器2状态 | BIT | 1bit | - | 0/1 | 继电器状态 |
| 22 | 加热器3状态 | BIT | 1bit | - | 0/1 | 继电器状态 |
| 23 | 调速泵1速度 | UINT16 | 2 | 0.1% | 0~1000 | PWM速度 0-100% |
| 24 | 调速泵2速度 | UINT16 | 2 | 0.1% | 0~1000 | PWM速度 0-100% |
| 25 | 直流泵1状态 | BIT | 1bit | - | 0/1 | 泵开关状态 |
| 26 | 直流泵2状态 | BIT | 1bit | - | 0/1 | 泵开关状态 |
| 27 | 加热器1电流 | UINT16 | 2 | 0.01A | 0~5000 | 实际电流反馈 |
| 28 | 加热器2电流 | UINT16 | 2 | 0.01A | 0~5000 | 实际电流反馈 |
| 29 | 加热器3电流 | UINT16 | 2 | 0.01A | 0~5000 | 实际电流反馈 |

**执行器状态字1** (UINT16, 合并bit18-19,23-26):
```
Bit 0: 电磁阀1状态
Bit 1: 电磁阀2状态
Bit 2: 直流泵1状态
Bit 3: 直流泵2状态
Bit 4-15: 预留
```

**执行器状态字2** (UINT16, 合并bit20-22):
```
Bit 0: 加热器1状态
Bit 1: 加热器2状态
Bit 2: 加热器3状态
Bit 3-15: 预留
```

### 1.3 控制参数 (根据v3.md设计文档)

| 序号 | 数据项 | 类型 | 字节数 | 单位 | 说明 |
|------|--------|------|--------|------|------|
| 30 | 温度设定值1 | INT16 | 2 | 0.1°C | 温度控制目标 |
| 31 | 温度设定值2 | INT16 | 2 | 0.1°C | 温度控制目标 |
| 32 | 温度设定值3 | INT16 | 2 | 0.1°C | 温度控制目标 |
| 33 | 压力设定值1 | UINT16 | 2 | 0.1kPa | 压力控制目标 |
| 34 | 压力设定值2 | UINT16 | 2 | 0.1kPa | 压力控制目标 |
| 35 | 压力设定值3 | UINT16 | 2 | 0.1kPa | 压力控制目标 |
| 36 | 压力设定值4 | UINT16 | 2 | 0.1kPa | 压力控制目标 |
| 37 | 液位设定值1 | UINT16 | 2 | 0.1mm | 液位控制目标 |
| 38 | 液位设定值2 | UINT16 | 2 | 0.1mm | 液位控制目标 |
| 39 | 液位设定值3 | UINT16 | 2 | 0.1mm | 液位控制目标 |
| 40 | 流量设定值 | UINT16 | 2 | 0.01L/min | 流量控制目标 |

### 1.4 系统状态

| 数据项 | 类型 | 字节数 | 说明 |
|--------|------|--------|------|
| 系统状态字 | UINT16 | 2 | 系统运行状态 |
| 告警字1 | UINT16 | 2 | 传感器告警 |
| 告警字2 | UINT16 | 2 | 执行器告警 |
| 控制字 | UINT16 | 2 | 控制命令 |
| 时间戳 | UINT32 | 4 | 系统运行时间(ms) |

---

## 2. 统一数据结构定义

### 2.1 核心数据结构 (支持EtherCAT和TCP/IP)

```c
// include/common/protocol_data.h
#ifndef __PROTOCOL_DATA_H
#define __PROTOCOL_DATA_H

#include <stdint.h>
#include <stdbool.h>

//==============================================================================
// 传感器数据结构
//==============================================================================
typedef struct {
    int16_t  temperature[3];        // 温度传感器 0.1°C (-50.0~300.0°C)
    uint16_t pressure[4];           // 压力传感器 0.1kPa
    uint16_t level[3];              // 液位传感器 0.1mm
    uint16_t level_analog;          // 模拟液位 0.1mm
    uint16_t flow_rate;             // 流量 0.01L/min
    uint16_t level_switch_status;   // 液位开关状态位
} __attribute__((packed)) sensor_data_t;

//==============================================================================
// 执行器状态结构
//==============================================================================
typedef struct {
    uint16_t actuator_status1;      // 阀门+泵状态位
    uint16_t actuator_status2;      // 加热器状态位
    uint16_t pump_speed[2];         // 调速泵速度 0.1%
    uint16_t heater_current[3];     // 加热器电流 0.01A
} __attribute__((packed)) actuator_status_t;

//==============================================================================
// 控制设定值结构
//==============================================================================
typedef struct {
    int16_t  temp_setpoint[3];      // 温度设定 0.1°C
    uint16_t pressure_setpoint[4];  // 压力设定 0.1kPa
    uint16_t level_setpoint[3];     // 液位设定 0.1mm
    uint16_t flow_setpoint;         // 流量设定 0.01L/min
} __attribute__((packed)) control_setpoint_t;

//==============================================================================
// 执行器控制命令结构
//==============================================================================
typedef struct {
    uint16_t actuator_control1;     // 阀门+泵控制位
    uint16_t actuator_control2;     // 加热器控制位
    uint16_t pump_speed_cmd[2];     // 调速泵速度命令 0.1%
} __attribute__((packed)) actuator_control_t;

//==============================================================================
// 系统状态结构
//==============================================================================
typedef struct {
    uint16_t status_word;           // 系统状态字
    uint16_t alarm_word1;           // 告警字1
    uint16_t alarm_word2;           // 告警字2
    uint32_t timestamp;             // 时间戳(ms)
    uint16_t cycle_counter;         // 循环计数器
} __attribute__((packed)) system_status_t;

//==============================================================================
// 完整实时数据包 (传感器+执行器+状态)
//==============================================================================
typedef struct {
    sensor_data_t       sensors;        // 传感器数据 (26字节)
    actuator_status_t   actuators;      // 执行器状态 (10字节)
    system_status_t     system;         // 系统状态 (12字节)
} __attribute__((packed)) realtime_data_t;  // 总计: 48字节

//==============================================================================
// 完整控制数据包 (设定值+控制命令+控制字)
//==============================================================================
typedef struct {
    control_setpoint_t  setpoints;      // 设定值 (22字节)
    actuator_control_t  controls;       // 执行器控制 (6字节)
    uint16_t            control_word;   // 控制字 (2字节)
} __attribute__((packed)) control_data_t;   // 总计: 30字节

//==============================================================================
// 状态字位定义
//==============================================================================
// 系统状态字 (status_word)
#define STATUS_BIT_READY            (1 << 0)    // 系统就绪
#define STATUS_BIT_RUNNING          (1 << 1)    // 系统运行中
#define STATUS_BIT_ALARM            (1 << 2)    // 存在告警
#define STATUS_BIT_FAULT            (1 << 3)    // 存在故障
#define STATUS_BIT_SAFE_MODE        (1 << 4)    // 安全模式
#define STATUS_BIT_MANUAL_MODE      (1 << 5)    // 手动模式
#define STATUS_BIT_AUTO_MODE        (1 << 6)    // 自动模式
#define STATUS_BIT_COMM_OK          (1 << 7)    // 通信正常
#define STATUS_BIT_SENSOR_FAULT     (1 << 8)    // 传感器故障
#define STATUS_BIT_ACTUATOR_FAULT   (1 << 9)    // 执行器故障
#define STATUS_BIT_TEMP_OVER        (1 << 10)   // 温度超限
#define STATUS_BIT_PRESSURE_OVER    (1 << 11)   // 压力超限
#define STATUS_BIT_LEVEL_ABNORMAL   (1 << 12)   // 液位异常
#define STATUS_BIT_CONFIG_VALID     (1 << 13)   // 配置有效
#define STATUS_BIT_SELF_TEST_OK     (1 << 14)   // 自检通过
#define STATUS_BIT_RESERVED         (1 << 15)   // 预留

// 控制字 (control_word)
#define CTRL_BIT_ENABLE             (1 << 0)    // 系统使能
#define CTRL_BIT_RESET              (1 << 1)    // 复位命令
#define CTRL_BIT_START              (1 << 2)    // 启动命令
#define CTRL_BIT_STOP               (1 << 3)    // 停止命令
#define CTRL_BIT_EMERGENCY_STOP     (1 << 4)    // 紧急停止
#define CTRL_BIT_AUTO_MODE          (1 << 5)    // 切换自动模式
#define CTRL_BIT_MANUAL_MODE        (1 << 6)    // 切换手动模式
#define CTRL_BIT_PARAM_SAVE         (1 << 7)    // 保存参数
#define CTRL_BIT_PARAM_LOAD         (1 << 8)    // 加载参数
#define CTRL_BIT_ALARM_ACK          (1 << 9)    // 告警确认
#define CTRL_BIT_SELF_TEST          (1 << 10)   // 启动自检
#define CTRL_BIT_PID_AUTOTUNE       (1 << 11)   // PID自整定
#define CTRL_BIT_FORCE_SAFE         (1 << 12)   // 强制安全模式
#define CTRL_BIT_CONFIG_LOCK        (1 << 13)   // 配置锁定
#define CTRL_BIT_DEBUG_MODE         (1 << 14)   // 调试模式
#define CTRL_BIT_RESERVED           (1 << 15)   // 预留

// 液位开关状态位 (level_switch_status)
#define LEVEL_SWITCH_1_LOW          (1 << 0)
#define LEVEL_SWITCH_1_HIGH         (1 << 1)
#define LEVEL_SWITCH_2_LOW          (1 << 2)
#define LEVEL_SWITCH_2_HIGH         (1 << 3)
#define LEVEL_SWITCH_3_LOW          (1 << 4)
#define LEVEL_SWITCH_3_HIGH         (1 << 5)

// 执行器状态位1 (actuator_status1)
#define ACTUATOR_VALVE_1            (1 << 0)    // 电磁阀1
#define ACTUATOR_VALVE_2            (1 << 1)    // 电磁阀2
#define ACTUATOR_PUMP_DC_1          (1 << 2)    // 直流泵1
#define ACTUATOR_PUMP_DC_2          (1 << 3)    // 直流泵2
#define ACTUATOR_PUMP_SPEED_1_EN    (1 << 4)    // 调速泵1使能
#define ACTUATOR_PUMP_SPEED_2_EN    (1 << 5)    // 调速泵2使能

// 执行器状态位2 (actuator_status2)
#define ACTUATOR_HEATER_1           (1 << 0)    // 加热器1
#define ACTUATOR_HEATER_2           (1 << 1)    // 加热器2
#define ACTUATOR_HEATER_3           (1 << 2)    // 加热器3

// 执行器控制位1 (actuator_control1)
#define CTRL_VALVE_1                (1 << 0)    // 控制电磁阀1
#define CTRL_VALVE_2                (1 << 1)    // 控制电磁阀2
#define CTRL_PUMP_DC_1              (1 << 2)    // 控制直流泵1
#define CTRL_PUMP_DC_2              (1 << 3)    // 控制直流泵2
#define CTRL_PUMP_SPEED_1_EN        (1 << 4)    // 调速泵1使能
#define CTRL_PUMP_SPEED_2_EN        (1 << 5)    // 调速泵2使能

// 执行器控制位2 (actuator_control2)
#define CTRL_HEATER_1               (1 << 0)    // 控制加热器1
#define CTRL_HEATER_2               (1 << 1)    // 控制加热器2
#define CTRL_HEATER_3               (1 << 2)    // 控制加热器3

//==============================================================================
// 告警字定义
//==============================================================================
// 告警字1 (alarm_word1) - 传感器故障
#define ALARM_TEMP_1_FAULT          (1 << 0)    // 温度1故障
#define ALARM_TEMP_2_FAULT          (1 << 1)    // 温度2故障
#define ALARM_TEMP_3_FAULT          (1 << 2)    // 温度3故障
#define ALARM_PRESSURE_1_FAULT      (1 << 3)    // 压力1故障
#define ALARM_PRESSURE_2_FAULT      (1 << 4)    // 压力2故障
#define ALARM_PRESSURE_3_FAULT      (1 << 5)    // 压力3故障
#define ALARM_PRESSURE_4_FAULT      (1 << 6)    // 压力4故障
#define ALARM_LEVEL_1_FAULT         (1 << 7)    // 液位1故障
#define ALARM_LEVEL_2_FAULT         (1 << 8)    // 液位2故障
#define ALARM_LEVEL_3_FAULT         (1 << 9)    // 液位3故障
#define ALARM_LEVEL_ANALOG_FAULT    (1 << 10)   // 模拟液位故障
#define ALARM_FLOW_FAULT            (1 << 11)   // 流量故障
#define ALARM_TEMP_1_OVER           (1 << 12)   // 温度1超限
#define ALARM_TEMP_2_OVER           (1 << 13)   // 温度2超限
#define ALARM_TEMP_3_OVER           (1 << 14)   // 温度3超限
#define ALARM_PRESSURE_1_OVER       (1 << 15)   // 压力1超限

// 告警字2 (alarm_word2) - 执行器故障+系统故障
#define ALARM_PRESSURE_2_OVER       (1 << 0)    // 压力2超限
#define ALARM_PRESSURE_3_OVER       (1 << 1)    // 压力3超限
#define ALARM_PRESSURE_4_OVER       (1 << 2)    // 压力4超限
#define ALARM_LEVEL_1_OVER          (1 << 3)    // 液位1超限
#define ALARM_LEVEL_2_OVER          (1 << 4)    // 液位2超限
#define ALARM_LEVEL_3_OVER          (1 << 5)    // 液位3超限
#define ALARM_HEATER_1_OVERCURRENT  (1 << 6)    // 加热器1过流
#define ALARM_HEATER_2_OVERCURRENT  (1 << 7)    // 加热器2过流
#define ALARM_HEATER_3_OVERCURRENT  (1 << 8)    // 加热器3过流
#define ALARM_PUMP_1_FAULT          (1 << 9)    // 泵1故障
#define ALARM_PUMP_2_FAULT          (1 << 10)   // 泵2故障
#define ALARM_VALVE_1_FAULT         (1 << 11)   // 阀门1故障
#define ALARM_VALVE_2_FAULT         (1 << 12)   // 阀门2故障
#define ALARM_CONFIG_ERROR          (1 << 13)   // 配置错误
#define ALARM_FLASH_ERROR           (1 << 14)   // Flash错误
#define ALARM_WATCHDOG_RESET        (1 << 15)   // 看门狗复位

#endif // __PROTOCOL_DATA_H
```

---

## 3. TCP/IP 通信协议设计

### 3.1 TCP协议帧格式

```c
// include/common/tcp_protocol.h
#ifndef __TCP_PROTOCOL_H
#define __TCP_PROTOCOL_H

#include "protocol_data.h"

//==============================================================================
// TCP协议帧头定义
//==============================================================================
#define TCP_SYNC_WORD           0xAA55      // 同步字
#define TCP_PROTOCOL_VERSION    0x01        // 协议版本

typedef struct {
    uint16_t sync_word;         // 同步字 0xAA55
    uint8_t  version;           // 协议版本
    uint8_t  cmd;               // 命令字
    uint16_t length;            // 数据长度(不含帧头帧尾)
    uint16_t sequence;          // 序列号
    uint16_t checksum;          // 帧头校验和(CRC16)
} __attribute__((packed)) tcp_frame_header_t;  // 10字节

typedef struct {
    uint16_t crc16;             // 整帧CRC16校验
} __attribute__((packed)) tcp_frame_tail_t;    // 2字节

typedef struct {
    tcp_frame_header_t header;
    uint8_t data[256];          // 最大256字节数据
    tcp_frame_tail_t tail;
} __attribute__((packed)) tcp_protocol_frame_t;

//==============================================================================
// TCP命令字定义 (基于协议表格功能)
//==============================================================================
typedef enum {
    // 数据读取命令 (0x01-0x0F)
    CMD_READ_REALTIME_DATA      = 0x01,     // 读取实时数据
    CMD_READ_SENSOR_DATA        = 0x02,     // 读取传感器数据
    CMD_READ_ACTUATOR_STATUS    = 0x03,     // 读取执行器状态
    CMD_READ_SYSTEM_STATUS      = 0x04,     // 读取系统状态
    CMD_READ_ALARM_INFO         = 0x05,     // 读取告警信息

    // 数据写入命令 (0x10-0x1F)
    CMD_WRITE_SETPOINT          = 0x10,     // 写入设定值
    CMD_WRITE_ACTUATOR_CONTROL  = 0x11,     // 写入执行器控制
    CMD_WRITE_CONTROL_WORD      = 0x12,     // 写入控制字
    CMD_WRITE_CONTROL_DATA      = 0x13,     // 写入完整控制数据

    // 参数配置命令 (0x20-0x2F)
    CMD_READ_PID_PARAMS         = 0x20,     // 读取PID参数
    CMD_WRITE_PID_PARAMS        = 0x21,     // 写入PID参数
    CMD_READ_SENSOR_CONFIG      = 0x22,     // 读取传感器配置
    CMD_WRITE_SENSOR_CONFIG     = 0x23,     // 写入传感器配置
    CMD_READ_ACTUATOR_CONFIG    = 0x24,     // 读取执行器配置
    CMD_WRITE_ACTUATOR_CONFIG   = 0x25,     // 写入执行器配置
    CMD_READ_SAFETY_PARAMS      = 0x26,     // 读取安全参数
    CMD_WRITE_SAFETY_PARAMS     = 0x27,     // 写入安全参数

    // 系统控制命令 (0x30-0x3F)
    CMD_SYSTEM_RESET            = 0x30,     // 系统复位
    CMD_SYSTEM_START            = 0x31,     // 系统启动
    CMD_SYSTEM_STOP             = 0x32,     // 系统停止
    CMD_EMERGENCY_STOP          = 0x33,     // 紧急停止
    CMD_ALARM_ACK               = 0x34,     // 告警确认
    CMD_ALARM_CLEAR_ALL         = 0x35,     // 清除所有告警
    CMD_MODE_SWITCH_AUTO        = 0x36,     // 切换自动模式
    CMD_MODE_SWITCH_MANUAL      = 0x37,     // 切换手动模式
    CMD_FORCE_SAFE_MODE         = 0x38,     // 强制安全模式

    // 配置管理命令 (0x40-0x4F)
    CMD_SAVE_CONFIG             = 0x40,     // 保存配置到Flash
    CMD_LOAD_CONFIG             = 0x41,     // 从Flash加载配置
    CMD_RESTORE_DEFAULT         = 0x42,     // 恢复默认配置
    CMD_BACKUP_CONFIG           = 0x43,     // 备份配置
    CMD_GET_CONFIG_VERSION      = 0x44,     // 获取配置版本

    // 诊断命令 (0x50-0x5F)
    CMD_SELF_TEST               = 0x50,     // 启动自检
    CMD_GET_DIAGNOSTIC_INFO     = 0x51,     // 获取诊断信息
    CMD_GET_ERROR_LOG           = 0x52,     // 获取错误日志
    CMD_CLEAR_ERROR_LOG         = 0x53,     // 清除错误日志
    CMD_GET_PERFORMANCE_DATA    = 0x54,     // 获取性能数据

    // 标定命令 (0x60-0x6F)
    CMD_ENTER_CALIBRATION_MODE  = 0x60,     // 进入标定模式
    CMD_CALIBRATE_SENSOR        = 0x61,     // 标定传感器
    CMD_CALIBRATE_SAVE          = 0x62,     // 保存标定数据
    CMD_CALIBRATE_EXIT          = 0x63,     // 退出标定模式

    // 固件升级命令 (0x70-0x7F)
    CMD_FIRMWARE_UPDATE_START   = 0x70,     // 固件升级开始
    CMD_FIRMWARE_UPDATE_DATA    = 0x71,     // 固件数据传输
    CMD_FIRMWARE_UPDATE_END     = 0x72,     // 固件升级结束
    CMD_FIRMWARE_VERIFY         = 0x73,     // 固件校验
    CMD_GET_FIRMWARE_VERSION    = 0x74,     // 获取固件版本

    // 响应命令 (0x80-0xFF)
    CMD_RESPONSE_OK             = 0x80,     // 响应成功
    CMD_RESPONSE_ERROR          = 0x81,     // 响应错误
    CMD_RESPONSE_DATA           = 0x82,     // 响应数据
    CMD_RESPONSE_BUSY           = 0x83,     // 设备忙
    CMD_RESPONSE_TIMEOUT        = 0x84,     // 超时

} tcp_command_t;

//==============================================================================
// 错误码定义
//==============================================================================
typedef enum {
    ERR_OK                      = 0x00,     // 成功
    ERR_INVALID_CMD             = 0x01,     // 无效命令
    ERR_INVALID_PARAM           = 0x02,     // 无效参数
    ERR_DEVICE_BUSY             = 0x03,     // 设备忙
    ERR_TIMEOUT                 = 0x04,     // 超时
    ERR_CHECKSUM_ERROR          = 0x05,     // 校验错误
    ERR_LENGTH_ERROR            = 0x06,     // 长度错误
    ERR_PERMISSION_DENIED       = 0x07,     // 权限不足
    ERR_NOT_READY               = 0x08,     // 未就绪
    ERR_CONFIG_LOCKED           = 0x09,     // 配置锁定
    ERR_OPERATION_FAILED        = 0x0A,     // 操作失败
    ERR_OUT_OF_RANGE            = 0x0B,     // 参数超出范围
    ERR_FLASH_ERROR             = 0x0C,     // Flash错误
    ERR_CALIBRATION_ERROR       = 0x0D,     // 标定错误
    ERR_UNKNOWN                 = 0xFF,     // 未知错误
} tcp_error_code_t;

//==============================================================================
// TCP协议接口函数
//==============================================================================
// 构造TCP帧
int tcp_build_frame(tcp_protocol_frame_t *frame, uint8_t cmd,
                    const uint8_t *data, uint16_t len);

// 解析TCP帧
int tcp_parse_frame(const tcp_protocol_frame_t *frame, uint8_t *cmd,
                    uint8_t *data, uint16_t *len);

// 发送实时数据
int tcp_send_realtime_data(const realtime_data_t *data);

// 发送控制数据
int tcp_send_control_data(const control_data_t *data);

// 发送响应
int tcp_send_response(uint8_t cmd, uint8_t error_code,
                      const uint8_t *data, uint16_t len);

// CRC16校验计算
uint16_t tcp_calculate_crc16(const uint8_t *data, uint16_t len);

#endif // __TCP_PROTOCOL_H
```

### 3.2 TCP通信示例

#### 3.2.1 上位机读取实时数据
```
请求帧:
+--------+--------+-----+-----+--------+----------+----------+-------+
| 0xAA55 |  0x01  |0x01 | 0x00|  0x00  |  序列号  | CRC16-H  | CRC16 |
| 同步字 | 版本   |命令 |长度 | 长度   |          | 帧头校验 | 帧校验|
+--------+--------+-----+-----+--------+----------+----------+-------+
  2字节    1字节   1字节 2字节        2字节       2字节      2字节

响应帧:
+--------+--------+-----+-----+--------+----------+----------+--------+-------+
| 0xAA55 |  0x01  |0x82 | 0x30|  0x00  |  序列号  | CRC16-H  | 48字节 | CRC16 |
| 同步字 | 版本   |响应 |长度=48      |          | 帧头校验 |实时数据| 帧校验|
+--------+--------+-----+-----+--------+----------+----------+--------+-------+
                                                    realtime_data_t结构
```

#### 3.2.2 上位机写入设定值
```
请求帧:
+--------+--------+-----+-----+--------+----------+----------+--------+-------+
| 0xAA55 |  0x01  |0x10 | 0x16|  0x00  |  序列号  | CRC16-H  | 22字节 | CRC16 |
| 同步字 | 版本   |写入 |长度=22      |          | 帧头校验 |设定值  | 帧校验|
+--------+--------+-----+-----+--------+----------+----------+--------+-------+
                                                    control_setpoint_t结构

响应帧:
+--------+--------+-----+-----+--------+----------+----------+-------+-------+
| 0xAA55 |  0x01  |0x80 | 0x01|  0x00  |  序列号  | CRC16-H  | 0x00  | CRC16 |
| 同步字 | 版本   |成功 |长度=1       |          | 帧头校验 |ERR_OK | 帧校验|
+--------+--------+-----+-----+--------+----------+----------+-------+-------+
```

---

## 4. EtherCAT 通信协议设计

### 4.1 EtherCAT PDO映射

#### 4.1.1 TxPDO (从站→主站) - 实时数据上传

**TxPDO 1 - 传感器+执行器+状态** (对应realtime_data_t)
```c
typedef struct __attribute__((packed)) {
    // 传感器数据 (26字节)
    int16_t  temperature[3];        // 偏移0:  温度 6字节
    uint16_t pressure[4];           // 偏移6:  压力 8字节
    uint16_t level[3];              // 偏移14: 液位 6字节
    uint16_t level_analog;          // 偏移20: 模拟液位 2字节
    uint16_t flow_rate;             // 偏移22: 流量 2字节
    uint16_t level_switch_status;   // 偏移24: 液位开关 2字节

    // 执行器状态 (10字节)
    uint16_t actuator_status1;      // 偏移26: 阀门+泵状态 2字节
    uint16_t actuator_status2;      // 偏移28: 加热器状态 2字节
    uint16_t pump_speed[2];         // 偏移30: 泵速度反馈 4字节
    uint16_t heater_current[3];     // 偏移34: 加热器电流 6字节

    // 系统状态 (12字节)
    uint16_t status_word;           // 偏移40: 状态字 2字节
    uint16_t alarm_word1;           // 偏移42: 告警字1 2字节
    uint16_t alarm_word2;           // 偏移44: 告警字2 2字节
    uint32_t timestamp;             // 偏移46: 时间戳 4字节
    uint16_t cycle_counter;         // 偏移50: 循环计数 2字节

    uint16_t crc16;                 // 偏移52: CRC校验 2字节
} EtherCAT_TxPDO1_t;  // 总计54字节
```

**PDO映射表**:

```
0x1A00 - TxPDO 1 映射
  子索引0: 条目数 = 14
  子索引1: 0x60000110 (温度传感器, 48位 = 6字节)
  子索引2: 0x60000220 (压力传感器, 64位 = 8字节)
  子索引3: 0x60000330 (液位传感器, 96位 = 12字节)
  子索引4: 0x60000410 (流量传感器, 16位)
  子索引5: 0x60000510 (液位开关, 16位)
  子索引6: 0x60000620 (执行器状态, 32位)
  子索引7: 0x60000730 (泵速度, 32位)
  子索引8: 0x60000830 (加热器电流, 48位)
  子索引9: 0x60000910 (状态字, 16位)
  子索引10: 0x60000A20 (告警字, 32位)
  子索引11: 0x60000B20 (时间戳, 32位)
  子索引12: 0x60000C10 (循环计数, 16位)
  子索引13: 0x60000D10 (CRC, 16位)
```

#### 4.1.2 RxPDO (主站→从站) - 控制命令下发

**RxPDO 1 - 设定值+控制命令** (对应control_data_t)
```c
typedef struct __attribute__((packed)) {
    // 设定值 (22字节)
    int16_t  temp_setpoint[3];      // 偏移0:  温度设定 6字节
    uint16_t pressure_setpoint[4];  // 偏移6:  压力设定 8字节
    uint16_t level_setpoint[3];     // 偏移14: 液位设定 6字节
    uint16_t flow_setpoint;         // 偏移20: 流量设定 2字节

    // 控制命令 (6字节)
    uint16_t actuator_control1;     // 偏移22: 阀门+泵控制 2字节
    uint16_t actuator_control2;     // 偏移24: 加热器控制 2字节
    uint16_t pump_speed_cmd[2];     // 偏移26: 泵速度命令 4字节

    // 控制字 (2字节)
    uint16_t control_word;          // 偏移30: 控制字 2字节

    uint16_t watchdog;              // 偏移32: 看门狗计数 2字节
} EtherCAT_RxPDO1_t;  // 总计34字节
```

**PDO映射表**:
```
0x1600 - RxPDO 1 映射
  子索引0: 条目数 = 8
  子索引1: 0x70000110 (温度设定, 48位)
  子索引2: 0x70000220 (压力设定, 64位)
  子索引3: 0x70000330 (液位设定, 48位)
  子索引4: 0x70000410 (流量设定, 16位)
  子索引5: 0x70000520 (执行器控制, 32位)
  子索引6: 0x70000620 (泵速度命令, 32位)
  子索引7: 0x70000710 (控制字, 16位)
  子索引8: 0x70000810 (看门狗, 16位)
```

### 4.2 EtherCAT SDO对象字典 (简化版)

```c
// 关键SDO对象
0x1000: Device Type = 0x00000191 (过程控制设备)
0x1008: Device Name = "InkSupply_Slave"
0x1018: Identity Object
  - Vendor ID: 0x00000001
  - Product Code: 0x00000100
  - Revision: 0x00010000
  - Serial Number: 从Flash读取

0x1C00-0x1C03: Sync Manager配置
0x1A00: TxPDO 1 映射
0x1600: RxPDO 1 映射

// 应用参数 (基于协议表格)
0x6000: 传感器实时数据 (RO)
0x7000: 控制设定值 (RW)
0x8000: PID参数 (RW)
0x9000: 安全限值 (RW)
```

---

## 5. 网络中间件层设计

### 5.1 目录结构

```
middleware/
└── network/                        # 网络中间件
    ├── comm_manager.c/h            # 通信管理器(协议切换核心)
    ├── protocol_adapter.c/h        # 协议适配器
    ├── tcp_protocol.c/h            # TCP协议实现
    ├── ethercat_protocol.c/h       # EtherCAT协议实现
    ├── message_queue.c/h           # 消息队列
    └── network_config.c/h          # 网络配置

app/
├── comm_task.c/h                   # 通信任务(调用中间件)
├── tcp_server.c/h                  # TCP服务器
└── ethercat_app.c/h                # EtherCAT应用
```

### 5.2 通信管理器接口

```c
// middleware/network/comm_manager.h
#ifndef __COMM_MANAGER_H
#define __COMM_MANAGER_H

#include "protocol_data.h"

//==============================================================================
// 协议类型定义
//==============================================================================
typedef enum {
    COMM_PROTOCOL_NONE = 0,
    COMM_PROTOCOL_TCP,              // TCP/IP协议
    COMM_PROTOCOL_ETHERCAT,         // EtherCAT协议
    COMM_PROTOCOL_COUNT
} comm_protocol_t;

//==============================================================================
// 通信模式定义
//==============================================================================
typedef enum {
    COMM_MODE_TCP_ONLY,             // 纯TCP模式
    COMM_MODE_ETHERCAT_ONLY,        // 纯EtherCAT模式
    COMM_MODE_AUTO_SELECT,          // 自动选择(根据连接状态)
} comm_mode_t;

//==============================================================================
// 通信配置结构
//==============================================================================
typedef struct {
    comm_mode_t mode;               // 工作模式
    comm_protocol_t active_protocol; // 当前活动协议
    bool tcp_enabled;               // TCP使能
    bool ethercat_enabled;          // EtherCAT使能
    uint32_t tcp_port;              // TCP端口
    uint32_t ip_address;            // IP地址
} comm_config_t;

//==============================================================================
// 通信状态结构
//==============================================================================
typedef struct {
    bool tcp_connected;             // TCP连接状态
    bool ethercat_connected;        // EtherCAT连接状态
    uint32_t tcp_tx_count;          // TCP发送计数
    uint32_t tcp_rx_count;          // TCP接收计数
    uint32_t ethercat_tx_count;     // EtherCAT发送计数
    uint32_t ethercat_rx_count;     // EtherCAT接收计数
    uint32_t communication_errors;  // 通信错误计数
    uint32_t last_tcp_activity;     // TCP最后活动时间
    uint32_t last_ethercat_activity; // EtherCAT最后活动时间
} comm_status_t;

//==============================================================================
// 统一通信接口 (应用层调用这些接口)
//==============================================================================
// 初始化
hal_status_t comm_manager_init(comm_mode_t mode);

// 发送接口 (自动选择协议)
hal_status_t comm_send_realtime_data(const realtime_data_t *data);
hal_status_t comm_send_sensor_data(const sensor_data_t *data);
hal_status_t comm_send_actuator_status(const actuator_status_t *status);
hal_status_t comm_send_system_status(const system_status_t *status);

// 接收接口 (通过回调返回数据)
typedef void (*comm_data_callback_t)(const void *data, uint16_t len, comm_protocol_t from_protocol);

hal_status_t comm_register_control_callback(comm_data_callback_t callback);
hal_status_t comm_register_setpoint_callback(comm_data_callback_t callback);

// 协议管理
hal_status_t comm_switch_protocol(comm_protocol_t protocol);
hal_status_t comm_set_mode(comm_mode_t mode);
comm_status_t* comm_get_status(void);

// 周期处理 (在通信任务中调用)
void comm_process_task(void);

#endif // __COMM_MANAGER_H
```

### 5.3 协议适配器

```c
// middleware/network/protocol_adapter.h
#ifndef __PROTOCOL_ADAPTER_H
#define __PROTOCOL_ADAPTER_H

#include "protocol_data.h"

//==============================================================================
// 协议适配器接口
//==============================================================================
typedef struct {
    comm_protocol_t type;

    // 生命周期接口
    hal_status_t (*init)(void);
    hal_status_t (*deinit)(void);
    hal_status_t (*start)(void);
    hal_status_t (*stop)(void);

    // 数据接口
    hal_status_t (*send_realtime)(const realtime_data_t *data);
    hal_status_t (*send_control)(const control_data_t *data);
    hal_status_t (*receive)(void *buffer, uint16_t *len);

    // 状态接口
    bool (*is_connected)(void);
    uint32_t (*get_tx_count)(void);
    uint32_t (*get_rx_count)(void);

} protocol_adapter_t;

//==============================================================================
// TCP适配器
//==============================================================================
extern protocol_adapter_t tcp_adapter;

hal_status_t tcp_adapter_init(void);
hal_status_t tcp_adapter_send_realtime(const realtime_data_t *data);
hal_status_t tcp_adapter_receive(void *buffer, uint16_t *len);
bool tcp_adapter_is_connected(void);

//==============================================================================
// EtherCAT适配器
//==============================================================================
extern protocol_adapter_t ethercat_adapter;

hal_status_t ethercat_adapter_init(void);
hal_status_t ethercat_adapter_send_realtime(const realtime_data_t *data);
hal_status_t ethercat_adapter_receive(void *buffer, uint16_t *len);
bool ethercat_adapter_is_connected(void);

#endif // __PROTOCOL_ADAPTER_H
```

---

## 6. 应用层使用示例

### 6.1 传感器任务 (发送数据)

```c
// app/sensor_task.c
#include "comm_manager.h"
#include "sensor_task.h"

void sensor_task(void *pvParameters)
{
    realtime_data_t rt_data;

    while(1) {
        // 1. 采集所有传感器数据
        collect_temperature_sensors(rt_data.sensors.temperature);
        collect_pressure_sensors(rt_data.sensors.pressure);
        collect_level_sensors(rt_data.sensors.level);
        collect_flow_sensor(&rt_data.sensors.flow_rate);
        collect_level_switches(&rt_data.sensors.level_switch_status);

        // 2. 采集执行器状态
        get_actuator_status(&rt_data.actuators);

        // 3. 采集系统状态
        get_system_status(&rt_data.system);

        // 4. 通过统一接口发送 (自动适配TCP或EtherCAT)
        comm_send_realtime_data(&rt_data);

        vTaskDelay(pdMS_TO_TICKS(50));  // 50ms周期
    }
}
```

### 6.2 控制任务 (接收数据)

```c
// app/control_task.c
#include "comm_manager.h"
#include "control_task.h"

// 控制数据接收回调
void control_data_callback(const void *data, uint16_t len, comm_protocol_t from_protocol)
{
    control_data_t *ctrl_data = (control_data_t*)data;

    // 处理设定值
    for(int i = 0; i < 3; i++) {
        float temp_sp = (float)ctrl_data->setpoints.temp_setpoint[i] / 10.0f;
        set_temperature_setpoint(i, temp_sp);
    }

    // 处理执行器控制
    if(ctrl_data->controls.actuator_control1 & CTRL_VALVE_1) {
        set_valve_state(0, true);
    }

    // 处理控制字
    if(ctrl_data->control_word & CTRL_BIT_EMERGENCY_STOP) {
        emergency_stop_all();
    }
}

void control_task_init(void)
{
    // 注册控制数据回调
    comm_register_control_callback(control_data_callback);
}
```

### 6.3 通信任务

```c
// app/comm_task.c
#include "comm_manager.h"

void comm_task(void *pvParameters)
{
    // 初始化通信管理器 (从配置读取模式)
    comm_mode_t mode = get_config_comm_mode();
    comm_manager_init(mode);

    while(1) {
        // 周期处理通信 (接收数据、协议切换等)
        comm_process_task();

        // 监控通信状态
        comm_status_t *status = comm_get_status();
        if(!status->tcp_connected && !status->ethercat_connected) {
            // 通信断开处理
            set_safe_mode();
        }

        vTaskDelay(pdMS_TO_TICKS(10));  // 10ms周期
    }
}
```

---

## 7. 关键设计要点

### 7.1 数据一致性保证

所有数据项**严格遵循协议表格定义**:
- 温度: INT16, 精度0.1°C, 范围-50.0~300.0°C
- 压力: UINT16, 精度0.1kPa
- 液位: UINT16, 精度0.1mm
- 流量: UINT16, 精度0.01L/min
- 状态位: 严格按照协议表格定义的bit位

### 7.2 协议兼容性

**TCP模式**:
- 命令字驱动,支持读写操作
- 帧格式: 帧头+数据+CRC校验
- 适用于远程监控、配置管理

**EtherCAT模式**:
- PDO周期性数据交换(1ms)
- SDO参数配置
- 适用于实时控制

**统一数据结构**:
```c
应用层 → realtime_data_t/control_data_t
         ↓
TCP模式: 封装到TCP帧
EtherCAT模式: 映射到PDO
```

### 7.3 协议切换策略

```c
// 编译时选择 (简单方案)
#define ACTIVE_PROTOCOL COMM_PROTOCOL_ETHERCAT

// 运行时切换 (灵活方案)
comm_set_mode(COMM_MODE_AUTO_SELECT);
// 系统根据连接状态自动选择:
// - EtherCAT主站连接 → 使用EtherCAT
// - 无EtherCAT连接 → 使用TCP
```

### 7.4 实时性考虑

| 协议 | 数据周期 | 延迟 | 适用场景 |
|------|---------|------|---------|
| EtherCAT | 1ms | <1ms | 实时控制,生产环境 |
| TCP/IP | 50-100ms | 10-50ms | 远程监控,调试测试 |

---



---

## 8. 总结

本设计方案**严格基于墨路通信协议表格**,实现了:

✅ **统一数据结构**: 所有数据项对应协议表格定义
✅ **TCP协议完整**: 帧格式+命令字+错误码
✅ **EtherCAT映射**: PDO直接映射协议表格数据
✅ **中间件抽象**: 应用层协议无关
✅ **兼容两种协议**: 编译时或运行时切换

**应用层代码示例**:
```c
// 不关心底层是TCP还是EtherCAT
comm_send_realtime_data(&rt_data);  // 自动适配协议
```

这种设计确保了**协议表格数据项**在TCP和EtherCAT中完全一致,便于开发、测试和维护。
