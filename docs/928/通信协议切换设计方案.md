# 通信协议切换设计方案 (TCP ↔ EtherCAT)

## 1. 设计目标

实现TCP协议和EtherCAT协议的**运行时切换**或**编译时选择**，确保两种协议可以无缝切换，代码复用率最大化。

---

## 2. 切换方式对比

### 2.1 方案A：编译时选择（推荐用于产品）

**优点**：
- 代码体积小，未使用的协议不编译进固件
- 性能最优，无额外开销
- 适合批量生产（EtherCAT版本/TCP版本分开）

**缺点**：
- 需要重新编译固件才能切换
- 不支持运行时动态切换

**实现方式**：通过宏定义选择
```c
// config/protocol_config.h
#define PROTOCOL_USE_ETHERCAT  0
#define PROTOCOL_USE_TCP       1

#if (PROTOCOL_USE_ETHERCAT && PROTOCOL_USE_TCP)
    #error "只能选择一种通信协议"
#endif
```

### 2.2 方案B：运行时切换（推荐用于开发调试）

**优点**：
- 灵活，可通过命令动态切换
- 方便测试和调试
- 单一固件支持多种协议

**缺点**：
- 代码体积较大（两种协议都编译）
- 需要复位系统才能切换
- 内存开销增加

**实现方式**：通过函数指针+配置参数
```c
// 保存到Flash的配置
typedef struct {
    protocol_type_t selected_protocol;  // 0=TCP, 1=EtherCAT
    uint32_t magic;                     // 配置有效性标志
} protocol_config_t;
```

---

## 3. 协议抽象层设计

### 3.1 目录结构修改

在v3设计基础上，增加协议抽象层：

```
middleware/
├── protocol.c/h                    # 通信协议解析 (已有)
├── protocol_abstraction.c/h        # 【新增】协议抽象层
└── protocol_adapter.c/h            # 【新增】协议适配器

app/
├── comm_task.c/h                   # 【修改】统一的通信任务
├── ethercat_app.c/h                # EtherCAT协议实现
└── tcp_server.c/h                  # TCP协议实现
```

### 3.2 数据交换结构（统一数据模型）

```c
// middleware/protocol_abstraction.h

#ifndef __PROTOCOL_ABSTRACTION_H
#define __PROTOCOL_ABSTRACTION_H

#include <stdint.h>
#include <stdbool.h>

// 协议类型
typedef enum {
    PROTOCOL_TYPE_NONE = 0,
    PROTOCOL_TYPE_TCP,
    PROTOCOL_TYPE_ETHERCAT
} protocol_type_t;

// 统一的输出数据（设备→上位机）
typedef struct __attribute__((packed)) {
    // 传感器数据
    int16_t  temp_sensor[3];          // 温度 (0.1°C)
    uint16_t pressure_sensor[4];      // 压力 (0.1kPa)
    uint16_t level_sensor[4];         // 液位 (0.1mm)
    uint16_t flow_sensor;             // 流量 (0.01L/min)
    uint16_t level_switch_status;     // 液位开关状态

    // 执行器反馈
    uint16_t actuator_feedback1;      // 阀门/泵状态
    uint16_t actuator_feedback2;      // 加热器状态
    uint16_t heater_current[3];       // 加热器电流 (0.01A)
    uint16_t pump_speed_feedback[2];  // 泵速度反馈 (0.1%)

    // 控制输出
    int16_t  pid_output[3];           // PID输出 (0.1%)

    // 状态信息
    uint16_t status_word;             // 状态字
    uint16_t alarm_word1;             // 告警字1
    uint16_t alarm_word2;             // 告警字2

    // 诊断信息
    uint32_t diagnostic_counter;      // 诊断计数
    uint32_t timestamp;               // 时间戳 (ms)
} protocol_output_data_t;

// 统一的输入数据（上位机→设备）
typedef struct __attribute__((packed)) {
    // 设定值
    int16_t  temp_setpoint[3];        // 温度设定 (0.1°C)
    uint16_t pressure_setpoint[4];    // 压力设定 (0.1kPa)
    uint16_t level_setpoint[3];       // 液位设定 (0.1mm)
    uint16_t flow_setpoint;           // 流量设定 (0.01L/min)

    // 泵速度控制
    uint16_t pump_speed_cmd[2];       // 泵速度 (0.1%)

    // 控制命令
    uint16_t control_word;            // 控制字
    uint16_t actuator_control1;       // 执行器控制1
    uint16_t actuator_control2;       // 执行器控制2
    uint16_t pid_mode_select;         // PID模式选择

    // 告警控制
    uint16_t alarm_ack;               // 告警确认

    // 看门狗
    uint16_t watchdog;                // 通信看门狗

    // 快速参数访问
    uint16_t param_index;             // 参数索引
    int32_t  param_value;             // 参数值
} protocol_input_data_t;

// 协议接口定义
typedef struct {
    protocol_type_t type;
    const char *name;

    // 初始化/反初始化
    bool (*init)(void);
    void (*deinit)(void);

    // 数据交换（周期调用）
    bool (*update_output)(protocol_output_data_t *output);  // 发送输出数据
    bool (*update_input)(protocol_input_data_t *input);     // 接收输入数据

    // 状态查询
    bool (*is_connected)(void);
    uint32_t (*get_cycle_time)(void);  // 获取通信周期(ms)

    // 可选：配置参数读写（用于SDO/TCP配置命令）
    bool (*read_param)(uint16_t index, uint8_t sub, void *data, uint8_t *len);
    bool (*write_param)(uint16_t index, uint8_t sub, const void *data, uint8_t len);
} protocol_interface_t;

// 全局函数
void protocol_abstraction_init(void);
bool protocol_select(protocol_type_t type);
protocol_type_t protocol_get_current(void);
const protocol_interface_t* protocol_get_interface(void);

// 数据访问接口（供应用层调用）
bool protocol_exchange_data(protocol_output_data_t *output, protocol_input_data_t *input);
bool protocol_is_online(void);

#endif
```

### 3.3 协议抽象层实现

```c
// middleware/protocol_abstraction.c

#include "protocol_abstraction.h"
#include "ethercat_app.h"
#include "tcp_server.h"
#include <string.h>

// 当前选中的协议
static protocol_type_t g_current_protocol = PROTOCOL_TYPE_NONE;
static const protocol_interface_t *g_protocol_interface = NULL;

// 协议注册表
static const protocol_interface_t* g_protocol_registry[] = {
#if PROTOCOL_USE_TCP
    &tcp_protocol_interface,
#endif
#if PROTOCOL_USE_ETHERCAT
    &ethercat_protocol_interface,
#endif
    NULL
};

// 初始化协议抽象层
void protocol_abstraction_init(void)
{
    // 从配置中读取选择的协议
    protocol_type_t selected = protocol_load_config();

    if (selected == PROTOCOL_TYPE_NONE) {
        // 默认协议
#if PROTOCOL_USE_TCP
        selected = PROTOCOL_TYPE_TCP;
#elif PROTOCOL_USE_ETHERCAT
        selected = PROTOCOL_TYPE_ETHERCAT;
#endif
    }

    protocol_select(selected);
}

// 选择并初始化协议
bool protocol_select(protocol_type_t type)
{
    // 关闭当前协议
    if (g_protocol_interface && g_protocol_interface->deinit) {
        g_protocol_interface->deinit();
    }

    g_protocol_interface = NULL;
    g_current_protocol = PROTOCOL_TYPE_NONE;

    // 查找并初始化新协议
    for (int i = 0; g_protocol_registry[i] != NULL; i++) {
        if (g_protocol_registry[i]->type == type) {
            if (g_protocol_registry[i]->init && g_protocol_registry[i]->init()) {
                g_protocol_interface = g_protocol_registry[i];
                g_current_protocol = type;

                printf("协议切换成功: %s\n", g_protocol_interface->name);
                return true;
            } else {
                printf("协议初始化失败: %d\n", type);
                return false;
            }
        }
    }

    printf("未找到协议: %d\n", type);
    return false;
}

// 获取当前协议
protocol_type_t protocol_get_current(void)
{
    return g_current_protocol;
}

// 获取当前协议接口
const protocol_interface_t* protocol_get_interface(void)
{
    return g_protocol_interface;
}

// 数据交换（统一接口）
bool protocol_exchange_data(protocol_output_data_t *output, protocol_input_data_t *input)
{
    if (!g_protocol_interface) {
        return false;
    }

    bool success = true;

    // 发送输出数据
    if (g_protocol_interface->update_output) {
        success &= g_protocol_interface->update_output(output);
    }

    // 接收输入数据
    if (g_protocol_interface->update_input) {
        success &= g_protocol_interface->update_input(input);
    }

    return success;
}

// 检查通信状态
bool protocol_is_online(void)
{
    if (!g_protocol_interface || !g_protocol_interface->is_connected) {
        return false;
    }
    return g_protocol_interface->is_connected();
}
```

---

## 4. 协议适配器实现

### 4.1 TCP协议适配器

```c
// app/tcp_server.c (修改)

#include "protocol_abstraction.h"

// TCP协议的输出数据缓存
static protocol_output_data_t g_tcp_output_data;
static protocol_input_data_t g_tcp_input_data;
static bool g_tcp_input_updated = false;

// TCP协议接口实现
static bool tcp_protocol_init(void);
static void tcp_protocol_deinit(void);
static bool tcp_protocol_update_output(protocol_output_data_t *output);
static bool tcp_protocol_update_input(protocol_input_data_t *input);
static bool tcp_protocol_is_connected(void);
static uint32_t tcp_protocol_get_cycle_time(void);

// 导出TCP协议接口
const protocol_interface_t tcp_protocol_interface = {
    .type = PROTOCOL_TYPE_TCP,
    .name = "TCP/IP",
    .init = tcp_protocol_init,
    .deinit = tcp_protocol_deinit,
    .update_output = tcp_protocol_update_output,
    .update_input = tcp_protocol_update_input,
    .is_connected = tcp_protocol_is_connected,
    .get_cycle_time = tcp_protocol_get_cycle_time,
    .read_param = NULL,   // TCP通过命令实现
    .write_param = NULL
};

static bool tcp_protocol_init(void)
{
    memset(&g_tcp_output_data, 0, sizeof(g_tcp_output_data));
    memset(&g_tcp_input_data, 0, sizeof(g_tcp_input_data));
    g_tcp_input_updated = false;

    // 初始化TCP服务器
    tcp_server_init();

    return true;
}

static void tcp_protocol_deinit(void)
{
    // 关闭TCP服务器
    tcp_server_deinit();
}

static bool tcp_protocol_update_output(protocol_output_data_t *output)
{
    // 将应用层数据复制到TCP缓存
    memcpy(&g_tcp_output_data, output, sizeof(protocol_output_data_t));

    // TCP协议通过主动上报或请求响应发送数据
    // 这里不直接发送，由tcp_server.c中的周期任务处理
    return true;
}

static bool tcp_protocol_update_input(protocol_input_data_t *input)
{
    // 如果TCP收到了新的控制命令，复制到应用层
    if (g_tcp_input_updated) {
        memcpy(input, &g_tcp_input_data, sizeof(protocol_input_data_t));
        g_tcp_input_updated = false;
        return true;
    }
    return false;
}

static bool tcp_protocol_is_connected(void)
{
    return g_tcp_ctx.connected;
}

static uint32_t tcp_protocol_get_cycle_time(void)
{
    return 100;  // TCP默认100ms周期
}

// TCP命令处理函数中，更新输入数据
void tcp_handle_write_setpoint(tcp_server_ctx_t *ctx, tcp_frame_header_t *header, uint8_t *data)
{
    int16_t setpoint = *(int16_t*)data;

    // 更新到统一输入数据结构
    if (header->index >= 0x00 && header->index <= 0x02) {
        g_tcp_input_data.temp_setpoint[header->index] = setpoint;
        g_tcp_input_updated = true;
    }

    // 发送响应...
}
```

### 4.2 EtherCAT协议适配器

```c
// app/ethercat_app.c (修改)

#include "protocol_abstraction.h"

// EtherCAT协议接口实现
static bool ethercat_protocol_init(void);
static void ethercat_protocol_deinit(void);
static bool ethercat_protocol_update_output(protocol_output_data_t *output);
static bool ethercat_protocol_update_input(protocol_input_data_t *input);
static bool ethercat_protocol_is_connected(void);
static uint32_t ethercat_protocol_get_cycle_time(void);

// 导出EtherCAT协议接口
const protocol_interface_t ethercat_protocol_interface = {
    .type = PROTOCOL_TYPE_ETHERCAT,
    .name = "EtherCAT",
    .init = ethercat_protocol_init,
    .deinit = ethercat_protocol_deinit,
    .update_output = ethercat_protocol_update_output,
    .update_input = ethercat_protocol_update_input,
    .is_connected = ethercat_protocol_is_connected,
    .get_cycle_time = ethercat_protocol_get_cycle_time,
    .read_param = ethercat_sdo_read,   // SDO读
    .write_param = ethercat_sdo_write  // SDO写
};

static bool ethercat_protocol_init(void)
{
    // 初始化EtherCAT从站协议栈
    return ethercat_slave_init();
}

static void ethercat_protocol_deinit(void)
{
    ethercat_slave_deinit();
}

static bool ethercat_protocol_update_output(protocol_output_data_t *output)
{
    // 直接映射到TxPDO内存区域
    TxPDO1_t *txpdo = (TxPDO1_t*)ec_slave[0].outputs;

    // 复制数据（结构体字段一一对应）
    memcpy(txpdo->temp_sensor, output->temp_sensor, sizeof(output->temp_sensor));
    memcpy(txpdo->pressure_sensor, output->pressure_sensor, sizeof(output->pressure_sensor));
    // ... 其他字段

    txpdo->status_word = output->status_word;
    txpdo->alarm_word1 = output->alarm_word1;
    txpdo->alarm_word2 = output->alarm_word2;
    txpdo->timestamp = output->timestamp;

    // 计算CRC
    txpdo->crc = calculate_crc16((uint8_t*)txpdo, sizeof(TxPDO1_t) - 2);

    // 发送PDO
    ec_send_processdata();

    return true;
}

static bool ethercat_protocol_update_input(protocol_input_data_t *input)
{
    // 接收PDO
    ec_receive_processdata(EC_TIMEOUTRET);

    // 从RxPDO内存区域读取
    RxPDO1_t *rxpdo = (RxPDO1_t*)ec_slave[0].inputs;

    // 复制数据
    memcpy(input->temp_setpoint, rxpdo->temp_setpoint, sizeof(input->temp_setpoint));
    memcpy(input->pressure_setpoint, rxpdo->pressure_setpoint, sizeof(input->pressure_setpoint));
    // ... 其他字段

    input->control_word = rxpdo->control_word;
    input->actuator_control1 = rxpdo->actuator_control1;
    input->actuator_control2 = rxpdo->actuator_control2;

    return true;
}

static bool ethercat_protocol_is_connected(void)
{
    return (ec_slave[0].state == EC_STATE_OPERATIONAL);
}

static uint32_t ethercat_protocol_get_cycle_time(void)
{
    return 1;  // EtherCAT 1ms周期
}
```

---

## 5. 应用层统一通信任务

修改 `app/comm_task.c`，使用协议抽象层：

```c
// app/comm_task.c

#include "comm_task.h"
#include "protocol_abstraction.h"
#include "sensor_task.h"
#include "actuator_task.h"
#include "control_task.h"

// 通信任务
void comm_task(void *pvParameters)
{
    protocol_output_data_t output_data;
    protocol_input_data_t input_data;

    // 初始化协议抽象层（根据配置选择TCP或EtherCAT）
    protocol_abstraction_init();

    while (1) {
        // 1. 从各任务收集输出数据
        comm_prepare_output_data(&output_data);

        // 2. 通过协议抽象层交换数据
        if (protocol_exchange_data(&output_data, &input_data)) {
            // 3. 将输入数据分发到各任务
            comm_dispatch_input_data(&input_data);
        }

        // 4. 检查通信状态
        if (!protocol_is_online()) {
            // 进入离线模式
            handle_communication_loss();
        }

        // 5. 根据协议周期延时
        uint32_t cycle_time = protocol_get_interface()->get_cycle_time();
        vTaskDelay(pdMS_TO_TICKS(cycle_time));
    }
}

// 准备输出数据
static void comm_prepare_output_data(protocol_output_data_t *output)
{
    sensor_context_t *sensors = get_sensor_context();

    // 温度传感器
    for (int i = 0; i < 3; i++) {
        output->temp_sensor[i] = (int16_t)(sensors->temp_values[i] * 10.0f);
    }

    // 压力传感器
    for (int i = 0; i < 4; i++) {
        output->pressure_sensor[i] = (uint16_t)(sensors->pressure_values[i] * 10.0f);
    }

    // ... 其他传感器和状态

    output->status_word = get_system_status_word();
    output->alarm_word1 = get_alarm_word1();
    output->alarm_word2 = get_alarm_word2();
    output->timestamp = HAL_GetTick();
}

// 分发输入数据
static void comm_dispatch_input_data(protocol_input_data_t *input)
{
    // 处理控制字
    if (input->control_word & CTRL_BIT_ENABLE) {
        system_enable();
    }

    if (input->control_word & CTRL_BIT_EMERGENCY_STOP) {
        emergency_stop();
        return;
    }

    // 更新PID设定值
    for (int i = 0; i < 3; i++) {
        float temp_sp = (float)input->temp_setpoint[i] / 10.0f;
        set_temperature_setpoint(i, temp_sp);
    }

    // 更新执行器控制
    update_actuator_control(input->actuator_control1, input->actuator_control2);

    // 更新泵速度
    update_pump_speed(input->pump_speed_cmd);
}
```

---

## 6. 配置与切换管理

### 6.1 编译时配置

```c
// config/protocol_config.h

#ifndef __PROTOCOL_CONFIG_H
#define __PROTOCOL_CONFIG_H

// ========== 协议选择配置 ==========
// 只能选择一种协议为1，其余为0

#define PROTOCOL_USE_TCP       1   // 使用TCP协议
#define PROTOCOL_USE_ETHERCAT  0   // 使用EtherCAT协议

// 编译检查
#if (PROTOCOL_USE_TCP + PROTOCOL_USE_ETHERCAT) != 1
    #error "必须且只能选择一种通信协议"
#endif

// ========== TCP配置 ==========
#if PROTOCOL_USE_TCP
    #define TCP_SERVER_PORT        8888
    #define TCP_MAX_CONNECTIONS    1
    #define TCP_RX_BUFFER_SIZE     1024
    #define TCP_TX_BUFFER_SIZE     1024
    #define TCP_REPORT_PERIOD_MS   100   // 主动上报周期
#endif

// ========== EtherCAT配置 ==========
#if PROTOCOL_USE_ETHERCAT
    #define ETHERCAT_CYCLE_TIME_MS    1
    #define ETHERCAT_VENDOR_ID        0x00000001
    #define ETHERCAT_PRODUCT_CODE     0x00000100
    #define ETHERCAT_REVISION         0x00010000
#endif

#endif
```

### 6.2 运行时切换（可选）

```c
// app/protocol_switch.c

#include "protocol_abstraction.h"
#include "flash_hal.h"

#define PROTOCOL_CONFIG_ADDR  0x080E0000  // Flash存储地址
#define PROTOCOL_CONFIG_MAGIC 0x5AA5C33C

typedef struct {
    uint32_t magic;
    protocol_type_t protocol;
    uint32_t crc;
} protocol_config_storage_t;

// 保存协议选择到Flash
bool protocol_save_selection(protocol_type_t protocol)
{
    protocol_config_storage_t config;
    config.magic = PROTOCOL_CONFIG_MAGIC;
    config.protocol = protocol;
    config.crc = calculate_crc32((uint8_t*)&config, sizeof(config) - 4);

    return flash_hal_write(PROTOCOL_CONFIG_ADDR, (uint8_t*)&config, sizeof(config));
}

// 从Flash加载协议选择
protocol_type_t protocol_load_config(void)
{
    protocol_config_storage_t config;

    if (flash_hal_read(PROTOCOL_CONFIG_ADDR, (uint8_t*)&config, sizeof(config))) {
        if (config.magic == PROTOCOL_CONFIG_MAGIC) {
            uint32_t crc = calculate_crc32((uint8_t*)&config, sizeof(config) - 4);
            if (crc == config.crc) {
                return config.protocol;
            }
        }
    }

    return PROTOCOL_TYPE_NONE;  // 使用默认协议
}

// 切换协议（需要复位系统）
void protocol_switch_and_reset(protocol_type_t new_protocol)
{
    // 保存配置
    if (protocol_save_selection(new_protocol)) {
        printf("协议配置已保存，即将复位...\n");
        vTaskDelay(pdMS_TO_TICKS(1000));

        // 软件复位
        NVIC_SystemReset();
    }
}
```

---

## 7. 使用示例

### 7.1 编译时选择（产品使用）

**步骤**：
1. 修改 `config/protocol_config.h`：
   ```c
   #define PROTOCOL_USE_TCP       1
   #define PROTOCOL_USE_ETHERCAT  0
   ```

2. 编译固件，TCP版本的固件只包含TCP代码

3. 切换到EtherCAT：
   ```c
   #define PROTOCOL_USE_TCP       0
   #define PROTOCOL_USE_ETHERCAT  1
   ```
   重新编译即可

### 7.2 运行时切换（开发调试）

**步骤**：
1. 修改 `config/protocol_config.h` 启用两个协议：
   ```c
   #define PROTOCOL_USE_TCP       1
   #define PROTOCOL_USE_ETHERCAT  1
   ```

2. 通过USMART命令或TCP命令切换：
   ```c
   // USMART命令
   protocol_switch_and_reset(PROTOCOL_TYPE_ETHERCAT);
   ```

3. 系统复位后，使用新协议运行

---

## 8. 兼容性与迁移

### 8.1 现有代码改动最小化

**不需要改动的部分**：
- `sensor_task.c` - 传感器采集逻辑不变
- `actuator_task.c` - 执行器控制逻辑不变
- `control_task.c` - PID控制逻辑不变
- `safety_task.c` - 安全监控逻辑不变

**需要改动的部分**：
- `ethercat_app.c` - 添加协议接口实现函数
- `tcp_server.c` - 添加协议接口实现函数
- `comm_task.c` - 使用协议抽象层

### 8.2 数据结构统一性验证

由于两个协议的数据格式已经统一：
```c
// 验证数据结构大小一致性
static_assert(sizeof(protocol_output_data_t) == 62, "输出数据大小必须为62字节");
static_assert(sizeof(protocol_input_data_t) == 44, "输入数据大小必须为44字节");
```

---

## 9. 性能对比

| 指标 | TCP协议 | EtherCAT协议 | 说明 |
|------|---------|-------------|------|
| 通信周期 | 100~500ms | 1ms | 可配置 |
| 延迟 | 10~50ms | <1ms | 网络往返时间 |
| CPU占用 | ~5% | ~10% | FreeRTOS任务统计 |
| 内存占用 | 4KB | 8KB | lwIP vs EtherCAT库 |
| 数据吞吐量 | 10KB/s | 62KB/s | 实时数据流量 |
| 实时性 | 中等 | 高 | 同步精度 |
| 代码体积 | +20KB | +40KB | 增加的Flash占用 |

---

## 10. 测试验证

### 10.1 功能测试

**测试项1：编译时切换**
- [ ] TCP版本编译通过，EtherCAT代码未编译
- [ ] EtherCAT版本编译通过，TCP代码未编译
- [ ] 代码体积符合预期

**测试项2：运行时切换**
- [ ] 从TCP切换到EtherCAT，复位后生效
- [ ] 从EtherCAT切换到TCP，复位后生效
- [ ] 配置保存到Flash正确

**测试项3：数据一致性**
- [ ] 传感器数据在两种协议下数值一致
- [ ] 控制命令在两种协议下效果一致
- [ ] 状态字/告警字位定义一致

### 10.2 性能测试

- [ ] TCP协议通信周期稳定在100ms±10ms
- [ ] EtherCAT协议通信周期稳定在1ms±50μs
- [ ] CPU占用率符合预期
- [ ] 内存无泄漏

---

## 11. 总结

### 11.1 设计优势

✅ **代码复用率高**：应用层代码完全共享，只需实现协议适配层
✅ **切换灵活**：支持编译时选择或运行时切换
✅ **维护简单**：统一的数据模型，只需维护一套业务逻辑
✅ **扩展性好**：未来可轻松添加新协议（Modbus/Profinet等）

### 11.2 推荐使用场景

| 场景 | 推荐协议 | 切换方式 |
|------|---------|---------|
| 监控系统 | TCP | 编译时选择 |
| 精确同步控制 | EtherCAT | 编译时选择 |
| 开发调试 | TCP+EtherCAT | 运行时切换 |
| 批量生产 | 根据需求 | 编译时选择 |

### 11.3 后续工作

- [ ] 实现 `protocol_abstraction.c/h` 完整代码
- [ ] 修改 `ethercat_app.c` 添加适配器
- [ ] 修改 `tcp_server.c` 添加适配器
- [ ] 修改 `comm_task.c` 使用抽象层
- [ ] 添加单元测试验证切换功能

---

**文档版本**: v1.0
**编写日期**: 2025-09-30
**编写依据**: 墨路控制系统详细设计文档v3 + TCP通信协议 + EtherCAT通信协议