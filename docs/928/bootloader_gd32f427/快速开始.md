# Bootloader快速开始指南

## 工程文件清单

已创建的核心文件：

### 1. 配置文件 (config/)
- `flash_layout.h` - Flash分区定义（Bootloader 64KB + 配置区 + 双Bank）
- `boot_config.h` - 启动配置数据结构
- `gd32f427_bootloader.ld` - Bootloader链接脚本（0x08000000, 64KB）

### 2. Bootloader核心 (bootloader/)
- `bootloader.h` - Bootloader主程序头文件
- `bootloader.c` - Bootloader主程序实现
- `boot_config.c` - 配置管理实现

### 3. 工具模块 (utils/)
- `crc32.h / crc32.c` - CRC32计算（查表法）
- `flash_hal.h / flash_hal.c` - Flash HAL抽象层

### 4. 用户代码 (USER/)
- `main.c` - 主函数入口

## 完成Keil工程的步骤

由于时间关系，完整的Keil工程还需要以下文件（可从按键实验或GD32官方库复制）：

### 需要从"实验2 按键输入实验"复制的文件：

1. **CORE目录**：
   - `core_cm4.h`
   - `core_cmFunc.h`
   - `core_cmInstr.h`
   - `core_cmSimd.h`
   - `startup_gd32f4xx.s` （启动文件）

2. **HALLIB目录**：
   从GD32F4标准库复制以下必需文件：
   ```
   inc/:
   - gd32f4xx.h
   - gd32f4xx_fmc.h        (Flash控制)
   - gd32f4xx_rcu.h        (时钟控制)
   - gd32f4xx_gpio.h       (GPIO)
   - system_gd32f4xx.h

   src/:
   - gd32f4xx_fmc.c
   - gd32f4xx_rcu.c
   - gd32f4xx_gpio.c
   - system_gd32f4xx.c
   ```

3. **SYSTEM目录**：
   - `delay/delay.c` - 延时函数
   - `usart/usart.c` - 串口调试（可选）

4. **HARDWARE目录**（可选）：
   - `LED/led.c` - LED驱动
   - `KEY/key.c` - 按键驱动

### 快速复制命令（Windows）：

```bash
cd E:\molu\ink_supply_system_gd32f427\docs\928

# 复制CORE文件
xcopy "实验2 按键输入实验\CORE" "bootloader_gd32f427\CORE" /E /I /Y

# 复制HALLIB文件（选择需要的）
xcopy "实验2 按键输入实验\HALLIB" "bootloader_gd32f427\HALLIB" /E /I /Y

# 复制SYSTEM文件
xcopy "实验2 按键输入实验\SYSTEM" "bootloader_gd32f427\SYSTEM" /E /I /Y

# 复制HARDWARE文件
xcopy "实验2 按键输入实验\HARDWARE" "bootloader_gd32f427\HARDWARE" /E /I /Y
```

## 使用说明

### 方案1：基于现有工程修改

最简单的方法是基于"实验2 按键输入实验"修改：

1. 复制整个"实验2 按键输入实验"文件夹，重命名为"bootloader_gd32f427"
2. 将我创建的文件覆盖到对应目录
3. 在Keil工程中：
   - 修改链接脚本为 `gd32f427_bootloader.ld`
   - 添加源文件：`bootloader.c`, `boot_config.c`, `crc32.c`, `flash_hal.c`
   - 修改 `USER/main.c` 为新版本
   - 添加头文件路径：`config/`, `bootloader/`, `utils/`

### 方案2：独立创建Keil工程

1. 打开Keil MDK
2. 新建工程，选择GD32F427VE芯片
3. 按照README.md的说明添加所有源文件
4. 配置编译选项和链接脚本
5. 编译测试

## 测试流程

### 第一步：编译Bootloader
1. 完成工程搭建
2. 编译通过后生成 `bootloader.bin` 或 `bootloader.hex`

### 第二步：烧录Bootloader
使用J-Link/ST-Link将Bootloader烧录到 `0x08000000`

### 第三步：测试应用程序跳转
1. 修改按键实验的链接脚本，起始地址改为 `0x08014000`
2. 在应用程序main()开头添加：`SCB->VTOR = 0x08014000;`
3. 编译应用程序
4. 烧录应用程序到 `0x08014000`
5. 复位芯片，观察Bootloader是否能跳转到应用程序

## 调试建议

1. **启用UART调试**：
   - 定义 `BOOTLOADER_DEBUG` 宏
   - 连接UART0（PA9/PA10）到串口工具
   - 波特率115200，查看启动日志

2. **LED指示**：
   - 实现 `boot_led_set()` 和 `boot_led_toggle()` 函数
   - 使用LED观察Bootloader状态

3. **使用调试器**：
   - 设置断点在 `bootloader_main()`
   - 单步调试，查看配置扇区读取
   - 观察跳转前的寄存器状态

## 下一步工作

1. **完善硬件驱动**：
   - 实现LED控制函数
   - 实现按键检测函数
   - 实现UART调试输出

2. **测试OTA功能**：
   - 开发应用程序的OTA管理器
   - 实现TCP/UART固件接收
   - 测试Bank A/B切换

3. **安全增强**：
   - 添加固件签名验证
   - 实现Flash写保护
   - 添加安全启动

## 技术支持

如有问题，请参考：
- `README.md` - 完整的使用说明
- `../OTA固件升级设计方案.md` - 详细的设计文档
- GD32F4xx参考手册

---
创建日期：2025-09-30