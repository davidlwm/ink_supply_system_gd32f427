# TCP/EtherCAT 双协议兼容性设计说明

## 1. 兼容性设计核心思想

### 1.1 为什么两种协议可以兼容？

两种协议之间的兼容性并不是指它们可以同时运行，而是指在同一套硬件和软件架构上，可以通过配置选择其中一种协议运行。兼容性体现在以下几个方面：

#### 1.1.1 数据结构统一
```c
// 核心：所有协议都操作相同的数据结构
typedef struct {
    int16_t temperature[3];      // 温度数据
    uint16_t pressure[4];        // 压力数据
    uint16_t level[4];           // 液位数据
    uint16_t flow_rate;          // 流量数据
    // ...其他字段相同
} sensor_data_t;  // TCP和EtherCAT都使用这个结构
```

#### 1.1.2 抽象接口层
```c
// 关键：定义统一的通信接口
typedef struct {
    comm_protocol_t protocol_type;
    int (*send_sensor_data)(const sensor_data_t* data);  // 发送接口
    int (*receive_control_cmd)(actuator_control_t* control); // 接收接口
    // ...其他接口相同
} comm_interface_t;
```

## 2. 兼容性实现机制

### 2.1 协议选择机制
```
系统启动
    ↓
读取配置参数
    ↓
if (config == TCP) → 初始化TCP接口
if (config == EtherCAT) → 初始化EtherCAT接口
    ↓
应用层使用统一接口调用
```

### 2.2 数据映射对比

| 数据类型 | TCP传输方式 | EtherCAT传输方式 | 统一数据结构 |
|---------|------------|-----------------|-------------|
| 温度数据 | TCP包中data字段 | 输入PDO映射区 | `sensor_data_t.temperature[3]` |
| 压力数据 | TCP包中data字段 | 输入PDO映射区 | `sensor_data_t.pressure[4]` |
| 控制命令 | TCP包解析 | 输出PDO映射区 | `actuator_control_t` |
| 系统状态 | TCP包data字段 | 输入PDO状态区 | `system_status_t` |

### 2.3 应用层调用示例
```c
// 应用层代码完全相同，不需要关心底层协议
void application_main_loop(void) {
    sensor_data_t sensor_data;
    actuator_control_t control_cmd;

    // 1. 采集数据
    collect_sensor_data(&sensor_data);

    // 2. 发送数据 (自动适配TCP或EtherCAT)
    app_send_sensor_data(&sensor_data);

    // 3. 接收控制命令 (自动适配TCP或EtherCAT)
    if (app_receive_control_command(&control_cmd) == 0) {
        execute_actuator_control(&control_cmd);
    }
}
```

## 3. 协议差异处理

### 3.1 时序差异处理

#### TCP协议特点：
- **异步通信**：发送和接收可以在不同时间
- **事件驱动**：socket事件触发数据处理
- **缓冲机制**：使用队列缓存收发数据

```c
// TCP实现：异步事件处理
static void tcp_process_task(void) {
    fd_set readfds;
    select(FD_SETSIZE, &readfds, NULL, NULL, &timeout);
    // 事件驱动处理
}
```

#### EtherCAT协议特点：
- **同步通信**：严格按1ms周期同步
- **中断驱动**：SYNC0中断触发数据交换
- **直接映射**：PDO数据直接内存映射

```c
// EtherCAT实现：同步中断处理
void ethercat_sync0_callback(void) {
    // 1ms周期同步触发
    vTaskNotifyGiveFromISR(sensor_task_handle, &xHigherPriorityTaskWoken);
}
```

### 3.2 数据传输方式差异

#### TCP协议：
```c
// 构造数据包 → 计算校验和 → socket发送
tcp_protocol_frame_t* frame = create_tcp_frame(CMD_REALTIME_DATA);
memcpy(frame->data, sensor_data, sizeof(sensor_data_t));
frame->header.checksum = calculate_checksum();
send(socket, frame, frame->header.length, 0);
```

#### EtherCAT协议：
```c
// 直接更新PDO内存映射区域
memcpy(ecat_ctx.input_pdo->temperature, data->temperature, sizeof(data->temperature));
// 硬件自动处理传输
```

### 3.3 错误处理差异

#### TCP协议错误处理：
- 连接断开检测
- 超时重传
- 校验和验证
- 应用层确认

#### EtherCAT协议错误处理：
- 状态机监控
- 看门狗超时
- 分布式时钟同步
- 硬件层错误检测

## 4. 兼容性优势分析

### 4.1 开发优势
```c
// 同一套应用代码支持两种协议
void sensor_task(void* parameter) {
    sensor_data_t data;

    while(1) {
        collect_sensor_data(&data);

        // 这行代码自动适配TCP或EtherCAT
        app_send_sensor_data(&data);

        vTaskDelay(pdMS_TO_TICKS(100));
    }
}
```

### 4.2 部署灵活性
- **研发阶段**：使用TCP协议，便于调试和测试
- **生产阶段**：切换到EtherCAT协议，提供高实时性
- **不同客户需求**：同一套固件支持不同通信需求

### 4.3 维护便利性
- 应用逻辑代码统一，减少维护工作量
- 协议问题隔离在接口层，便于定位故障
- 支持协议热切换（重启后生效）

## 5. 实际运行场景

### 5.1 TCP模式运行场景
```
上位机 ←─TCP/IP以太网─→ 墨路控制器
        100ms周期数据交换
        自定义TCP协议帧
        适用于监控和配置
```

**启动流程**：
1. 系统读取配置：`protocol = COMM_PROTOCOL_TCP`
2. 初始化TCP接口：`g_comm_interface = &tcp_interface`
3. 创建socket服务器，等待上位机连接
4. 应用层通过统一接口收发数据

### 5.2 EtherCAT模式运行场景
```
EtherCAT主站 ←─EtherCAT总线─→ 墨路控制器(从站)
              1ms周期同步
              PDO过程数据交换
              适用于实时控制
```

**启动流程**：
1. 系统读取配置：`protocol = COMM_PROTOCOL_ETHERCAT`
2. 初始化EtherCAT接口：`g_comm_interface = &ethercat_interface`
3. 初始化EtherCAT从站，等待主站连接
4. 应用层通过统一接口进行PDO数据交换

## 6. 关键设计要点

### 6.1 为什么不能同时运行？
- **硬件资源冲突**：以太网PHY只有一个
- **实时性要求冲突**：EtherCAT需要独占网络带宽
- **中断优先级冲突**：SYNC0中断与TCP socket中断冲突
- **内存资源限制**：MCU内存无法同时支持两套协议栈

### 6.2 切换机制设计
```c
int communication_switch_protocol(comm_protocol_t new_protocol) {
    // 1. 停止当前协议任务
    // 2. 清理资源
    // 3. 重新初始化目标协议
    // 4. 更新全局接口指针

    return communication_init(new_protocol);
}
```

### 6.3 数据一致性保证
```c
// 使用统一的数据单位和精度
#define TEMP_SCALE_FACTOR    100    // 温度精度 0.01°C
#define PRESSURE_SCALE_FACTOR 10     // 压力精度 0.1kPa
#define LEVEL_SCALE_FACTOR   10     // 液位精度 0.1mm
#define FLOW_SCALE_FACTOR    100    // 流量精度 0.01L/min
```

## 7. 性能对比

| 特性指标 | TCP模式 | EtherCAT模式 |
|---------|---------|-------------|
| 数据周期 | 50-100ms | 1ms |
| 延迟抖动 | 10-50ms | <1μs |
| CPU占用 | 5-10% | 15-20% |
| 内存占用 | 32KB | 64KB |
| 实时确定性 | 软实时 | 硬实时 |
| 开发复杂度 | 中等 | 高 |
| 调试便利性 | 高 | 中等 |

## 8. 总结

通过这种兼容性设计，墨路控制系统可以：

1. **统一应用层代码**：无论使用哪种协议，业务逻辑代码完全相同
2. **灵活适应需求**：根据实际应用场景选择合适的通信协议
3. **降低开发成本**：一套代码支持两种部署方式
4. **便于产品升级**：可从TCP模式平滑升级到EtherCAT模式

**兼容性的本质**不是两种协议能同时工作，而是同一套软硬件架构能够支持两种不同的通信方式，通过抽象接口层实现上层应用的协议无关性。

---

*版本: v1.0*
*最后更新: 2025-09-28*